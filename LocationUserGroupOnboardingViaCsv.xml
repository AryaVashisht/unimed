<channel version="3.9.1">
  <id>f6261a9b-8e35-45c7-bf71-eaf64d284e8c</id>
  <nextMetaDataId>3</nextMetaDataId>
  <name>LocationUserGroupOnboardingViaCsv</name>
  <description>This channel onboards locations on unimed along with 2 usergroups - one is local admin for each location, other is usergroup of physician type of user for particular location.</description>
  <revision>7</revision>
  <sourceConnector version="3.9.1">
    <metaDataId>0</metaDataId>
    <name>sourceConnector</name>
    <properties class="com.mirth.connect.connectors.file.FileReceiverProperties" version="3.9.1">
      <pluginProperties/>
      <pollConnectorProperties version="3.9.1">
        <pollingType>INTERVAL</pollingType>
        <pollOnStart>false</pollOnStart>
        <pollingFrequency>5000</pollingFrequency>
        <pollingHour>0</pollingHour>
        <pollingMinute>0</pollingMinute>
        <cronJobs/>
        <pollConnectorPropertiesAdvanced>
          <weekly>true</weekly>
          <inactiveDays>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
            <boolean>false</boolean>
          </inactiveDays>
          <dayOfMonth>1</dayOfMonth>
          <allDay>true</allDay>
          <startingHour>8</startingHour>
          <startingMinute>0</startingMinute>
          <endingHour>17</endingHour>
          <endingMinute>0</endingMinute>
        </pollConnectorPropertiesAdvanced>
      </pollConnectorProperties>
      <sourceConnectorProperties version="3.9.1">
        <responseVariable>None</responseVariable>
        <respondAfterProcessing>true</respondAfterProcessing>
        <processBatch>false</processBatch>
        <firstResponse>false</firstResponse>
        <processingThreads>1</processingThreads>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
        <queueBufferSize>1000</queueBufferSize>
      </sourceConnectorProperties>
      <scheme>FILE</scheme>
      <host>${baseDirectoryPath}/receivedLocCsv</host>
      <fileFilter>*.csv</fileFilter>
      <regex>false</regex>
      <directoryRecursion>false</directoryRecursion>
      <ignoreDot>true</ignoreDot>
      <anonymous>true</anonymous>
      <username>anonymous</username>
      <password>anonymous</password>
      <timeout>10000</timeout>
      <secure>true</secure>
      <passive>true</passive>
      <validateConnection>true</validateConnection>
      <afterProcessingAction>MOVE</afterProcessingAction>
      <moveToDirectory>${baseDirectoryPath}/processedLocCsv</moveToDirectory>
      <moveToFileName>${originalFilename}</moveToFileName>
      <errorReadingAction>MOVE</errorReadingAction>
      <errorResponseAction>AFTER_PROCESSING</errorResponseAction>
      <errorMoveToDirectory>${baseDirectoryPath}/failedLocCsv</errorMoveToDirectory>
      <errorMoveToFileName>${originalFilename}</errorMoveToFileName>
      <checkFileAge>true</checkFileAge>
      <fileAge>1000</fileAge>
      <fileSizeMinimum>0</fileSizeMinimum>
      <fileSizeMaximum></fileSizeMaximum>
      <ignoreFileSizeMaximum>true</ignoreFileSizeMaximum>
      <sortBy>date</sortBy>
      <binary>false</binary>
      <charsetEncoding>DEFAULT_ENCODING</charsetEncoding>
    </properties>
    <transformer version="3.9.1">
      <elements>
        <com.mirth.connect.plugins.javascriptstep.JavaScriptStep version="3.9.1">
          <name>test</name>
          <sequenceNumber>0</sequenceNumber>
          <enabled>true</enabled>
          <script>//imported packages
importPackage(Packages.org.apache.http.client);
importPackage(Packages.org.apache.http.client.methods);
importPackage(Packages.org.apache.http.impl.client);
importPackage(Packages.org.apache.http.message);
importPackage(Packages.org.apache.http.client.entity);
importPackage(Packages.org.apache.http.entity);
importPackage(Packages.org.apache.http.util);
importPackage(Packages.org.apache.http.ssl);
importPackage(Packages.org.apache.http.conn);
importPackage(Packages.org.apache.http.conn.ssl);
importPackage(Packages.org.apache.http.client.config);

//global variables
logger.info(&quot;The message received from custom sheet is - &quot;+msg)
var numberOfColumn = 11
var count=0;
var locId;

var respId;
var mainOrgId;
var failed = &quot;FAILED&quot;
var success = &quot;SUCCESS&quot;
var warning = &quot;WARNING&quot;
var reportMap = {}
reportMap.report = &quot;&quot;
var orgId;
var orgURL = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).organizationCreateUpdateUrl
var token = configurationMap.get(&apos;xAuthToken&apos;)
var locOrgId;
var orgUpdateUrl;

//unimedDoBrasil org creation
var orgJson = {
			&quot;identifier&quot;: [{  &quot;value&quot;: &quot;48090146000100&quot;  }],
    			&quot;name&quot;: &quot;UNIMED DO BRASIL&quot;,  
    			&quot;resourceType&quot;: &quot;Organization&quot;
			}
		logger.info(&quot;main orgJson is - &quot;+JSON.stringify(orgJson))
	
	var mainOrgReqParams = new java.util.HashMap()
	
		//checking if udb exists then id, or else  create new
		mainOrgReqParams.put(&apos;keyName&apos;, &apos;identifier.value.value&apos;)
		mainOrgReqParams.put(&apos;keyValue&apos;, &apos;48090146000100&apos;)
		logger.info(&quot;mainOrgReqParams - &quot;+mainOrgReqParams)

	     var queryMap ={}
		var mainOrgQuery= new Packages.com.mongodb.BasicDBObject(mainOrgReqParams.get(&apos;keyName&apos;),mainOrgReqParams.get(&apos;keyValue&apos;))
		queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).orgCollectionName
		logger.info(&quot;org collection name - &quot;+queryMap.collectionName)
		queryMap.find = mainOrgQuery
		var mainOrgData = MongoGlobalService(&quot;search&quot;,queryMap)
		if(mainOrgData.totalCount&gt;0){
			//update main org
			var cursor = mainOrgData.message
			var lookUpEntry = JSON.parse(cursor.next())
			mainOrgId = lookUpEntry._id			
			logger.info(&quot;unimed do brasil organization, found main org at id - &quot;+mainOrgId)
	
		}
		else{
			//create main org
			logger.info(&quot;creating new unimed do brasil organization&quot;)
			var attr = new java.util.HashMap()
				attr.put(&quot;token&quot;,token)
				attr.put(&quot;url&quot;,orgURL)
				logger.info(&quot;org create url is - &quot;+orgURL)
				var OrgResponse = api_Request(orgJson,attr,&quot;POST&quot;)
				mainOrgId = respId;
				if(OrgResponse.getStatusLine().getStatusCode()==200){
					logger.info(&quot;Unimed Do Brasil org created successfully with id-&quot;+respId)
				}else{
					logger.info(&quot;Unimed Do Brasil org not created&quot;)
				}
}

for each(seg in msg.children()){    
	logger.info(&quot;seg is - &quot;+seg)
	reportMap.status = &quot;&quot;;
     reportMap.errMessage = &quot;&quot;;
     var row = (SerializerFactory.getSerializer(&apos;DELIMITED&apos;).fromXML(seg)).replace(&apos;\n&apos;, &apos;&apos;)
	logger.info(&quot;WORKING_FOR_ROW &quot;+ count + &quot; | VALUES : &quot;+row);

	checkNumberOfColumn(seg)
	
		if(count==0){
			reportMap.report = row + &quot;,Status,Filter Reason\n&quot;;
		}
		else
		{
			try{
				//read data from csv
				var dataMap = getDataFromCsv(seg);
				//validate data of csv
				validateDataMap(dataMap);	
				logger.info(&quot;received data map is after getDataFromCsv - &quot;+dataMap)
				
				
				//values of csv to usergroup and location collection entry
				var resp1 = createORupdateLocation(dataMap)
				var resp2 = createORupdateUserGroup(dataMap,locId,locOrgId)
				
				if(resp1){
					logger.info(&quot;response from createORupdateOrg is getting receive&quot;)
				}
				else{
					logger.info(&quot;no response from createORupdateOrg&quot;)
				}
				if(resp2){
					logger.info(&quot;response from createORupdateUserGroup is getting receive&quot;)
				}
				else{
					logger.info(&quot;no response from createORupdateUserGroup&quot;)
				}
				}
			catch(ex) {
				if (reportMap.errMessage) {
					logger.error(ex + ex.stack)
							}
				else {
					errorPopulation(&quot;EXCEPTION_WHILE_PARSING_ROW : &quot; + count);
					logger.error(reportMap.errMessage + &quot; : &quot; + ex + ex.stack);
					}
				}
	reportMap.report = reportMap.report + row + &quot;,&quot; + reportMap.status + &quot;,&quot; + reportMap.errMessage + &quot;\n&quot;;
	   }
	   
	
	count++;
	logger.info(&quot;count is - &quot;+count)
	
	}

logger.info(&quot;calling create or update global admin userGroup&quot;)
createOrUpdateGlobalAdminUserGroup()
	
channelMap.put(&apos;report&apos;, reportMap.report);
var date = new Date().toISOString().slice(0, 16)
var userGroupAndLocationCsvToSend = &quot;userGroupAndLocationFilterReport&quot; + date + &quot;.csv&quot;
logger.info(&quot;sending report with name - &quot;+userGroupAndLocationCsvToSend)

channelMap.put(&apos;userGroupAndLocationCsvToSend&apos;, userGroupAndLocationCsvToSend)

function checkNumberOfColumn(seg) {
	if (seg.children().length() != numberOfColumn) {
		errorPopulation(&quot;NUMBER_OF_COLUMN_MISMATCH : &quot; + seg.children().length(), true);
	}
}

function errorPopulation(errMessage, throwExp) {
	reportMap.errMessage = reportMap.errMessage ? reportMap.errMessage + &quot; | &quot; + errMessage: errMessage;
	reportMap.status = failed;
	logger.error(errMessage);
	if (throwExp) {
		throw (errMessage)
	}
}

function successPopulation(message) {
	reportMap.status = success;
	logger.info(success + &quot;: &quot; + message);
}

function getDataFromCsv(seg) 
{
try{
	var dataMap =  new java.util.HashMap()
     logger.info(&quot;PARSING_DATA_FROM_CSV_ROW for seg - &quot;+seg);

    dataMap.put(&quot;userGroupType&quot;, seg[&apos;userGroupType&apos;].toString() ? seg[&apos;userGroupType&apos;].toString().trim() : &quot;&quot;)
    dataMap.put(&quot;userGroupName&quot;, seg[&apos;userGroupName&apos;].toString() ? seg[&apos;userGroupName&apos;].toString().trim() : &quot;&quot;)
    
    dataMap.put(&quot;facilityCode&quot;, seg[&apos;facilityCode&apos;].toString() ? seg[&apos;facilityCode&apos;].toString().trim() : &quot;&quot;) 
    dataMap.put(&quot;locationName&quot;,seg[&apos;locationName&apos;].toString() ? seg[&apos;locationName&apos;].toString().trim() : &quot;&quot;) 
    
    dataMap.put(&quot;cityCode&quot;, seg[&apos;cityCode&apos;].toString() ? seg[&apos;cityCode&apos;].toString().trim() : &quot;&quot;) 
    dataMap.put(&quot;city&quot;,seg[&apos;city&apos;].toString() ? seg[&apos;city&apos;].toString().trim() : &quot;&quot;)
    dataMap.put(&quot;zipCode&quot;,seg[&apos;zipCode&apos;].toString() ? seg[&apos;zipCode&apos;].toString().trim() : &quot;&quot;) 
    dataMap.put(&quot;stateCode&quot;,seg[&apos;stateCode&apos;].toString() ? seg[&apos;stateCode&apos;].toString().trim() : &quot;&quot;) 
    dataMap.put(&quot;state&quot;,seg[&apos;state&apos;].toString() ? seg[&apos;state&apos;].toString().trim() : &quot;&quot;) 

    dataMap.put(&quot;facilityAddressText&quot;,seg[&apos;facilityAddressText&apos;].toString() ? seg[&apos;facilityAddressText&apos;].toString().trim() : &quot;&quot;) 
	dataMap.put(&quot;CNPJ&quot;,seg[&apos;CNPJ&apos;].toString() ? seg[&apos;CNPJ&apos;].toString().trim() : &quot;&quot;) 	

    
    logger.info(&quot;Value in dataMap in getDataFromCsv fun is - &quot;+dataMap)
    
			
    return dataMap;
	}
    catch(e){
    	logger.info(&quot;COULD_NOT_READ_DATA_FROM_CSV - &quot;+e)
    	errorPopulation(&quot;COULD_NOT_READ_DATA_FROM_CSV&quot;, true)
    }
}

function validateDataMap(map) {
    logger.info(&quot;GOING_TO_VALIDATE_CSV_DATA with datamap value - &quot;+map);

	var userGroupName = map.get(&quot;userGroupName&quot;);
	var userGroupType = map.get(&quot;userGroupType&quot;);
	
    if(!userGroupName){
        errorPopulation(&quot;EMPTY_FIELD_UERRGROUP_NAME&quot;);
    }

	
	if (!userGroupType || (userGroupType &amp;&amp; !userGroupType.match(/^[\w]+$/))) {
		errorPopulation(userGroupType ? &quot;INVALID_FIELD_USERGROUP_TYPE&quot;: &quot;EMPTY_FIELD_UERRGROUP_TYPE&quot;)
	}
	
    
  
    var locationName = map.get(&quot;locationName&quot;);
    var facilityCode = map.get(&quot;facilityCode&quot;);
    var cityCode = map.get(&quot;cityCode&quot;);
    var stateCode = map.get(&quot;stateCode&quot;);
	
	if (!facilityCode || (facilityCode &amp;&amp; !facilityCode.length)) {
		errorPopulation(&quot;EMPTY_FACILITY_CODE&quot;);
	}

	if (!cityCode || (cityCode &amp;&amp; !cityCode.length)) {
		errorPopulation(&quot;EMPTY_CITY_CODE&quot;);
	}
	if (!stateCode || (stateCode &amp;&amp; !stateCode.length)) {
		errorPopulation(&quot;EMPTY_STATE_CODE&quot;);
	}
	
	if (!locationName || (locationName &amp;&amp; !locationName.length)) {
		errorPopulation(&quot;EMPTY_FIELD_LOCATION_NAME&quot;);
	}
	

	if (reportMap.errMessage) {
		throw (reportMap.errMessage)
	}
}



function createORupdateLocation(map)
{
	logger.info(&quot;Inside createORupdateLocation method with map - &quot;+map)
	
	try{
	var request;
	var attr = new java.util.HashMap()
	attr.put(&quot;token&quot;,token)

	logger.info(&quot;creating loc based organization&quot;)
	//new org create
			var locOrgJson = {
					 &quot;identifier&quot;: [{  &quot;value&quot;: dataMap.get(&quot;CNPJ&quot;)  }],
    					&quot;name&quot;: dataMap.get(&quot;locationName&quot;),  
    					&quot;resourceType&quot;: &quot;Organization&quot;,
    					&quot;partOf&quot;: { &quot;reference&quot;: mainOrgId }
				}
				logger.info(&quot;new orgJson is - &quot;+JSON.stringify(orgJson))

var locOrgReqParams = new java.util.HashMap()
		locOrgReqParams.put(&apos;keyName&apos;, &apos;identifier.value.value&apos;)
		locOrgReqParams.put(&apos;keyValue&apos;, map.get(&quot;CNPJ&quot;))
		logger.info(&quot;locOrgReqParams - &quot;+locOrgReqParams)

	     var queryMap ={}
		var locOrgQuery= new Packages.com.mongodb.BasicDBObject(locOrgReqParams.get(&apos;keyName&apos;),locOrgReqParams.get(&apos;keyValue&apos;))
		queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).orgCollectionName
		queryMap.find = locOrgQuery
		var locOrgData = MongoGlobalService(&quot;search&quot;,queryMap)
		
		if(locOrgData.totalCount&gt;0){
			
			//update loc org
			var cursor_o = locOrgData.message
			var lookUpEntry_o = JSON.parse(cursor_o.next())
			locOrgId = lookUpEntry_o._id
		logger.info(&quot;location based org found with id - &quot;+locOrgId)	
//			var attr = new java.util.HashMap()
//				attr.put(&quot;token&quot;,token)
//				orgUpdateUrl = orgUrl+locOrgId
//				logger.info(&quot;location organization update url - &quot;+orgUpdateUrl)
//				attr.put(&quot;url&quot;,orgUpdateUrl)
//				
//				var OrgResponse = api_Request(locOrgJson,attr,&quot;PUT&quot;)
//				if(OrgResponse.getStatusLine().getStatusCode()==200){
//					
//					logger.info(&quot;loc org updated successfully&quot;)
//				}else{
//					logger.info(&quot;loc org not updated&quot;)
//				}

				var locationReqParams = new java.util.HashMap()
	     locationReqParams.put(&apos;keyName&apos;, &apos;identifier.value.value&apos;)
	     locationReqParams.put(&apos;keyValue&apos;, map.get(&quot;facilityCode&quot;))

	     var locationData = findLocation(locationReqParams)
		
	if(locationData.totalCount &gt; 0){
		var cursor = locationData.message
		var lookUpEntry = JSON.parse(cursor.next())
		var locationId = lookUpEntry._id
		logger.info(&quot;locationId found in createORupdateLocation fun - &quot;+locationId)
		//update code here
		var locationUpdateApi = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).locationUpdateUrl + locationId
		var location_json={
	               &quot;mode&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).locationMode,
                &quot;name&quot;:{&quot;value&quot;: map.get(&quot;locationName&quot;)},
                &quot;identifier&quot;:[{&quot;value&quot;:map.get(&quot;facilityCode&quot;),&quot;useCode&quot;:&quot;usual&quot;,&quot;type&quot;:{&quot;text&quot;:&quot;performingLocationId&quot;}},
               		 { &quot;value&quot;: map.get(&quot;CNPJ&quot;),&quot;useCode&quot;: &quot;usual&quot;,&quot;type&quot;: {&quot;text&quot;:&quot;CNPJ&quot;}}],
                &quot;description&quot;:&quot;\n&quot;,
                &quot;telecom&quot;:[],
                &quot;status&quot;:&quot;active&quot;,
                &quot;visible&quot;:false,
                &quot;partOf&quot;:null,
                &quot;photo&quot;:[],
                &quot;managingOrganization&quot;: {&quot;id&quot;: locOrgId},
                &quot;map&quot;:[],
                &quot;type&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).locationType,
                &quot;physicalType&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).physicalType,
                &quot;address&quot;:[{&quot;line&quot;:[map.get(&quot;facilityAddressText&quot;),&quot;&quot;], &quot;state&quot;:map.get(&quot;stateCode&quot;),&quot;postalCode&quot;:map.get(&quot;zipCode&quot;),&quot;city&quot;:map.get(&quot;cityCode&quot;),&quot;country&quot;:&quot;BRA&quot;,&quot;text&quot;:map.get(&quot;locationName&quot;)+&quot;, &quot;+map.get(&quot;city&quot;)+&quot;, &quot;+map.get(&quot;state&quot;)+&quot;, &quot;+map.get(&quot;zipCode&quot;)}]
            }
		locId = locationId //global variable to be used in create usergroup
		var reqType = &quot;PUT&quot;
		request = reqType
		attr.put(&quot;url&quot;,locationUpdateApi)
		
		
	}
	else
	{
	logger.info(&quot;did not found old location, creating new location&quot;)
		
	//var countryCode = &quot;BRA&quot;
	 
	var locationSaveApi = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).locationCreateUrl
	var location_json={
                &quot;mode&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).locationMode,
                &quot;name&quot;:{&quot;value&quot;: map.get(&quot;locationName&quot;)},
                &quot;identifier&quot;:[{&quot;value&quot;:map.get(&quot;facilityCode&quot;),&quot;useCode&quot;:&quot;usual&quot;,&quot;type&quot;:{&quot;text&quot;:&quot;performingLocationId&quot;}},
               		 { &quot;value&quot;: map.get(&quot;CNPJ&quot;),&quot;useCode&quot;: &quot;usual&quot;,&quot;type&quot;: {&quot;text&quot;:&quot;CNPJ&quot;}}],
                &quot;description&quot;:&quot;\n&quot;,
                &quot;telecom&quot;:[],
                &quot;status&quot;:&quot;active&quot;,
                &quot;visible&quot;:false,
                &quot;partOf&quot;:null,
                &quot;photo&quot;:[],
                &quot;managingOrganization&quot;: {&quot;id&quot;: locOrgId},
                &quot;map&quot;:[],
                &quot;type&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).locationType,
                &quot;physicalType&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).physicalType,
                &quot;address&quot;:[{&quot;line&quot;:[map.get(&quot;facilityAddressText&quot;),&quot;&quot;], &quot;state&quot;:map.get(&quot;stateCode&quot;),&quot;postalCode&quot;:map.get(&quot;zipCode&quot;),&quot;city&quot;:map.get(&quot;cityCode&quot;),&quot;country&quot;:&quot;BRA&quot;,&quot;text&quot;:map.get(&quot;locationName&quot;)+&quot;, &quot;+map.get(&quot;city&quot;)+&quot;, &quot;+map.get(&quot;state&quot;)+&quot;, &quot;+map.get(&quot;zipCode&quot;)}]
            }

		var reqType = &quot;POST&quot;
		request = reqType
		attr.put(&quot;url&quot;,locationSaveApi)
		
	}
	 logger.info(&quot;location request json for new location - &quot;+JSON.stringify(location_json))
      attr.put(&quot;token&quot;,token)
	 var resp = api_Request(location_json,attr,reqType)
	  
	   return resp;
	   
	   if(request==&quot;PUT&quot;){
	   	successPopulation(&quot;LOCATION_UPDATED_SUCCESSFULLY&quot;)
	   	
	   }
	   else{
	   	successPopulation(&quot;LOCATION_CREATED_SUCCESSFULLY&quot;)
	   	
	   }
			
			
		}else{
			
				var attr = new java.util.HashMap()
				attr.put(&quot;token&quot;,token)
				attr.put(&quot;url&quot;,orgURL)
				var locOrgResp = api_Request(locOrgJson,attr,&quot;POST&quot;)
				//locOrgId = locOrgResp.id
				if(locOrgResp.getStatusLine().getStatusCode()==200){
					logger.info(&quot;loc based org created successfully&quot;)
				}else{
					logger.info(&quot;loc based org not created&quot;)
				}
				locOrgId = respId	
				logger.info(&quot;locOrgId is - &quot;+locOrgId)	

				var locationReqParams = new java.util.HashMap()
	     locationReqParams.put(&apos;keyName&apos;, &apos;identifier.value.value&apos;)
	     locationReqParams.put(&apos;keyValue&apos;, map.get(&quot;facilityCode&quot;))

	     var locationData = findLocation(locationReqParams)
		
	if(locationData.totalCount &gt; 0){
		var cursor = locationData.message
		var lookUpEntry = JSON.parse(cursor.next())
		var locationId = lookUpEntry._id
		logger.info(&quot;locationId found in createORupdateLocation fun - &quot;+locationId)
		//update code here
		var locationUpdateApi = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).locationUpdateUrl + locationId
		var location_json={
	               &quot;mode&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).locationMode,
                &quot;name&quot;:{&quot;value&quot;: map.get(&quot;locationName&quot;)},
                &quot;identifier&quot;:[{&quot;value&quot;:map.get(&quot;facilityCode&quot;),&quot;useCode&quot;:&quot;usual&quot;,&quot;type&quot;:{&quot;text&quot;:&quot;performingLocationId&quot;}},
               		 { &quot;value&quot;: map.get(&quot;CNPJ&quot;),&quot;useCode&quot;: &quot;usual&quot;,&quot;type&quot;: {&quot;text&quot;:&quot;CNPJ&quot;}}],
                &quot;description&quot;:&quot;\n&quot;,
                &quot;telecom&quot;:[],
                &quot;status&quot;:&quot;active&quot;,
                &quot;visible&quot;:false,
                &quot;partOf&quot;:null,
                &quot;photo&quot;:[],
                &quot;managingOrganization&quot;: {&quot;id&quot;: locOrgId},
                &quot;map&quot;:[],
                &quot;type&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).locationType,
                &quot;physicalType&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).physicalType,
                &quot;address&quot;:[{&quot;line&quot;:[map.get(&quot;facilityAddressText&quot;),&quot;&quot;], &quot;state&quot;:map.get(&quot;stateCode&quot;),&quot;postalCode&quot;:map.get(&quot;zipCode&quot;),&quot;city&quot;:map.get(&quot;cityCode&quot;),&quot;country&quot;:&quot;BRA&quot;,&quot;text&quot;:map.get(&quot;locationName&quot;)+&quot;, &quot;+map.get(&quot;city&quot;)+&quot;, &quot;+map.get(&quot;state&quot;)+&quot;, &quot;+map.get(&quot;zipCode&quot;)}]
            }
		locId = locationId //global variable to be used in create usergroup
		var reqType = &quot;PUT&quot;
		request = reqType
		attr.put(&quot;url&quot;,locationUpdateApi)
		
		
	}
	else
	{
	logger.info(&quot;did not found old location, creating new location&quot;)
		
	//var countryCode = &quot;BRA&quot;
	 
	var locationSaveApi = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).locationCreateUrl
	var location_json={
                &quot;mode&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).locationMode,
                &quot;name&quot;:{&quot;value&quot;: map.get(&quot;locationName&quot;)},
                &quot;identifier&quot;:[{&quot;value&quot;:map.get(&quot;facilityCode&quot;),&quot;useCode&quot;:&quot;usual&quot;,&quot;type&quot;:{&quot;text&quot;:&quot;performingLocationId&quot;}},
               		 { &quot;value&quot;: map.get(&quot;CNPJ&quot;),&quot;useCode&quot;: &quot;usual&quot;,&quot;type&quot;: {&quot;text&quot;:&quot;CNPJ&quot;}}],
                &quot;description&quot;:&quot;\n&quot;,
                &quot;telecom&quot;:[],
                &quot;status&quot;:&quot;active&quot;,
                &quot;visible&quot;:false,
                &quot;partOf&quot;:null,
                &quot;photo&quot;:[],
                &quot;managingOrganization&quot;: {&quot;id&quot;: locOrgId},
                &quot;map&quot;:[],
                &quot;type&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).locationType,
                &quot;physicalType&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).physicalType,
                &quot;address&quot;:[{&quot;line&quot;:[map.get(&quot;facilityAddressText&quot;),&quot;&quot;], &quot;state&quot;:map.get(&quot;stateCode&quot;),&quot;postalCode&quot;:map.get(&quot;zipCode&quot;),&quot;city&quot;:map.get(&quot;cityCode&quot;),&quot;country&quot;:&quot;BRA&quot;,&quot;text&quot;:map.get(&quot;locationName&quot;)+&quot;, &quot;+map.get(&quot;city&quot;)+&quot;, &quot;+map.get(&quot;state&quot;)+&quot;, &quot;+map.get(&quot;zipCode&quot;)}]
            }

		var reqType = &quot;POST&quot;
		request = reqType
		attr.put(&quot;url&quot;,locationSaveApi)
		
	}
	 logger.info(&quot;location request json for new location - &quot;+JSON.stringify(location_json))
      attr.put(&quot;token&quot;,token)
	 var resp = api_Request(location_json,attr,reqType)
	  
	   return resp;
	   
	   if(request==&quot;PUT&quot;){
	   	successPopulation(&quot;LOCATION_UPDATED_SUCCESSFULLY&quot;)
	   	
	   }
	   else{
	   	successPopulation(&quot;LOCATION_CREATED_SUCCESSFULLY&quot;)
	   	
	   }
			
			}
		
		
        

		}
		catch(e){
			logger.info(&quot;ERROR_CREATING/UPDATING_LOCATION - &quot;+e)
			if(request==&quot;PUT&quot;){
	   			errorPopulation(&quot;FAILED_TO_UPDATE_LOCATION&quot;, true)
	   			}
	   		else{
	   			errorPopulation(&quot;FAILED_TO_CREATE_LOCATION&quot;, true)
	   			}		
		}
	
}

function createORupdateUserGroup(map,locId,neworgId)
{
	logger.info(&quot;inside createORupdateUserGroup fun with map - &quot;+map)
	var token = configurationMap.get(&apos;xAuthToken&apos;)
try{
	if(map.get(&quot;userGroupType&quot;)==&quot;LOCAL_ADMIN&quot;){
		var request;
		logger.info(&quot;inside if of local admin&quot;)
		//finding if local admin usergroup pre exists  basis name - yes then update(put), no then create(push)
		var adminUsergroupReqParams = new java.util.HashMap()
	     adminUsergroupReqParams.put(&apos;keyName&apos;, &apos;name&apos;)
	     adminUsergroupReqParams.put(&apos;keyValue&apos;, map.get(&quot;userGroupName&quot;))

	    // var adminUsergroupData = findUserGroup(adminUsergroupReqParams)

	     logger.info(&quot;admin user group found data is - &quot;+adminUsergroupData)
	     
		var queryMap ={}
		var adminUserGroupQuery= new Packages.com.mongodb.BasicDBObject(adminUsergroupReqParams.get(&apos;keyName&apos;),adminUsergroupReqParams.get(&apos;keyValue&apos;))
		queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userGroupCollectionName
		queryMap.find = adminUserGroupQuery
		var adminUsergroupData = MongoGlobalService(&quot;search&quot;,queryMap)
		
		if(adminUsergroupData.totalCount&gt;0){ 
			
			logger.info(&quot;inside if of local admin ug&quot;)
			
			var cursor = adminUsergroupData.message
			var lookUpEntry = JSON.parse(cursor.next())
			var adminUserGroupId = lookUpEntry._id
			logger.info(&quot;adminUsergroupData found in createORupdateLocation fun - &quot;+adminUsergroupData)
			
		//update menuitem,patientbanner,role	
		var menuList = getMenuItems(map.get(&quot;userGroupType&quot;))
		var MenuIdlist = []
		for (i in menuList) {
		  logger.info(&quot;menuItem to add &quot; + menuList[i].menuItem)
		  MenuIdlist.push(menuList[i].menuItem)
		}
		logger.info(&quot;MenuIdlist : &quot; + MenuIdlist)
		//var flag = 0;
		logger.info(&quot;Inside if : &quot; + JSON.stringify(lookUpEntry.menuItems));
		for (i in lookUpEntry.menuItems) {

		  logger.info(&quot;lookUpEntry.menuItemId :&quot; + lookUpEntry.menuItems[i].menuItem)
		  if (MenuIdlist.indexOf(lookUpEntry.menuItems[i].menuItem) == -1) {
			menuList.push(lookUpEntry.menuItems[i]);
			MenuIdlist.push(lookUpEntry.menuItems[i].menuItem)
		  }

		  var patientBannerList = getPatientBannerMenuItems(map.get(&quot;userGroupType&quot;))
		  var patientBannerMenuIdList = [] //new Packages.java.util.ArrayList()
		for (i in patientBannerList) {
		  patientBannerMenuIdList.push(patientBannerList[i].menuItem)
		}
		logger.info(&quot;patientBannerMenuIdList : &quot; + patientBannerMenuIdList)
		for (i in lookUpEntry.patientBannerMenuItems) {
		  //logger.info(lookUpEntry.patientBannerMenuItems[i].menuItem)
		  if (patientBannerMenuIdList.indexOf(lookUpEntry.patientBannerMenuItems[i].menuItem) == -1) {
			patientBannerList.push(lookUpEntry.patientBannerMenuItems[i]);
			patientBannerMenuIdList.push(lookUpEntry.patientBannerMenuItems[i].menuItem)
		  }
		}
	  }

	  logger.info(&quot;Menu List After:&quot; + JSON.stringify(menuList))
	  logger.info(&quot;PatientBannerList After:&quot; + JSON.stringify(patientBannerList))

	var rolesName = getRoles(map.get(&quot;userGroupType&quot;),locId)
	 for (id in lookUpEntry.authorities) {
				var rolesReqParam = new java.util.HashMap()
				rolesReqParam.put(&apos;keyName&apos;, &apos;_id&apos;)
				rolesReqParam.put(&apos;keyValue&apos;, parseInt(id))

				var rolesData = findDataFromDB(&apos;ROLES&apos;, rolesReqParam)
				if (rolesData.totalCount &gt; 0) {
				  logger.info(&quot;[User Group Creation] : Roles Data Count is &quot; + rolesData.totalCount)
				  var cursor = null
				  var lookUpEntry1 = null
				  cursor = rolesData.message
				  var lookUpEntry1 = JSON.parse(cursor.next())
				  var roleName = lookUpEntry1.authority
				  logger.info(&quot;roleName :&quot; + roleName + &quot;test : &quot; + rolesName[roleName])
				  if (rolesName[roleName]) {
					  var assignedRoles = []
					  assignedRoles.push(rolesName[roleName])
					logger.info(&quot;Found existing value as:&quot; + assignedRoles)
					for (i in lookUpEntry.authorities[id]) {
					  if (assignedRoles.indexOf(lookUpEntry.authorities[id][i]) == -1) {
						logger.info(&quot;Not Found :&quot; + lookUpEntry.authorities[id][i])
						assignedRoles.add(lookUpEntry.authorities[id][i])
					  }
					  rolesName[roleName] = assignedRoles
					}
				  } else {
					rolesName[roleName] = lookUpEntry.authorities[id]
				  }
				}
			  }	
			  	
		var userGroupSaveOrUpdateApi = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userGroupUpdateUrl
		var LOCAL_ADMIN_Json ={
		&quot;name&quot;:map.get(&quot;userGroupName&quot;),
		&quot;organizationId&quot;:parseInt(neworgId),
		&quot;agreements&quot;:[&quot;1&quot;],
		&quot;locationId&quot;:locId,
		//&quot;menuItems&quot;:MenuIdlist,getMenuItems(map.get(&quot;userGroupType&quot;))
		&quot;menuItems&quot;:getMenuItems(map.get(&quot;userGroupType&quot;)),
		//&quot;patientBannerMenuItems&quot;:patientBannerMenuIdList,
		&quot;patientBannerMenuItems&quot;:getPatientBannerMenuItems(map.get(&quot;userGroupType&quot;)),
		//&quot;authorities&quot;:rolesName,
		&quot;authorities&quot;:getRoles(map.get(&quot;userGroupType&quot;),locId),
		&quot;id&quot;: adminUserGroupId
				}	
				
				var userGp_data = JSON.stringify(LOCAL_ADMIN_Json);
				logger.info(&quot; [User Group Updation] : User Group json data&quot; + userGp_data )
				var attr= new java.util.HashMap()
				var reqType = &quot;PUT&quot;
				request = reqType
				attr.put(&quot;url&quot;,userGroupSaveOrUpdateApi)
				attr.put(&quot;token&quot;,token)
				attr.put(&quot;apiInfo&quot;,JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).apiInfo)
				var save_response1 = api_Request(LOCAL_ADMIN_Json,attr,reqType)
				logger.info(&quot;local admin User group update response==== : &quot; + save_response1);
		
		
		}

		
		else{
			logger.info(&quot;inside else of admin local ug, will create new admin usergroup&quot;)
		var userGroupSaveOrUpdateApi = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userGroupCreate_url
		var LOCAL_ADMIN_Json ={
		&quot;name&quot;:map.get(&quot;userGroupName&quot;),
		&quot;organizationId&quot;:parseInt(neworgId),
		&quot;locationId&quot;:locId,
		&quot;agreements&quot;:[&quot;1&quot;],
		&quot;menuItems&quot;:getMenuItems(map.get(&quot;userGroupType&quot;)),
		&quot;patientBannerMenuItems&quot;:getPatientBannerMenuItems(map.get(&quot;userGroupType&quot;)),
		&quot;authorities&quot;:getRoles(map.get(&quot;userGroupType&quot;),locId)
				}	
				
				var userGp_data = JSON.stringify(LOCAL_ADMIN_Json);
				logger.info(&quot; [User Group Creation] : User Group json data new&quot; + userGp_data )
				var attr= new java.util.HashMap()
				var reqType = &quot;POST&quot;
				request = reqType
				attr.put(&quot;url&quot;,userGroupSaveOrUpdateApi)
				attr.put(&quot;token&quot;,token)
				attr.put(&quot;apiInfo&quot;,JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).apiInfo)
				var save_response1 = api_Request(LOCAL_ADMIN_Json,attr,reqType)
				logger.info(&quot;local admin User group creation response==== : &quot; + save_response1);
			
		}

		if(request==&quot;PUT&quot;){
	   	successPopulation(&quot;LOCAL_ADMIN_UPDATED_SUCCESSFULLY&quot;)
	   
	   			}
	   else{
	   	successPopulation(&quot;LOCAL_ADMIN_CREATED_SUCCESSFULLY&quot;)
	   	
	   			}
		
		
	}
	else if(map.get(&quot;userGroupType&quot;)==&quot;LOCAL_PHYSICIAN&quot;){

		var request;
		//checking if local physician usergroup pre exists - yes then update, no then create basis name 
		logger.info(&quot;inside else of local admin&quot;)
		
		var phyUsergroupReqParams = new java.util.HashMap()
	     phyUsergroupReqParams.put(&apos;keyName&apos;, &apos;name&apos;)
	     phyUsergroupReqParams.put(&apos;keyValue&apos;,map.get(&quot;userGroupName&quot;))

	    // var phyUsergroupData = findUserGroup(phyUsergroupReqParams);
		var queryMap ={}
		var phyUserGroupQuery= new Packages.com.mongodb.BasicDBObject(phyUsergroupReqParams.get(&apos;keyName&apos;),phyUsergroupReqParams.get(&apos;keyValue&apos;))
		queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userGroupCollectionName
		queryMap.find = phyUserGroupQuery
		var phyUsergroupData = MongoGlobalService(&quot;search&quot;,queryMap)


		if(phyUsergroupData.totalCount&gt;0){
			
			var cursor = phyUsergroupData.message
			var lookUpEntry = JSON.parse(cursor.next())
			var phyUserGroupId = lookUpEntry._id
			logger.info(&quot;local phy UsergroupData found in createORupdateLocation fun - &quot;+phyUsergroupData)

//update menuitem,patientbanner,role	
		var menuList = getMenuItems(map.get(&quot;userGroupType&quot;))
		var MenuIdlist = []
		for (i in menuList) {
		  logger.info(&quot;menuItem to add &quot; + menuList[i].menuItem)
		  MenuIdlist.push(menuList[i].menuItem)
		}
		logger.info(&quot;MenuIdlist : &quot; + MenuIdlist)
		//var flag = 0;
		logger.info(&quot;Inside if : &quot; + JSON.stringify(lookUpEntry.menuItems));
		for (i in lookUpEntry.menuItems) {

		  logger.info(&quot;lookUpEntry.menuItemId :&quot; + lookUpEntry.menuItems[i].menuItem)
		  if (MenuIdlist.indexOf(lookUpEntry.menuItems[i].menuItem) == -1) {
			menuList.push(lookUpEntry.menuItems[i]);
			MenuIdlist.push(lookUpEntry.menuItems[i].menuItem)
		  }

		  var patientBannerList = getPatientBannerMenuItems(map.get(&quot;userGroupType&quot;))
		  var patientBannerMenuIdList = [] //new Packages.java.util.ArrayList()
		for (i in patientBannerList) {
		  patientBannerMenuIdList.push(patientBannerList[i].menuItem)
		}
		logger.info(&quot;patientBannerMenuIdList : &quot; + patientBannerMenuIdList)
		for (i in lookUpEntry.patientBannerMenuItems) {
		  //logger.info(lookUpEntry.patientBannerMenuItems[i].menuItem)
		  if (patientBannerMenuIdList.indexOf(lookUpEntry.patientBannerMenuItems[i].menuItem) == -1) {
			patientBannerList.push(lookUpEntry.patientBannerMenuItems[i]);
			patientBannerMenuIdList.push(lookUpEntry.patientBannerMenuItems[i].menuItem)
		  }
		}
	  }

	  logger.info(&quot;Menu List After:&quot; + JSON.stringify(menuList))
	  logger.info(&quot;PatientBannerList After:&quot; + JSON.stringify(patientBannerList))

	var rolesName = getRoles(map.get(&quot;userGroupType&quot;),locId)
	 for (id in lookUpEntry.authorities) {
				var rolesReqParam = new java.util.HashMap()
				rolesReqParam.put(&apos;keyName&apos;, &apos;_id&apos;)
				rolesReqParam.put(&apos;keyValue&apos;, parseInt(id))

				var rolesData = findDataFromDB(&apos;ROLES&apos;, rolesReqParam)
				if (rolesData.totalCount &gt; 0) {
				  logger.info(&quot;[User Group Creation] : Roles Data Count is &quot; + rolesData.totalCount)
				  var cursor = null
				  var lookUpEntry1 = null
				  cursor = rolesData.message
				  var lookUpEntry1 = JSON.parse(cursor.next())
				  var roleName = lookUpEntry1.authority
				  logger.info(&quot;roleName :&quot; + roleName + &quot;test : &quot; + rolesName[roleName])
				  if (rolesName[roleName]) {
					  var assignedRoles = []
					  assignedRoles.push(rolesName[roleName])
					logger.info(&quot;Found existing value as:&quot; + assignedRoles)
					for (i in lookUpEntry.authorities[id]) {
					  if (assignedRoles.indexOf(lookUpEntry.authorities[id][i]) == -1) {
						logger.info(&quot;Not Found :&quot; + lookUpEntry.authorities[id][i])
						assignedRoles.add(lookUpEntry.authorities[id][i])
					  }
					  rolesName[roleName] = assignedRoles
					}
				  } else {
					rolesName[roleName] = lookUpEntry.authorities[id]
				  }
				}
			  }	
			
			var userGroupSaveOrUpdateApi = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userGroupUpdateUrl
			var LOCAL_PHYSICIAN_Json={
				&quot;name&quot;:map.get(&quot;userGroupName&quot;),
				&quot;organizationId&quot;:parseInt(neworgId),
				&quot;locationId&quot;:locId,
		    		&quot;agreements&quot;: [&quot;1&quot;],
		    		&quot;menuItems&quot;:getMenuItems(map.get(&quot;userGroupType&quot;)),
				&quot;patientBannerMenuItems&quot;:getPatientBannerMenuItems(map.get(&quot;userGroupType&quot;)),
			&quot;authorities&quot;:getRoles(map.get(&quot;userGroupType&quot;),locId),
			&quot;id&quot;:phyUserGroupId
			}
			var userGp_data = JSON.stringify(LOCAL_PHYSICIAN_Json);
			logger.info(&quot; [User Group Updation] : User Group json data&quot; + userGp_data )
			
				var attr= new java.util.HashMap()
				var reqType = &quot;PUT&quot;
				request = reqType
				attr.put(&quot;url&quot;,userGroupSaveOrUpdateApi)
				attr.put(&quot;token&quot;,token)
				attr.put(&quot;apiInfo&quot;,JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).apiInfo)
				var save_response2 = api_Request(LOCAL_PHYSICIAN_Json,attr,reqType)
				logger.info(&quot;local admin User group update response==== : &quot; + save_response2);
		

		
		
		}
		else{
			logger.info(&quot;creating new local physician usergroup&quot;)
			var userGroupSaveOrUpdateApi = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userGroupCreate_url	
			var LOCAL_PHYSICIAN_Json={
				&quot;name&quot;:map.get(&quot;userGroupName&quot;),
				&quot;organizationId&quot;:parseInt(neworgId),
				&quot;locationId&quot;:locId,
		 	  	 &quot;agreements&quot;: [&quot;1&quot;],
		 	  	 &quot;menuItems&quot;:getMenuItems(map.get(&quot;userGroupType&quot;)),
				&quot;patientBannerMenuItems&quot;:getPatientBannerMenuItems(map.get(&quot;userGroupType&quot;)),
			&quot;authorities&quot;:getRoles(map.get(&quot;userGroupType&quot;),locId)
			}

			var userGp_data = JSON.stringify(LOCAL_PHYSICIAN_Json);
			logger.info(&quot; [User Group Creation] : User Group json data&quot; + userGp_data )
			
				var attr= new java.util.HashMap()
				var reqType = &quot;POST&quot;
				request=reqType
				attr.put(&quot;url&quot;,userGroupSaveOrUpdateApi)
				attr.put(&quot;token&quot;,token)
				attr.put(&quot;apiInfo&quot;,JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).apiInfo)
				var save_response2 = api_Request(LOCAL_PHYSICIAN_Json,attr,reqType)
				logger.info(&quot;local admin User group creation response==== : &quot; + save_response2);
			
		
			}
			if(request==&quot;PUT&quot;){
	   	successPopulation(&quot;LOCAL_PHYSICIAN_UPDATED_SUCCESSFULLY&quot;)
		
	   }
	   else{
	   	successPopulation(&quot;LOCAL_PHYSICIAN_CREATED_SUCCESSFULLY&quot;)
	   	
	   }
		
	}
			} 
		catch (e) {
				logger.error(&quot;Exception Occured while creating user Group&quot;+e)
				if(request==&quot;PUT&quot;){
	   	errorPopulation(&quot;LOCAL_PHYSICIAN_NOT_UPDATED_SUCCESSFULLY&quot;)
		
	   }
	   else{
	   	errorPopulation(&quot;LOCAL_PHYSICIAN_NOT_CREATED_SUCCESSFULLY&quot;)
	   	
	   }
				}

	return save_response1
	//successPopulation(&quot;USERGROUP_CREATED/UPDATED_SUCCESSFULLY&quot;)
}


function getMenuItems(userGroupType) {
  logger.info(&quot;[User Group Creation ] : Inside getMenuItems with userGroupType &quot; + userGroupType)
  var menuList = [] 
  try {
	var menuJson = JSON.parse(configurationMap.get(&apos;userGroupCreationMap&apos;))
	logger.info(&quot;menuJson getting received is - &quot;+menuJson)

	if(userGroupType in menuJson){
		for (menu in menuJson[userGroupType].menuItems) {
			logger.info(&quot;[UserGroup]: User Group Menu Data Inside Loop &quot; + menuJson[userGroupType].menuItems[menu])
		
			//finding id of menuitems in db
			var menuItemReqParam = new java.util.HashMap()
			menuItemReqParam.put(&apos;keyName&apos;, &apos;name&apos;)
			menuItemReqParam.put(&apos;keyValue&apos;, menuJson[userGroupType].menuItems[menu])
			var queryMap ={}
			var menuItemQuery= new Packages.com.mongodb.BasicDBObject(menuItemReqParam.get(&apos;keyName&apos;),menuItemReqParam.get(&apos;keyValue&apos;))
			logger.info(&quot;menuItemQuery - &quot;+menuItemQuery)
			queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).menuCollectionName
			logger.info(&quot;queryMap.collectionName - &quot;+queryMap.collectionName)
			queryMap.find = menuItemQuery
			var menuData = MongoGlobalService(&quot;search&quot;,queryMap)

		
			logger.info(&quot;[User Group Creation] : Menu Items Count is &quot; + menuData.totalCount)
			if (menuData.totalCount &gt; 0) {

				  var menusId = {}
				  var menuId = getId(menuData)
				  menusId.menuItem = menuId
		  		  if (menuJson[userGroupType].menuItems[menu] == menuJson[userGroupType].defaultMenuBar) {
				       menusId.isDefault = true
			            } 
			       else {
				       menusId.isDefault = false
			  	       }

		  menuList.push(menusId)
		  logger.info(&quot;[User  Group Creation] :  Menu List Created is &quot; + JSON.stringify(menuList))
		}
	  }
		}
		else{
			  errorPopulation(&quot;USERGROUP_TYPE_DOES_NOT_EXISTS : getMenuItems&quot;, true);
		}
	
  } catch(e) {
	if (!reportMap.errMessage) {
	  errorPopulation(&quot;EXCEPTION_WHILE_GETTING_MENU_ITEMS&quot;)
	}
	throw (e);
  }
  logger.info(&quot;menuList receiving at end of getmenu is - &quot;+JSON.stringify(menuList))
  logger.info(&quot;menuList receiving at end of getmenu is - &quot;+menuList)
  menuListToPass = JSON.stringify(menuList)
  logger.info(&quot;value i am passing - &quot;+menuListToPass)
  //return menuListToPass;
  return menuList;
}


function getPatientBannerMenuItems(userGroupType) {
  logger.info(&quot;[User Group Creation] :  Inside getPatientBannerMenuItems for userGroupType&quot; + userGroupType)
  var patientBannerList = [] //new Packages.java.util.ArrayList()
  try {
	var patientBannerMenuJson = JSON.parse(configurationMap.get(&apos;userGroupCreationMap&apos;))
	if (userGroupType in patientBannerMenuJson) {
	  for (patientMenu in patientBannerMenuJson[userGroupType].patientBanner) {
		logger.info(&quot;[UserGroup]: User Group patient Banner Menu Data Inside Loop &quot; + patientBannerMenuJson[userGroupType].patientBanner[patientMenu])
		
		var menuItemReqParam = new java.util.HashMap()
		menuItemReqParam.put(&apos;keyName&apos;, &apos;name&apos;)
		menuItemReqParam.put(&apos;keyValue&apos;, patientBannerMenuJson[userGroupType].patientBanner[patientMenu])

		var patientMenuData = findDataFromDB(&apos;MENUITEM&apos;, menuItemReqParam)
		logger.info(&quot;Patient Banner Menu Data is &quot; + patientMenuData)
		if (patientMenuData.totalCount &gt; 0) {
		  logger.info(&quot;[User Group] :Inside Search Data count for patient Banner menuItems&quot;)
		  var patientBanner = {}
		  var patientMenuId = getId(patientMenuData)
		  patientBanner.menuItem = patientMenuId
		  if (patientBannerMenuJson[userGroupType].patientBanner[patientMenu] == patientBannerMenuJson[userGroupType].defaultPatientBanner) {
			patientBanner.isDefault = true
		  } else {
			patientBanner.isDefault = false
		  }

		  patientBannerList.push(patientBanner)

		  logger.info(&quot;===========Patient Banner List&quot; + JSON.stringify(patientBannerList))

		} else {
		  logger.error(&quot;PatientMenuData Not Found&quot;)
		}
	  }
	} else {
	  errorPopulation(&quot;USERGROUP_TYPE_DOES_NOT_EXISTS : getPatientBannerMenuItems&quot;, true);
	}

  } catch(e) {
	if (!reportMap.errMessage) {
	  errorPopulation(&quot;EXCEPTION_WHILE_GETTING_PATIENT_BANNER_ITEMS&quot;)
	}
	throw (e);
  }
  return patientBannerList;

}

function getAgreement(userGroupType){
	logger.info(&quot;inside get agreement&quot;)
	var agreementList = []
	var userGroupMap = JSON.parse(configurationMap.get(&apos;userGroupCreationMap&apos;))
	if (userGroupType in userGroupMap) {
	for (agreement in userGroupMap[userGroupType].aggrements) {
		agreementList.push(agreement)
	}
	}
	logger.info(&quot;agreementList is - &quot;+agreementList)
	return agreementList
}

//function getRoles(userGroupType, locationName, locationIdentifier, orgId, userGroupId, userGroupName,facilityAddressMap) {
 function getRoles(userGroupType, locId) {
  logger.info(&quot;[User Group Creation] : Inside Get Roles Function &quot;)

  try {
	var rolesName = {}
	var userGroupMap = JSON.parse(configurationMap.get(&apos;userGroupCreationMap&apos;))
	var roleLocatioIdList = []

	if (userGroupType in userGroupMap) {
	  logger.info(&quot;[User Group] Going to get Roles Data for Team ==&quot; + JSON.stringify(userGroupMap[userGroupType]))
	  for (rolesArray in userGroupMap[userGroupType].roles) {
		logger.info(&apos;Roles Team is :&apos; + userGroupMap[userGroupType].roles[rolesArray])
		var cursor = null
		var lookUpEntry = null
		var rolesReqParam = new java.util.HashMap()
		rolesReqParam.put(&apos;keyName&apos;, &apos;authority&apos;)
		rolesReqParam.put(&apos;keyValue&apos;, userGroupMap[userGroupType].roles[rolesArray])

		var rolesData = findDataFromDB(&apos;ROLES&apos;, rolesReqParam)

		if (rolesData.totalCount &gt; 0) {
		  logger.info(&quot;[User Group Creation] : Roles Data Count is &quot; + rolesData.totalCount)
		  cursor = rolesData.message
		  lookUpEntry = JSON.parse(cursor.next())
		  var userGroupIdList = []
		  if (userGroupMap[userGroupType].roles[rolesArray] == &quot;ROLE_LOCATION_ACCESS&quot; || userGroupMap[userGroupType].roles[rolesArray] == &quot;ROLE_ADMIN_LOCATION_ACCESS&quot;) {

			rolesName[lookUpEntry.authority] = [locId]
		  } else {
			rolesName[lookUpEntry.authority] = &quot;&quot;
		  }
		 
		}
	  }
	 
	} else {
	  logger.error(&quot;[User Group Creation] getRoles: userGroupType Key doesnot exist in Json&quot;)
	}
logger.info(&quot;values in rolesName is = &quot;+rolesName)
	return rolesName;
  } catch(e) {
	logger.error(&apos;Exception occured while getting roles&apos; + e + e.stack)
	throw (e)
  }

}

function getId(jsonData) {
  try {
	logger.info(&quot;Inside GetId function with json Response =======&quot; + jsonData)
	var cursor = jsonData.message
	var lookUpEntry = JSON.parse(cursor.next())

	return lookUpEntry._id
  } catch(e) {
	if (!reportMap.errMessage) {
	  errorPopulation(&quot;EXCEPTION_WHILE_GETTING_MONGO_ID&quot;)
	}
	throw (e);
  }
}

function createOrUpdateGlobalAdminUserGroup(){
	logger.info(&quot;inside createOrUpdateGlobalAdminUserGroup&quot;)

//unimed do brasil location find and pass its id
var locOrgReqParams = new java.util.HashMap()
		locOrgReqParams.put(&apos;keyName&apos;, &apos;identifier.value.value&apos;)
		locOrgReqParams.put(&apos;keyValue&apos;, &quot;0999&quot;)
		logger.info(&quot;locOrgReqParams - &quot;+locOrgReqParams)

	     var queryMap ={}
		var locOrgQuery= new Packages.com.mongodb.BasicDBObject(locOrgReqParams.get(&apos;keyName&apos;),locOrgReqParams.get(&apos;keyValue&apos;))
		queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).locationCollectionName
		queryMap.find = locOrgQuery
		var locOrgData = MongoGlobalService(&quot;search&quot;,queryMap)
		//if(locOrgData.totalCount&gt;0)
		var cursor = locOrgData.message
		var lookUpEntry = JSON.parse(cursor.next())
		udblocId = lookUpEntry._id					
logger.info(&quot;udblocId is - &quot;+udblocId)
var globalAdminJson = {
	&quot;name&quot;:&quot;Admin&quot;,
				&quot;organizationId&quot;:mainOrgId,
				&quot;locationId&quot;:udblocId,
		 	  	 &quot;agreements&quot;: [&quot;1&quot;],
		 	  	 &quot;menuItems&quot;:getMenuItems(&quot;GLOBAL_ADMIN&quot;),
				&quot;patientBannerMenuItems&quot;:getPatientBannerMenuItems(&quot;GLOBAL_ADMIN&quot;),
			&quot;authorities&quot;:getRoles(&quot;GLOBAL_ADMIN&quot;,udblocId)	
}

logger.info(&quot;global admin ug json - &quot;+JSON.stringify(globalAdminJson))
var globalAdminUsergroupReqParams = new java.util.HashMap()
	     globalAdminUsergroupReqParams.put(&apos;keyName&apos;, &apos;name&apos;)
	     globalAdminUsergroupReqParams.put(&apos;keyValue&apos;, &quot;Admin&quot;)

	    // var adminUsergroupData = findUserGroup(adminUsergroupReqParams)
	     
		var queryMap ={}
		var adminUserGroupQuery= new Packages.com.mongodb.BasicDBObject(globalAdminUsergroupReqParams.get(&apos;keyName&apos;),globalAdminUsergroupReqParams.get(&apos;keyValue&apos;))
		queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userGroupCollectionName
		queryMap.find = adminUserGroupQuery
		var adminUsergroupData = MongoGlobalService(&quot;search&quot;,queryMap)
		if(adminUsergroupData.totalCount&gt;0){ 
			var cursor = adminUsergroupData.message
			var lookUpEntry = JSON.parse(cursor.next())
			gaId = lookUpEntry._id					
logger.info(&quot;global admin user group found id is - &quot;+gaId)
logger.info(&quot;updating global Admin usergroup&quot;)
		}
		else{
			logger.info(&quot;creating new global admin usergroup&quot;)

			
			var userGroupSaveApi = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userGroupCreate_url
				var attr = new java.util.HashMap()
				attr.put(&quot;token&quot;,token)
				attr.put(&quot;url&quot;,userGroupSaveApi)
				attr.put(&quot;apiInfo&quot;,JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).apiInfo)
				logger.info(&quot;global admin ug create url is - &quot;+userGroupSaveApi)
				var OrgResponse = api_Request(globalAdminJson,attr,&quot;POST&quot;)
				
				if(OrgResponse.getStatusLine().getStatusCode()==200){
					logger.info(&quot;global admin created successfully with id-&quot;+respId)
				}else{
					logger.info(&quot;global admin not created&quot;)
				}
				
				}
	
	
}

function api_Request(requestParam,apiAttributes,reqType)
{
	
var httpclient = new DefaultHttpClient();
logger.info(&quot;reqType in api req method - &quot;+reqType)
try{

	if(reqType == &quot;PUT&quot;){
//url
var httpPut = new HttpPut(apiAttributes.get(&apos;url&apos;));
logger.info(&quot;Making Request to Url ==&quot; + apiAttributes.get(&apos;url&apos;))
//header
httpPut.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);
httpPut.addHeader(&quot;x-auth-token&quot;, apiAttributes.get(&apos;token&apos;));
apiAttributes.get(&apos;apiInfo&apos;) ? httpPut.addHeader(&quot;api-info&quot;, apiAttributes.get(&apos;apiInfo&apos;)) : &quot;&quot;
//req body
var entityforhttp = JSON.stringify(requestParam);
var stringEntity1 = new StringEntity(entityforhttp,&quot;application/json&quot;,&quot;UTF-8&quot;);
httpPut.setEntity(stringEntity1)
logger.info(&quot;req body in json - &quot;+requestParam)
logger.info(&quot;req body in json string - &quot;+entityforhttp)	
logger.info(&quot;Going to execute put api request &quot;)
					var resp = httpclient.execute(httpPut);
					var statusCode = resp.getStatusLine().getStatusCode();
					var entity = resp.getEntity();
					var responseString = EntityUtils.toString(entity, &quot;UTF-8&quot;);
					var responseContent = resp.getEntity().getContent();

					logger.info(&quot;raw response of put api - &quot;+resp)
					logger.info(&quot;status code of response of api is - &quot;+statusCode)
					logger.info(&quot;entity of response is - &quot;+entity)
					logger.info(&quot;response string - &quot;+responseString)
					logger.info(&quot;response content is - &quot;+responseContent)

	}
	else if(reqType==&quot;POST&quot;){
		logger.info(&quot;inside post request&quot;)
//url
var httpPost = new HttpPost(apiAttributes.get(&apos;url&apos;));
logger.info(&quot;Making Request to Url ==&quot; + apiAttributes.get(&apos;url&apos;))
//header
httpPost.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);
httpPost.addHeader(&quot;x-auth-token&quot;, apiAttributes.get(&apos;token&apos;));
apiAttributes.get(&apos;apiInfo&apos;) ? httpPost.addHeader(&quot;api-info&quot;, apiAttributes.get(&apos;apiInfo&apos;)) : &quot;&quot;
//req body
var entityforhttp = JSON.stringify(requestParam);
var stringEntity1 = new StringEntity(entityforhttp,&quot;application/json&quot;,&quot;UTF-8&quot;);
httpPost.setEntity(stringEntity1)
logger.info(&quot;req body in json - &quot;+requestParam)
logger.info(&quot;req body in json string - &quot;+entityforhttp)	
logger.info(&quot;Going to execute post api request &quot;)
					var resp = httpclient.execute(httpPost);
					var statusCode = resp.getStatusLine().getStatusCode();
					var entity = resp.getEntity();
					var responseString = EntityUtils.toString(entity, &quot;UTF-8&quot;);
					var responseContent = resp.getEntity().getContent();

					logger.info(&quot;raw response of post api - &quot;+resp)
					logger.info(&quot;status code of response of api is - &quot;+statusCode)

					//to take out location mongo id
					var responseMap = {}
					responseMap = JSON.parse(responseString)
					respId=responseMap.id
					locId = responseMap.id
					logger.info(&quot;value of location id is +&quot;+locId)	
					
		}
								
}
catch(err){
	logger.error(&quot;ERROR Executed with API REQUEST  &quot; + err);
}

finally{
	resp.close();
}

return resp;
	
}</script>
        </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
      </elements>
      <inboundTemplate encoding="base64"></inboundTemplate>
      <outboundTemplate encoding="base64"></outboundTemplate>
      <inboundDataType>DELIMITED</inboundDataType>
      <outboundDataType>HL7V2</outboundDataType>
      <inboundProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDataTypeProperties" version="3.9.1">
        <serializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedSerializationProperties" version="3.9.1">
          <columnDelimiter>,</columnDelimiter>
          <recordDelimiter>\n</recordDelimiter>
          <quoteToken>&quot;</quoteToken>
          <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
          <quoteEscapeToken>\</quoteEscapeToken>
          <columnNames>
            <string>userGroupType</string>
            <string>userGroupName</string>
            <string>facilityCode</string>
            <string>locationName</string>
            <string>cityCode</string>
            <string>city</string>
            <string>zipCode</string>
            <string>stateCode</string>
            <string>state</string>
            <string>facilityAddressText</string>
            <string>CNPJ</string>
          </columnNames>
          <numberedRows>false</numberedRows>
          <ignoreCR>true</ignoreCR>
        </serializationProperties>
        <deserializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDeserializationProperties" version="3.9.1">
          <columnDelimiter>,</columnDelimiter>
          <recordDelimiter>\n</recordDelimiter>
          <quoteToken>&quot;</quoteToken>
          <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
          <quoteEscapeToken>\</quoteEscapeToken>
        </deserializationProperties>
        <batchProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedBatchProperties" version="3.9.1">
          <splitType>Record</splitType>
          <batchSkipRecords>0</batchSkipRecords>
          <batchMessageDelimiter></batchMessageDelimiter>
          <batchMessageDelimiterIncluded>false</batchMessageDelimiterIncluded>
          <batchGroupingColumn></batchGroupingColumn>
          <batchScript></batchScript>
        </batchProperties>
      </inboundProperties>
      <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.9.1">
        <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.9.1">
          <handleRepetitions>true</handleRepetitions>
          <handleSubcomponents>true</handleSubcomponents>
          <useStrictParser>false</useStrictParser>
          <useStrictValidation>false</useStrictValidation>
          <stripNamespaces>true</stripNamespaces>
          <segmentDelimiter>\r</segmentDelimiter>
          <convertLineBreaks>true</convertLineBreaks>
        </serializationProperties>
        <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.9.1">
          <useStrictParser>false</useStrictParser>
          <useStrictValidation>false</useStrictValidation>
          <segmentDelimiter>\r</segmentDelimiter>
        </deserializationProperties>
        <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.9.1">
          <splitType>MSH_Segment</splitType>
          <batchScript></batchScript>
        </batchProperties>
        <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.9.1">
          <segmentDelimiter>\r</segmentDelimiter>
          <successfulACKCode>AA</successfulACKCode>
          <successfulACKMessage></successfulACKMessage>
          <errorACKCode>AE</errorACKCode>
          <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
          <rejectedACKCode>AR</rejectedACKCode>
          <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
          <msh15ACKAccept>false</msh15ACKAccept>
          <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
        </responseGenerationProperties>
        <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.9.1">
          <successfulACKCode>AA,CA</successfulACKCode>
          <errorACKCode>AE,CE</errorACKCode>
          <rejectedACKCode>AR,CR</rejectedACKCode>
          <validateMessageControlId>true</validateMessageControlId>
          <originalMessageControlId>Destination_Encoded</originalMessageControlId>
          <originalIdMapVariable></originalIdMapVariable>
        </responseValidationProperties>
      </outboundProperties>
    </transformer>
    <filter version="3.9.1">
      <elements/>
    </filter>
    <transportName>File Reader</transportName>
    <mode>SOURCE</mode>
    <enabled>true</enabled>
    <waitForPrevious>true</waitForPrevious>
  </sourceConnector>
  <destinationConnectors>
    <connector version="3.9.1">
      <metaDataId>1</metaDataId>
      <name>Destination 1</name>
      <properties class="com.mirth.connect.connectors.file.FileDispatcherProperties" version="3.9.1">
        <pluginProperties/>
        <destinationConnectorProperties version="3.9.1">
          <queueEnabled>true</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <scheme>FILE</scheme>
        <host>${baseDirectoryPath}/processedCsvReportLoc</host>
        <outputPattern>${userGroupAndLocationCsvToSend}</outputPattern>
        <anonymous>true</anonymous>
        <username>anonymous</username>
        <password>anonymous</password>
        <timeout>10000</timeout>
        <keepConnectionOpen>true</keepConnectionOpen>
        <maxIdleTime>0</maxIdleTime>
        <secure>true</secure>
        <passive>true</passive>
        <validateConnection>true</validateConnection>
        <outputAppend>false</outputAppend>
        <errorOnExists>false</errorOnExists>
        <temporary>false</temporary>
        <binary>false</binary>
        <charsetEncoding>DEFAULT_ENCODING</charsetEncoding>
        <template>${report}</template>
      </properties>
      <transformer version="3.9.1">
        <elements/>
        <inboundDataType>HL7V2</inboundDataType>
        <outboundDataType>HL7V2</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.9.1">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.9.1">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.9.1">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.9.1">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.9.1">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.9.1">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.9.1">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.9.1">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.9.1">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.9.1">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.9.1">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.9.1">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.9.1">
        <elements/>
        <inboundDataType>HL7V2</inboundDataType>
        <outboundDataType>HL7V2</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.9.1">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.9.1">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.9.1">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.9.1">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.9.1">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.9.1">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.9.1">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.9.1">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.9.1">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.9.1">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.9.1">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.9.1">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.9.1">
        <elements/>
      </filter>
      <transportName>File Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>true</waitForPrevious>
    </connector>
    <connector version="3.9.1">
      <metaDataId>2</metaDataId>
      <name>Destination 2</name>
      <properties class="com.mirth.connect.connectors.smtp.SmtpDispatcherProperties" version="3.9.1">
        <pluginProperties/>
        <destinationConnectorProperties version="3.9.1">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <smtpHost>${smtpHostname}</smtpHost>
        <smtpPort>${smtpPort}</smtpPort>
        <overrideLocalBinding>false</overrideLocalBinding>
        <localAddress>0.0.0.0</localAddress>
        <localPort>0</localPort>
        <timeout>5000</timeout>
        <encryption>TLS</encryption>
        <authentication>true</authentication>
        <username>${smtpUsername}</username>
        <password>9d4nsM9hRX@$6</password>
        <to>${csvEmailId}</to>
        <from>${smtpFromEmailId}</from>
        <cc></cc>
        <bcc></bcc>
        <replyTo></replyTo>
        <headers class="linked-hash-map"/>
        <headersVariable></headersVariable>
        <isUseHeadersVariable>false</isUseHeadersVariable>
        <subject>${userGroupAndLocationSubject}</subject>
        <charsetEncoding>DEFAULT_ENCODING</charsetEncoding>
        <html>false</html>
        <body>This is auto generated report</body>
        <attachments>
          <com.mirth.connect.connectors.smtp.Attachment>
            <name>${userGroupAndLocationCsvToSend}</name>
            <content>${report}</content>
          </com.mirth.connect.connectors.smtp.Attachment>
        </attachments>
        <attachmentsVariable></attachmentsVariable>
        <isUseAttachmentsVariable>false</isUseAttachmentsVariable>
      </properties>
      <transformer version="3.9.1">
        <elements/>
        <inboundDataType>HL7V2</inboundDataType>
        <outboundDataType>HL7V2</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.9.1">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.9.1">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.9.1">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.9.1">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.9.1">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.9.1">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.9.1">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.9.1">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.9.1">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.9.1">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.9.1">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.9.1">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.9.1">
        <elements/>
        <inboundDataType>HL7V2</inboundDataType>
        <outboundDataType>HL7V2</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.9.1">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.9.1">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.9.1">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.9.1">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.9.1">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.9.1">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DataTypeProperties" version="3.9.1">
          <serializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2SerializationProperties" version="3.9.1">
            <handleRepetitions>true</handleRepetitions>
            <handleSubcomponents>true</handleSubcomponents>
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <stripNamespaces>true</stripNamespaces>
            <segmentDelimiter>\r</segmentDelimiter>
            <convertLineBreaks>true</convertLineBreaks>
          </serializationProperties>
          <deserializationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2DeserializationProperties" version="3.9.1">
            <useStrictParser>false</useStrictParser>
            <useStrictValidation>false</useStrictValidation>
            <segmentDelimiter>\r</segmentDelimiter>
          </deserializationProperties>
          <batchProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2BatchProperties" version="3.9.1">
            <splitType>MSH_Segment</splitType>
            <batchScript></batchScript>
          </batchProperties>
          <responseGenerationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseGenerationProperties" version="3.9.1">
            <segmentDelimiter>\r</segmentDelimiter>
            <successfulACKCode>AA</successfulACKCode>
            <successfulACKMessage></successfulACKMessage>
            <errorACKCode>AE</errorACKCode>
            <errorACKMessage>An Error Occurred Processing Message.</errorACKMessage>
            <rejectedACKCode>AR</rejectedACKCode>
            <rejectedACKMessage>Message Rejected.</rejectedACKMessage>
            <msh15ACKAccept>false</msh15ACKAccept>
            <dateFormat>yyyyMMddHHmmss.SSS</dateFormat>
          </responseGenerationProperties>
          <responseValidationProperties class="com.mirth.connect.plugins.datatypes.hl7v2.HL7v2ResponseValidationProperties" version="3.9.1">
            <successfulACKCode>AA,CA</successfulACKCode>
            <errorACKCode>AE,CE</errorACKCode>
            <rejectedACKCode>AR,CR</rejectedACKCode>
            <validateMessageControlId>true</validateMessageControlId>
            <originalMessageControlId>Destination_Encoded</originalMessageControlId>
            <originalIdMapVariable></originalIdMapVariable>
          </responseValidationProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.9.1">
        <elements/>
      </filter>
      <transportName>SMTP Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>true</waitForPrevious>
    </connector>
  </destinationConnectors>
  <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
  <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
  <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
  <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
  <properties version="3.9.1">
    <clearGlobalChannelMap>true</clearGlobalChannelMap>
    <messageStorageMode>DEVELOPMENT</messageStorageMode>
    <encryptData>false</encryptData>
    <removeContentOnCompletion>false</removeContentOnCompletion>
    <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
    <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
    <initialState>STARTED</initialState>
    <storeAttachments>true</storeAttachments>
    <metaDataColumns>
      <metaDataColumn>
        <name>SOURCE</name>
        <type>STRING</type>
        <mappingName>mirth_source</mappingName>
      </metaDataColumn>
      <metaDataColumn>
        <name>TYPE</name>
        <type>STRING</type>
        <mappingName>mirth_type</mappingName>
      </metaDataColumn>
    </metaDataColumns>
    <attachmentProperties version="3.9.1">
      <type>None</type>
      <properties/>
    </attachmentProperties>
    <resourceIds class="linked-hash-map">
      <entry>
        <string>Default Resource</string>
        <string>[Default Resource]</string>
      </entry>
    </resourceIds>
  </properties>
  <exportData>
    <metadata>
      <enabled>true</enabled>
      <lastModified>
        <time>1678946763069</time>
        <timezone>Asia/Calcutta</timezone>
      </lastModified>
      <pruningSettings>
        <archiveEnabled>true</archiveEnabled>
      </pruningSettings>
    </metadata>
    <codeTemplateLibraries>
      <codeTemplateLibrary version="3.9.1">
        <id>3f3cdf24-eb5c-4fee-aad6-8b87ba5fa7db</id>
        <name>GenericCodeTemplates</name>
        <revision>7</revision>
        <lastModified>
          <time>1677332066031</time>
          <timezone>UTC</timezone>
        </lastModified>
        <description></description>
        <includeNewChannels>false</includeNewChannels>
        <enabledChannelIds>
          <string>5dd1cce0-fcd2-4756-900f-47b157f17690</string>
          <string>f6261a9b-8e35-45c7-bf71-eaf64d284e8c</string>
          <string>e84827ea-74b1-4f4c-a3be-96a9346be3bb</string>
        </enabledChannelIds>
        <disabledChannelIds>
          <string>68aa9bb6-1660-41ce-9350-75b8346ed0b8</string>
          <string>3461dc62-416a-4e3b-a64e-e725fa77dc0d</string>
          <string>14f4f229-5e97-4ee1-b916-056dc61d55fd</string>
          <string>8f1252ff-280f-4c9e-9636-f54b8acf7b95</string>
          <string>aa0a54ab-8466-47fd-ad24-8446c765966d</string>
          <string>2d9f6e4d-f9ea-433a-a3a0-bf7d2d7741d1</string>
          <string>a3b7e5c2-284d-486b-a883-94c72042f611</string>
          <string>ee8561c2-aae4-4af7-9537-4cfb0f22a898</string>
          <string>2bad44cb-bbb9-4469-b75d-9afe39f9add8</string>
          <string>ba7525ef-3b2f-4bc7-8619-e1dcd7b3a4ae</string>
          <string>fb2b21a9-ebb6-46c5-a719-3424af0e5d35</string>
          <string>4bbb546b-cbf3-4bf4-894a-1e0e19a4c63c</string>
          <string>be8c3806-9e03-4c09-be9d-881fcf58712b</string>
          <string>3f011c8b-6810-46cb-b386-2fc21dd904ae</string>
          <string>a0525d5d-96d8-4bb6-8376-281462c43367</string>
          <string>68393673-e5ed-42c6-a017-8be9a8a20d8b</string>
          <string>8b79dcea-f420-4e89-9803-f8abfb3afd7e</string>
          <string>e967b766-f5cf-4c6b-aff7-5767e13bdf49</string>
          <string>006b73de-e897-477f-a4f2-13ad2f22a3d9</string>
          <string>17a802d4-a0c9-4289-bbb4-3788c2efd4ea</string>
          <string>ae1c0161-90c5-467c-be7c-e54404929b64</string>
          <string>995d1735-41b3-43e1-ac6d-5be71de41f98</string>
        </disabledChannelIds>
        <codeTemplates>
          <codeTemplate version="3.9.1">
            <id>9fe5391f-535c-43d8-a9a7-3b0e34e7c4e7</id>
            <name>apiRequest</name>
            <revision>10</revision>
            <lastModified>
              <time>1672725808049</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {String} arg1 - arg1 description
					@return {String} return description
					Send method as - POST ,PUT , DELETE , GET
					Send Request Params as second Parameter
					Send apiattr  token,apiInfo url in map
					*/
					importPackage(Packages.org.apache.http.client);
					importPackage(Packages.org.apache.http.client.methods);
					importPackage(Packages.org.apache.http.impl.client);
					importPackage(Packages.org.apache.http.message);
					importPackage(Packages.org.apache.http.client.entity);
					importPackage(Packages.org.apache.http.entity);
					importPackage(Packages.org.apache.http.util);
					importPackage(Packages.org.apache.http.ssl);
					importPackage(Packages.org.apache.http.conn);
					importPackage(Packages.org.apache.http.conn.ssl);
					importPackage(Packages.org.apache.http.client.config);

					function apiRequest(method,messageBody,apiAttributes){
					var result={}
					if(method==&apos;GET&apos;){
					return result= getRequest(messageBody,apiAttributes)
					}

					if(method==&apos;POST&apos;){
					return result = postRequest(messageBody,apiAttributes)
					}

					if(method==&apos;PUT&apos;){
					return result = putRequest(messageBody,apiAttributes)
					}

					if(method==&apos;DELETE&apos;){
					return result=deleteRequest(messageBody,apiAttributes)
					}
					}


					function getRequest(requestParam, apiAttributes) {
					logger.info(&quot;Inside Get Method with requestParams  &quot; + requestParam + &quot;API attributes&quot; + apiAttributes)
					var httpclient = new DefaultHttpClient();

					// Building the request

					if (apiAttributes.get(&apos;url&apos;)) {
					logger.info(&quot;Making Request to Url ==&quot; + apiAttributes.get(&apos;url&apos;))
					var httpGet = new HttpGet(apiAttributes.get(&apos;url&apos;));
					// Specify Headers which you want to send
					httpGet.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);

					apiAttributes.get(&apos;token&apos;) ? httpGet.addHeader(&quot;x-auth-token&quot;, apiAttributes.get(&apos;token&apos;)) : &quot;&quot;
					apiAttributes.get(&apos;apiInfo&apos;) ? httpGet.addHeader(&quot;api-info&quot;, apiAttributes.get(&apos;apiInfo&apos;)) : &quot;&quot;

					//httpGet.setEntity(new StringEntity(JSON.stringify(requestParam)))

					var statusCode, entity, responseString, resp
					try {
					logger.info(&quot;Going to execute api request &quot;)
					resp = httpclient.execute(httpGet);
					statusCode = resp.getStatusLine().getStatusCode();
					entity = resp.getEntity();
					responseString = EntityUtils.toString(entity, &quot;UTF-8&quot;);

					if (statusCode == 200 || statusCode == 201) {
					logger.info(&quot;API Executed succesfully with Status Code ===== &quot; + statusCode)
					}
					return responseString;

					} catch (err) {
					logger.error(&quot;Error Occured in GET Method &quot;  +  err);

					}finally {
					resp.close();
					}

					} else {
					logger.error(&quot;[API Request Get] : Api Url is not defined in Request Map&quot;)
					}


					}

					function putRequest(requestParam, apiAttributes) {
					logger.info(&quot;Inside PUT Method with requestParams  &quot; + requestParam + &quot;API attributes&quot; + apiAttributes)
					var httpclient = new DefaultHttpClient();
					if (apiAttributes.get(&apos;url&apos;)) {
					logger.info(&quot;Making Request to Url ==&quot; + apiAttributes.get(&apos;url&apos;))
					var httpPut = new HttpPut(apiAttributes.get(&apos;url&apos;));
					// Specify Headers which you want to send
					httpPut.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);

					apiAttributes.get(&apos;token&apos;) ? httpPut.addHeader(&quot;x-auth-token&quot;, apiAttributes.get(&apos;token&apos;)) : &quot;&quot;
					apiAttributes.get(&apos;apiInfo&apos;) ? httpPut.addHeader(&quot;api-info&quot;, apiAttributes.get(&apos;apiInfo&apos;)) : &quot;&quot;

					httpPut.setEntity(new StringEntity(JSON.stringify(requestParam)))

					var statusCode, entity, responseString, resp
					try {
					logger.info(&quot;Going to execute api request &quot;)
					resp = httpclient.execute(httpPut);
					statusCode = resp.getStatusLine().getStatusCode();
					entity = resp.getEntity();
					responseString = EntityUtils.toString(entity, &quot;UTF-8&quot;);

					if (statusCode == 200 || statusCode == 201) {
					logger.info(&quot;API Executed succesfully with Status Code ===== &quot; + statusCode)
					}
					return responseString;
					} catch (err) {
					logger.error(&quot;ERROR Occured while PUT Request&quot; + err);

					} finally {
					resp.close();
					}

					} else {
					logger.error(&quot;[API Request Get] : Api Url is not defined in Request Map&quot;)
					}

					}

					function deleteRequest(requestParam,apiAttributes){
					logger.info(&quot;Inside Delete  Method with requestParams  &quot; +requestParam  + &quot;API attributes&quot; +  apiAttributes )
					var httpclient = new DefaultHttpClient();

					// Building the request

					if (apiAttributes.get(&apos;url&apos;)) {
					logger.info(&quot;Making Request to Url ==&quot; + apiAttributes.get(&apos;url&apos;))
					var httpDelete = new HttpDelete(apiAttributes.get(&apos;url&apos;));
					// Specify Headers which you want to send
					httpDelete.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);

					apiAttributes.get(&apos;token&apos;) ? httpDelete.addHeader(&quot;x-auth-token&quot;, apiAttributes.get(&apos;token&apos;)) : &quot;&quot;
					apiAttributes.get(&apos;apiInfo&apos;) ? httpDelete.addHeader(&quot;api-info&quot;, apiAttributes.get(&apos;apiInfo&apos;)) : &quot;&quot;

					//httpGet.setEntity(new StringEntity(JSON.stringify(requestParam)))

					var statusCode, entity, responseString, resp
					try {
					logger.info(&quot;Going to execute api request &quot;)
					resp = httpclient.execute(httpDelete);
					statusCode = resp.getStatusLine().getStatusCode();
					entity = resp.getEntity();
					responseString = EntityUtils.toString(entity, &quot;UTF-8&quot;);

					if (statusCode == 200 &amp;&amp; statusCode == 201) {
					logger.info(&quot;API Executed succesfully with Status Code ===== &quot; + statusCode)
					}
					return responseString;
					} catch (err) {
					logger.error(&quot;Error occured while DELETE request&quot; + err);

					} finally {
					resp.close();
					}

					} else {
					logger.error(&quot;[API Request Get] : Api Url is not defined in Request Map&quot;)
					}
					}


					function postRequest(requestParam, apiAttributes) {
					// logger.info(&quot;Inside api request with url &quot; + url + &quot; requestParam==&quot; + requestParam + &quot;Token-===&quot; + token +  &quot;apiInfo&quot; +  apiInfo)
					var httpclient = new DefaultHttpClient();

					// Building the request
					logger.info(&quot;Making Request to Url ==&quot; + apiAttributes.get(&apos;url&apos;))
					var httpPost = new HttpPost(apiAttributes.get(&apos;url&apos;));
					// Specify Headers which you want to send
					httpPost.addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);


					apiAttributes.get(&apos;token&apos;) ? httpPost.addHeader(&quot;x-auth-token&quot;, apiAttributes.get(&apos;token&apos;)) : &quot;&quot;
					apiAttributes.get(&apos;apiInfo&apos;) ? httpPost.addHeader(&quot;api-info&quot;, apiAttributes.get(&apos;apiInfo&apos;)) : &quot;&quot;

					httpPost.setEntity(new StringEntity(JSON.stringify(requestParam)))

					var statusCode, entity, responseString, resp
					try {
					logger.info(&quot;Going to execute api request &quot;)
					resp = httpclient.execute(httpPost);
					statusCode = resp.getStatusLine().getStatusCode();
					entity = resp.getEntity();
					responseString = EntityUtils.toString(entity, &quot;UTF-8&quot;);
					if (statusCode == 200 || statusCode == 201) {
					logger.info(&quot;API Executed succesfully with Status Code ===== &quot; + statusCode)
					}
					return responseString;
					} catch (err) {
					logger.error(&quot;ERROR Executed with POST REQUEST  &quot; + err);

					} finally {
					resp.close();
					}

					}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>4b933e7c-f206-409b-951b-758c9b4c9442</id>
            <name>checkFieldsToFilter</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522846288</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function  checkFieldsToFilter(msg) {
					logger.info(&quot;msg : &quot;+msg)
					var filter = false;
					var sendingfacility;

					sendingfacility = msg[&apos;MSH&apos;][&apos;MSH.4&apos;][&apos;MSH.4.1&apos;].toString();
					if(sendingfacility.search(/SWF_/) &gt; -1){
					filter = true
					}

					return filter;
					}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>8d0f39ba-8e47-4096-bd41-e804ce91c526</id>
            <name>compressFile</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522846048</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {String} arg1 - arg1 description
					@return {String} return description
					*/
					function compressFile(filenameInZip, fileContents, password, tmpDir) {

					importPackage(Packages.net.lingala.zip4j);

					var uuid = UUIDGenerator.getUUID();

					var filenameZip = tmpDir + uuid + &quot;.zip&quot;;
					var filenameCsv = tmpDir + uuid + &quot;.csv&quot;;

					var zipFile = new Packages.net.lingala.zip4j.core.ZipFile( filenameZip );
					var filesToAdd = new java.util.ArrayList();

					FileUtil.write( filenameCsv, false, fileContents );

					filesToAdd.add( new java.io.File( filenameCsv ) );

					var parameters = new Packages.net.lingala.zip4j.model.ZipParameters();
					//parameters.setCompressionMethod(Packages.net.lingala.zip4j.util.Zip4jConstants.COMP_STORE); // set compression method to store compression
					parameters.setEncryptFiles(true);

					// Set the encryption method to AES Zip Encryption
					parameters.setEncryptionMethod(Packages.net.lingala.zip4j.util.Zip4jConstants.ENC_METHOD_AES);
					parameters.setAesKeyStrength(Packages.net.lingala.zip4j.util.Zip4jConstants.AES_STRENGTH_256);
					// Standard zip Encryption
					//parameters.setEncryptionMethod(Zip4jConstants.ENC_METHOD_STANDARD);
					parameters.setFileNameInZip( filenameInZip );
					parameters.setSourceExternalStream(true);

					parameters.setPassword(password);

					zipFile.addFiles(filesToAdd, parameters);

					var zipBase64 = FileUtil.encode( FileUtil.readBytes( filenameZip ) );

					// Delete tmp files
					var file = Packages.java.io.File( filenameZip );
					file[&quot;delete&quot;]();
					file = Packages.java.io.File( filenameCsv );
					file[&quot;delete&quot;]();

					return zipBase64;
					}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>5fb8315d-d5ce-4c14-bb47-2748eeb5729d</id>
            <name>convertCSVPhysName1</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522848100</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {String} arg1 - arg1 description
					@return {String} return description
					*/
					/**
					Convert CSV Physician Name
					*/
					// modify function_name and parameters as you wish.
					// one function per template is recommended. i.e.) create a new code template for each new function.
					function convertCSVPhysName1(physName) {
					var convertedName = new java.util.HashMap()
					try {
					logger.info(&quot;The physician name recieved is : &quot; + physName);

					// write code here.
					//var salutation = &quot;&quot;;
					var firstName = &quot;&quot;;
					var middleName = &quot;&quot;;
					var lastName = &quot;&quot;;
					//var listOfSalutations = [&apos;Dr&apos;,&apos;Dr.&apos;,&apos;Mr&apos;,&apos;Mr.&apos;,&apos;Mrs&apos;,&apos;Mrs.&apos;,&apos;Ms&apos;,&apos;Ms.&apos;];

					//var nameArr = physName.split(&quot; &quot;);
					var nameArr = physName.split(&quot;,&quot;);

					//lastName = nameArr[nameArr.length - 1 ];


					if (nameArr.length == 1) {
					firstName = nameArr[nameArr.length - 1].trim()
					} else if(nameArr.length &gt; 2){
					firstName =   nameArr.splice(1).reverse().join(&quot; &quot;)
					lastName = nameArr[0].trim()

					// lastName =  nameArr[0].replace(/,/g, &quot;&quot;)
					}else{
					firstName =   nameArr.splice(1).join(&quot; &quot;)
					lastName = nameArr[0].trim()
					}

					convertedName.put(&apos;firstName&apos;, firstName)
					convertedName.put(&apos;lastName&apos;, lastName)

					logger.info(&quot;The extracted name is : Last Name = &quot; + convertedName.get(&apos;lastName&apos;) + &quot; First Name = &quot; + convertedName.get(&apos;firstName&apos;));
					} catch (e) {
					logger.error(&quot;Exception occured while splitting Name&quot;+e)
					}

					return convertedName
					}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>a8f4327b-e1c0-41b0-afd9-7c3ac15e5f4f</id>
            <name>createAndUpdateUser</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522848527</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {String} arg1 - arg1 description
					@return {String} return description

					//Send requestMap in function with all required parameters to create User
					*/

					function createAndUpdateUser(requestMap) {
					logger.info(&quot;[User Creation] : Inside  User  Creation function &quot;)
					var userCreate_response = {}
					try {
					var userNameandPassword= {}
					//	var convertedDob =  DateUtil.convertDate(&apos;yyyyMMdd&apos;, &quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.sss&apos;Z&apos;&quot;, dtStr)
					var userCreate_json_data={}

					userCreate_json_data={
					&quot;username&quot; : requestMap.get(&apos;username&apos;),
					&quot;firstName&quot;: requestMap.get(&apos;firstName&apos;),
					&quot;lastName&quot;: requestMap.get(&apos;lastName&apos;),
					&quot;userType&quot; : requestMap.get(&apos;userType&apos;),
					&quot;enabled&quot;:true,
					&quot;activeResource&quot;:{&quot;status&quot;:&quot;ACTIVE&quot;},
					&quot;email&quot;: requestMap.get(&apos;email&apos;),
					&quot;phoneNo&quot;: requestMap.get(&apos;phone&apos;),
					&quot;countryCode&quot;:requestMap.get(&apos;countryCode&apos;),
					&quot;gender&quot;:requestMap.get(&apos;gender&apos;),
					&quot;dob&quot;:requestMap.get(&apos;dob&apos;),
					&quot;prefix&quot;:requestMap.get(&apos;prefix&apos;),
					&quot;countryCodeFax&quot;:requestMap.get(&apos;countryCodeFax&apos;),
					&quot;faxNo&quot;:requestMap.get(&apos;faxNo&apos;)
					}

					if(requestMap.get(&apos;userId&apos;)){
					userCreate_json_data.username=requestMap.get(&apos;username&apos;),
					userCreate_json_data.userGroups=requestMap.get(&apos;userGroups&apos;),
					userCreate_json_data.id=requestMap.get(&apos;userId&apos;)

					}else{
					var passwordCreateMap =  new java.util.HashMap()

					passwordCreateMap.put(&apos;firstname&apos;,requestMap.get(&apos;firstName&apos;))
					passwordCreateMap.put(&apos;email&apos;,requestMap.get(&apos;email&apos;))

					userNameandPassword = GenerateUserNameAndPassword(passwordCreateMap)
					userCreate_json_data.password  = userNameandPassword.password
					userCreate_json_data.userGroups = requestMap.get(&apos;userGroups&apos;)
					}


					/*  if(userType==&quot;PRACTITIONER&quot;)
					{

					}*/

					//var token = getAuthToken()
					logger.info(&quot;[User] User creation  map : &quot; + JSON.stringify(userCreate_json_data));
					var attr = new java.util.HashMap();
					attr.put(&quot;apiInfo&quot;,JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).apiInfo)
					attr.put(&quot;token&quot; ,requestMap.get(&apos;token&apos;))
					attr.put(&quot;url&quot;,requestMap.get(&apos;userCreateUrl&apos;))
					userCreate_response = apiRequest(&apos;POST&apos;,userCreate_json_data,attr);
					logger.info(&quot;userCreate_response : &quot; + userCreate_response);
					userCreate_response = JSON.parse(userCreate_response);

					if(userCreate_response.httpStatusCode == 200 &amp;&amp; requestMap.get(&apos;userId&apos;) == null) {
					var notificationMap = new java.util.HashMap()
					notificationMap.put(&quot;username&quot;,requestMap.get(&apos;username&apos;))
					notificationMap.put(&quot;userEmail&quot;,requestMap.get(&apos;email&apos;))
					notificationMap.put(&quot;password&quot;,userNameandPassword.password)
					notificationMap.put(&quot;token&quot;,requestMap.get(&apos;token&apos;))


					updateFirstTimePassword(requestMap.get(&apos;username&apos;))
					/* Uncomment below code to sendNotification after user creation */
					// var res =sendEmailNotification(notificationMap)
					//logger.info(&quot;Res Got from Send Notifictaion function is &quot; +  res)
					}

					} catch (e) {
					logger.error(&apos;Exception occured while creating user&apos;+e)
					}


					return userCreate_response;
					}
				</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>66af5541-33a8-4131-9d75-74636033b27b</id>
            <name>createAndUpdateUserGroup</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522845530</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {String} arg1 - arg1 description
					@return {String} return description
					*/

					function createAndUpdateUserGroup(requestMap){
					logger.info(&quot;[User Group]: Inside Create User Group function&quot;)
					//  var token= getAuthToken()
					// var userGroupSaveUrl =  globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userGroupCreate_url
					var save_response = {}
					try {
					var json_data_userGp={}

					json_data_userGp ={

					&quot;name&quot;:requestMap.get(&apos;userGroupName&apos;),
					&quot;organizationId&quot;:requestMap.get(&apos;orgId&apos;),
					&quot;locationId&quot;:requestMap.get(&apos;location&apos;),
					&quot;agreements&quot;:[],
					&quot;menuItems&quot;:requestMap.get(&apos;menuList&apos;),
					&quot;patientBannerMenuItems&quot;:requestMap.get(&apos;patientBannerList&apos;),
					&quot;authorities&quot;:requestMap.get(&apos;rolesJson&apos;),
					}

					if(requestMap.get(&apos;userGroupId&apos;)){
					json_data_userGp.id = requestMap.get(&apos;userGroupId&apos;)
					}

					var userGp_data = JSON.stringify(json_data_userGp);
					logger.info(&quot; [User Group Creation] : User Group json data&quot; + userGp_data )
					var attr= new java.util.HashMap()
					attr.put(&quot;url&quot;,requestMap.get(&apos;userGroupUrl&apos;))
					attr.put(&quot;token&quot;,requestMap.get(&apos;token&apos;))
					attr.put(&quot;apiInfo&quot;,JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).apiInfo)
					save_response = apiRequest(&apos;POST&apos;,json_data_userGp,attr)
					logger.info(&quot;User group creation response==== : &quot; + save_response);
					} catch (e) {
					logger.error(&quot;Exception Occured while creating user Group&quot;+e)
					}

					return save_response

					}
				</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>b8c9f2ed-afed-47b5-834f-c8eb7bd2586f</id>
            <name>createOrUpdateLocation</name>
            <revision>9</revision>
            <lastModified>
              <time>1672725873218</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {String} arg1 - arg1 description
					@return {String} return description

					*/

function getLocationData(locationName, locIdentifier, orgId, facilityAddressMap, checkLocationStatus) {
    logger.info(&quot;[getLocationData] : Inside get Location Function with location Name &quot; + locationName  + &quot;, Organisation Data &quot; + orgId + &quot;, Location Identifier &quot; +locIdentifier);
    logger.info(&quot;[getLocationData] : facilityAddressMap : &quot;+JSON.stringify(facilityAddressMap));
    var returnMap = {};
    returnMap.status = &quot;&quot;;
    returnMap.locationId = null;
    try {
        var locationExist = 0
        var locationReqParams = new java.util.HashMap()
        locationReqParams.put(&apos;keyName&apos;, &apos;identifier.value.value&apos;)
        locationReqParams.put(&apos;keyValue&apos;, locIdentifier)
        var locationData = findDataFromDB(&apos;LOCATION&apos;, locationReqParams)
        if (locationData.totalCount &gt; 0) {
            logger.info(&quot;A LOCATION WITH SAME IDENTIFIER EXISTS&quot;)

			logger.info(&quot;Getting location data from db =======&quot;)
			var cursor = locationData.message
			var lookUpEntry = JSON.parse(cursor.next())

			logger.info(&quot;LOCATION RESOURCE LookUpEntry : &quot;+JSON.stringify(lookUpEntry))

			var locationNameFromDb = lookUpEntry.name ? lookUpEntry.name.value : &quot;&quot;
			if(locationNameFromDb == locationName){
				locationExist = 1
				logger.info(&quot;A LOCATION WITH SAME IDENTIFIER AND LOCATION NAME EXISTS&quot;)
			} else {
				logger.info(&quot;A LOCATION WITH SAME IDENTIFIER EXISTS WITH DIFFERENT LOCATION NAME&quot;)
				returnMap.errMessage = &quot;A LOCATION WITH SAME IDENTIFIER EXISTS WITH DIFFERENT LOCATION NAME&quot;
				returnMap.status = &quot;FAILED&quot;
            }

        } else if(locationName &amp;&amp; locationName!=&quot;&quot;){
            locationReqParams.put(&apos;keyName&apos;, &apos;name.value&apos;)
            locationReqParams.put(&apos;keyValue&apos;, locationName)
            locationData = findDataFromDB(&apos;LOCATION&apos;, locationReqParams)
            if(locationData.totalCount &gt; 0){
                logger.info(&quot;A LOCATION WITH SAME LOCATION NAME EXISTS WITH DIFFERENT IDENTIFIER&quot;)
                returnMap.errMessage = &quot;A LOCATION WITH SAME LOCATION NAME EXISTS WITH DIFFERENT IDENTIFIER&quot;
                returnMap.status = &quot;FAILED&quot;
            }else{
                if(!facilityAddressMap.facilityState || facilityAddressMap.facilityState ==&quot;&quot; || !facilityAddressMap.facilityPostalCode || facilityAddressMap.facilityPostalCode == &quot;&quot;){
					logger.info(&quot;EMPTY_FIELD_FACILITY_STATE_OR_FACILITY_POSTALCODE&quot;)
					returnMap.errMessage = &quot;EMPTY_FIELD_FACILITY_STATE_OR_FACILITY_POSTALCODE&quot;
					returnMap.status = &quot;FAILED&quot;
				}else{
					logger.info(&quot;[Location Creation API] :  Going to Create Location with name &quot; + locationName)
					var locationMap = new java.util.HashMap()
					locationMap.put(&quot;locationName&quot;, locationName)
					locationMap.put(&quot;orgId&quot;, orgId)
					locationMap.put(&quot;locIdentifier&quot;, locIdentifier)
				
					locationMap.put(&quot;facilityAddress&quot;, facilityAddressMap.facilityAddress)
					locationMap.put(&quot;facilityCity&quot;, facilityAddressMap.facilityCity)
					locationMap.put(&quot;facilityState&quot;, facilityAddressMap.facilityState)
					locationMap.put(&quot;facilityPostalCode&quot;, facilityAddressMap.facilityPostalCode)
					locationMap.put(&quot;facilityTINNumber&quot;, facilityAddressMap.facilityTINNumber)
					var respMap = createOrUpdateLocation(locationMap)
					if(respMap.status != &quot;FAILED&quot;){
						var locres = respMap.location
						if(Object.keys(locres).length &gt; 0){
							logger.info(&quot;LOCATION_CREATED_SUCCESSFULLY : &quot;+locres.id);
							returnMap.errMessage = respMap.errMessage
							returnMap.locationId = locres.id;
							returnMap.id = locres.id;
						}else{
							returnMap.errMessage = &quot;UNABLE_TO_CREATE_LOCATION&quot;
							returnMap.status = &quot;FAILED&quot;
						}
					}else{
						returnMap.errMessage = respMap.errMessage
						returnMap.status = respMap.status
					}
				}
            }
        }
        else{
            logger.info(&quot;LOCATION NAME IS MISSING FOR NEW LOCATION&quot;)
            returnMap.errMessage = &quot;LOCATION NAME IS MISSING FOR NEW LOCATION : &quot;+locationName;
            returnMap.status = &quot;FAILED&quot;
        }
        if(locationExist == 1){

            if(checkLocationStatus == true &amp;&amp; !(lookUpEntry.status &amp;&amp; lookUpEntry.status.value == &quot;active&quot;)){
                returnMap.errMessage = &quot;EXCEPTION_WHILE_GETTING_LOCATION_IDS&quot;
                returnMap.status = &quot;FAILED&quot;
            }
            else{
				var locationAddress = lookUpEntry.address[0].line[0] ? lookUpEntry.address[0].line[0].value : &quot;&quot;
				var locationPostalCode = lookUpEntry.address[0].postalCode ? lookUpEntry.address[0].postalCode.value : &quot;&quot;
				var locationState = lookUpEntry.address[0].state ? lookUpEntry.address[0].state.value : &quot;&quot;
				var locationCity = lookUpEntry.address[0].city ? lookUpEntry.address[0].city.value : &quot;&quot;
				var locationTIN = null
				for(var i =0; i&lt;lookUpEntry.identifier.length;i++){
					if(lookUpEntry.identifier[i].type.text.value == &quot;TIN&quot;)
						locationTIN = lookUpEntry.identifier[i].value.value
				}
				if((facilityAddressMap.facilityAddress == null || facilityAddressMap.facilityAddress == &quot;&quot;) &amp;&amp; (facilityAddressMap.facilityPostalCode == null || facilityAddressMap.facilityPostalCode == &quot;&quot;) &amp;&amp; (facilityAddressMap.facilityState == null || facilityAddressMap.facilityState==&quot;&quot;) &amp;&amp; (facilityAddressMap.facilityCity == null || facilityAddressMap.facilityCity == &quot;&quot;)){
					logger.info(&quot;No update for facility received.&quot;)
					returnMap.locationId = lookUpEntry._id;
					returnMap.id = lookUpEntry._id;
				}else if((locationAddress &amp;&amp;  (facilityAddressMap.facilityAddress == null || facilityAddressMap.facilityAddress == &quot;&quot;) ) || (locationPostalCode &amp;&amp; (facilityAddressMap.facilityPostalCode == null || facilityAddressMap.facilityPostalCode == &quot;&quot;)) || (locationState &amp;&amp; (facilityAddressMap.facilityState == null || facilityAddressMap.facilityState==&quot;&quot;) ) || (locationCity &amp;&amp; (facilityAddressMap.facilityCity == null || facilityAddressMap.facilityCity == &quot;&quot;))){
					logger.info(&quot;DETAILS_ALREADY_EXIST_FOR_FEW_FIELDS_OF_FACILITY_THAT_CAME_AS_NULL_IN_UPDATE|UNABLE_TO_UPDATE_LOCATION&quot;)
					returnMap.errMessage = &quot;DETAILS_ALREADY_EXIST_FOR_FEW_FIELDS_OF_FACILITY_THAT_CAME_AS_NULL_IN_UPDATE|UNABLE_TO_UPDATE_LOCATION&quot;
					returnMap.status = &quot;FAILED&quot;
				}else{
					var locationUpdateMap = new java.util.HashMap()
					locationUpdateMap.put(&quot;locationId&quot;, lookUpEntry._id)
					locationUpdateMap.put(&quot;locationName&quot;, lookUpEntry.name.value)
					locationUpdateMap.put(&quot;orgId&quot;, lookUpEntry.managingOrganization)
					locationUpdateMap.put(&quot;locIdentifier&quot;, locIdentifier)
					locationUpdateMap.put(&quot;facilityAddress&quot;, facilityAddressMap.facilityAddress)
					locationUpdateMap.put(&quot;facilityCity&quot;, facilityAddressMap.facilityCity)
					locationUpdateMap.put(&quot;facilityState&quot;, facilityAddressMap.facilityState)
					locationUpdateMap.put(&quot;facilityPostalCode&quot;, facilityAddressMap.facilityPostalCode)
					if(locationTIN == null){
						locationUpdateMap.put(&quot;facilityTINNumber&quot;, facilityAddressMap.facilityTINNumber)	
					}
					logger.info(&quot;Going to update Location, locationUpdateMap : &quot;+locationUpdateMap)
					//var locres = createOrUpdateLocation(locationUpdateMap)
					var respMap = createOrUpdateLocation(locationUpdateMap)
					if(respMap.status != &quot;FAILED&quot;){
						var locres = respMap.location
						if(Object.keys(locres).length &gt; 0){
							logger.info(&quot;LOCATION_UPDATED_SUCCESSFULLY : &quot;+locres.id);
							returnMap.errMessage = respMap.errMessage
							returnMap.locationId = locres.id;
							returnMap.id = locres.id;
						}else{
							returnMap.errMessage = &quot;UNABLE_TO_UPDATE_LOCATION&quot;
							returnMap.status = &quot;FAILED&quot;
						}
					}else{
						returnMap.errMessage = respMap.errMessage
						returnMap.status = respMap.status
					}
				}
            }
        }
    } catch (e) {
        logger.error(&quot;Exception Occured while Searching location&quot;+e + e.stack)
        returnMap.errMessage = &quot;EXCEPTION_WHILE_GETTING_LOCATION_DETAILS&quot;
        returnMap.status = &quot;FAILED&quot;
    }
    logger.info(&quot;getLocationData return Map : &quot;+JSON.stringify(returnMap))
    return returnMap
}

function createOrUpdateLocation(requestMap){
	var returnMap = {};
	returnMap.status =&quot;&quot;
    logger.info(&quot;createOrUpdateLocation :  requestMap : &quot;+JSON.stringify(requestMap))
    logger.info(&quot;[Location Creation or Updation API] : Inside Create or Update Location Function with location Name &quot; + requestMap.get(&quot;locationName&quot;))
    var location = {}
    try {
        var requestType = &apos;POST&apos;
        var locationSaveOrUpdateApi
        var location_json={}
        //logger.info(&quot;createOrUpdateLocation : locationSaveOrUpdateApi : &quot; + locationSaveOrUpdateApi)
        var facilityAddressText =&quot;&quot;
        if(requestMap.get(&apos;facilityAddress&apos;) || requestMap.get(&apos;facilityCity&apos;) || requestMap.get(&apos;facilityState&apos;) || requestMap.get(&apos;facilityPostalCode&apos;)){
            
			
			var countryId = &quot;&quot;
			var countrySearchMap = {}
			countrySearchMap[&quot;code&quot;] = &quot;United States&quot;
			var countrySearchData = findDataFromDB(&apos;COUNTRIESSET&apos;,countrySearchMap)
			logger.info(&quot;countrySearchData: &quot;+JSON.stringify(countrySearchData))
			if(countrySearchData.totalCount  &amp;&amp; countrySearchData.totalCount == 1){
				var cursor = countrySearchData.message
				var lookUpEntry = JSON.parse(cursor.next())
				countryId = lookUpEntry._id.toString()
			}
			
			var stateId = &quot;&quot;
			var stateCode = &quot;&quot;
			var stateName =&quot;&quot;
			var stateSearchMap = {}
			stateSearchMap[&quot;name&quot;] = requestMap.get(&apos;facilityState&apos;)
			stateSearchMap[&quot;country_id&quot;] = countryId
			var StateSearchData = findDataFromDB(&apos;STATESSET&apos;,stateSearchMap)
			if(StateSearchData.totalCount  &amp;&amp; StateSearchData.totalCount == 1){
				var cursor = StateSearchData.message
				var lookUpEntry = JSON.parse(cursor.next())
				stateId = lookUpEntry._id.toString()
				stateCode = lookUpEntry.code
				stateName = lookUpEntry.name
				requestMap.put(&quot;facilityState&quot;,stateCode)
			}else{
				returnMap.errMessage = &quot;STATE DOES NOT EXIST IN DATABASE : &quot;+ requestMap.get(&apos;facilityState&apos;);
				returnMap.status = &quot;FAILED&quot;
				throw(&quot;STATE DOES NOT EXIST IN DATABASE&quot;)
			}
			
			var cityCode = &quot;&quot;
			var cityName = &quot;&quot;
			var citySearchMap = {}
			citySearchMap[&quot;name&quot;] = requestMap.get(&apos;facilityCity&apos;)
			citySearchMap[&quot;state_id&quot;] = stateId
            var citySearchData = findDataFromDB(&apos;CITIESSET&apos;,citySearchMap)
			if(citySearchData.totalCount  &amp;&amp; citySearchData.totalCount == 1){
				var cursor = citySearchData.message
				var lookUpEntry = JSON.parse(cursor.next())
				cityCode = lookUpEntry.code
				cityName = lookUpEntry.name
				requestMap.put(&quot;facilityCity&quot;, cityCode)
			}else{
				logger.info(&quot;CITY DOES NOT EXIST IN DATABASE&quot;)
				returnMap.errMessage = &quot;CITY DOES NOT EXIST IN DATABASE. FACILITY WILL BE CREATED/UPDATED WITHOUT CITY: &quot;+ requestMap.get(&apos;facilityCity&apos;);
				requestMap.put(&quot;facilityCity&quot;, &quot;&quot;)
			}
			facilityAddressText = requestMap.get(&apos;facilityAddress&apos;)+&quot;, &quot;+cityName+&quot;, &quot;+stateName+&quot;, United States, &quot;+requestMap.get(&apos;facilityPostalCode&apos;)
			
		}
        //var token =getAuthToken()
        var token = configurationMap.get(&apos;xAuthToken&apos;)
        if(requestMap.get(&quot;locationId&quot;)){
            var locationSaveOrUpdateApi = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).locationUpdateUrl + requestMap.get(&quot;locationId&quot;)
            requestType = &apos;PUT&apos;
            if(requestMap.get(&apos;facilityAddress&apos;) || requestMap.get(&apos;facilityCity&apos;) || requestMap.get(&apos;facilityState&apos;) || requestMap.get(&apos;facilityPostalCode&apos;)){
                location_json.address=[{&quot;line&quot;:[requestMap.get(&apos;facilityAddress&apos;),&quot;&quot;], &quot;state&quot;:requestMap.get(&quot;facilityState&quot;),&quot;postalCode&quot;:requestMap.get(&quot;facilityPostalCode&quot;),&quot;city&quot;:requestMap.get(&quot;facilityCity&quot;),&quot;country&quot;:&quot;United States&quot;,&quot;text&quot;:facilityAddressText}]
            }
            if(requestMap.get(&apos;facilityTINNumber&apos;) &amp;&amp; requestMap.get(&apos;facilityTINNumber&apos;)!=&quot;&quot;){
            	location_json.identifier = [{&quot;system&quot;:{&quot;value&quot;:globalMap.get(&quot;custName&quot;)},&quot;value&quot;:requestMap.get(&quot;locIdentifier&quot;),&quot;useCode&quot;:&quot;usual&quot;,&quot;type&quot;:{&quot;text&quot;:&quot;performingLocationId&quot;}},{&quot;value&quot;:requestMap.get(&quot;facilityTINNumber&quot;),&quot;useCode&quot;:&quot;usual&quot;,&quot;type&quot;:{&quot;text&quot;:&quot;TIN&quot;}}]
            }
        }else{
            var locationSaveOrUpdateApi = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).locationCreateUrl

            location_json={
                &quot;mode&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).locationMode,
                &quot;name&quot;:{&quot;value&quot;: requestMap.get(&quot;locationName&quot;)},
                &quot;identifier&quot;:[{&quot;system&quot;:{&quot;value&quot;:globalMap.get(&quot;custName&quot;)},&quot;value&quot;:requestMap.get(&quot;locIdentifier&quot;),&quot;useCode&quot;:&quot;usual&quot;,&quot;type&quot;:{&quot;text&quot;:&quot;performingLocationId&quot;}}],
                &quot;description&quot;:&quot;\n&quot;,
                &quot;telecom&quot;:[],
                &quot;status&quot;:&quot;active&quot;,
                &quot;visible&quot;:false,
                &quot;partOf&quot;:null,
                &quot;managingOrganization&quot;: {&quot;id&quot;: requestMap.get(&quot;orgId&quot;)},
                &quot;type&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).locationType,
                &quot;physicalType&quot;:JSON.parse(configurationMap.get(&apos;locationInfo&apos;)).physicalType,
                &quot;address&quot;:[{&quot;line&quot;:[requestMap.get(&apos;facilityAddress&apos;),&quot;&quot;], &quot;state&quot;:requestMap.get(&quot;facilityState&quot;),&quot;postalCode&quot;:requestMap.get(&quot;facilityPostalCode&quot;),&quot;city&quot;:requestMap.get(&quot;facilityCity&quot;),&quot;country&quot;:&quot;United States&quot;,&quot;text&quot;:facilityAddressText}]
            }
            if(requestMap.get(&apos;facilityTINNumber&apos;) &amp;&amp; requestMap.get(&apos;facilityTINNumber&apos;)!=&quot;&quot;)
            	location_json.identifier = [{&quot;system&quot;:{&quot;value&quot;:globalMap.get(&quot;custName&quot;)},&quot;value&quot;:requestMap.get(&quot;locIdentifier&quot;),&quot;useCode&quot;:&quot;usual&quot;,&quot;type&quot;:{&quot;text&quot;:&quot;performingLocationId&quot;}},{&quot;value&quot;:requestMap.get(&quot;facilityTINNumber&quot;),&quot;useCode&quot;:&quot;usual&quot;,&quot;type&quot;:{&quot;text&quot;:&quot;TIN&quot;}}]
        }

        logger.info(&quot;[Location Creation or Updation API] :  Location Creation or Updation JSON is &quot; + JSON.stringify(location_json))

        var attr = new java.util.HashMap()
        attr.put(&quot;url&quot;,locationSaveOrUpdateApi)
        attr.put(&quot;token&quot;,token)

        var locationResponse= apiRequest(requestType,location_json,attr)
        logger.info(&quot;[Location Creation or Updation API] : Location Creation or Updation Response from API is &quot; + locationResponse)
        location=JSON.parse(locationResponse)
		returnMap.location = location

    } catch (e) {
        logger.error(&quot;Exception Occured while Creating or Updating location&quot;+e)
		
    }

    return returnMap
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>06f6d32d-6417-4519-97ef-78c44d8165fa</id>
            <name>createPractitioner</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522845212</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {String} arg1 - arg1 description
					@return {String} return description
					*/
					function createPractitioner(requestMap){
					var telecomList = new Packages.java.util.ArrayList()
					var practitionerRoleList=  new Packages.java.util.ArrayList()
					var pracResponse = {}
					try {
					var telecomData= {}
					if(requestMap.get(&apos;physPhone&apos;)){
					telecomData= {}
					telecomData.countryCode=requestMap.get(&apos;countryCode&apos;),
					telecomData.primary=true
					telecomData.system=&quot;phone&quot;
					telecomData.useCode= &quot;home&quot;,
					telecomData.value=requestMap.get(&apos;physPhone&apos;)
					}

					telecomList.add(telecomData)
					if(requestMap.get(&apos;physEmail&apos;)){
					telecomData= {}
					telecomData.primary=true
					telecomData.system=&quot;email&quot;
					telecomData.useCode= &quot;email&quot;,
					telecomData.value= requestMap.get(&apos;physEmail&apos;)
					}
					telecomList.add(telecomData)

					var practitioner_json={}

					//var addressString = requestMap.get(&apos;address&apos;) + &quot; &quot; +  requestMap.get(&apos;city&apos;) + &quot;  &quot; + requestMap.get(&apos;state&apos;) +  &quot; &quot;+  requestMap.get(&apos;postalCode&apos;) +&quot; &quot; +  requestMap.get(&apos;country&apos;)

					practitioner_json={
					&quot;active&quot;:true,
					&quot;gender&quot;:requestMap.get(&apos;physGender&apos;),
					&quot;identifier&quot;:[{&quot;type&quot;:{&quot;coding&quot;:[{&quot;code&quot;:configurationMap.get(&apos;typeCode&apos;)}],&quot;text&quot;:&quot;National provider identifier&quot;},&quot;useCode&quot;:&quot;official&quot;,&quot;value&quot;:requestMap.get(&apos;physIdentifier&apos;),&quot;system&quot;: &quot;NPI&quot;}],
					&quot;name&quot;:[{&quot;family&quot;:requestMap.get(&apos;physLastName&apos;),&quot;given&quot;:requestMap.get(&apos;physFirstName&apos;),&quot;period&quot;:null,&quot;prefix&quot;:[],&quot;suffix&quot;:[],&quot;text&quot;:requestMap.get(&apos;physName&apos;),&quot;useCode&quot;:&quot;Human Name&quot;}],
					&quot;practitionerRole&quot;:[{&quot;specialty&quot;:[],&quot;role&quot;:{&quot;text&quot;:&quot;&quot;},&quot;managingOrganization&quot;:{&quot;id&quot;:requestMap.get(&apos;orgId&apos;)}}],
					&quot;location&quot;:requestMap.get(&apos;location&apos;),
					&quot;telecom&quot;:telecomList

					}

					if(requestMap.get(&apos;tinNo&apos;) &amp;&amp; requestMap.get(&apos;tinNo&apos;)!=&quot;&quot;){
						practitioner_json.identifier = [{&quot;type&quot;:{&quot;coding&quot;:[{&quot;code&quot;:configurationMap.get(&apos;typeCode&apos;)}],&quot;text&quot;:&quot;National provider identifier&quot;},&quot;useCode&quot;:&quot;official&quot;,&quot;value&quot;:requestMap.get(&apos;physIdentifier&apos;),&quot;system&quot;: &quot;NPI&quot;}, {&quot;system&quot;:{&quot;value&quot;:&quot;Tax Id&quot;},&quot;type&quot;:{&quot;coding&quot;:[{&quot;code&quot;:&quot;TIN&quot;}],&quot;text&quot;:&quot;Tax ID Number&quot;},&quot;useCode&quot;:&quot;usual&quot;,&quot;value&quot;:requestMap.get(&apos;tinNo&apos;)}]
					}

					logger.info(&quot;[Practitioner Creation API] : &quot;)

					logger.info(&quot;[Practitioner Creation API] : practitioner_json for API is  &quot; + JSON.stringify(practitioner_json) + requestMap.get(&apos;practitionerUrl&apos;))
					var attr= new java.util.HashMap()
					attr.put(&quot;url&quot;,requestMap.get(&apos;practitionerUrl&apos;))
					attr.put(&quot;token&quot;,requestMap.get(&apos;token&apos;))
					//  attr.put(&apos;apiInfo&apos;,configurationMap.get(&apos;apiInfo&apos;))
					if(!requestMap.get(&apos;physId&apos;)){
					pracResponse=apiRequest(&apos;POST&apos;,practitioner_json,attr)
					}else{
					practitioner_json.id=requestMap.get(&apos;physId&apos;)
					pracResponse=apiRequest(&apos;PUT&apos;,practitioner_json,attr)
					}


					} catch (e) {
					logger.error(&quot;Exception Occured while Creating Practitioner&quot;+e)
					}

					return JSON.parse(pracResponse)
					}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>bd04a698-bbad-4721-b3a0-579e6159404b</id>
            <name>createPractitionerViaMFNAndAPI</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522846456</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>

					/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {Any} action -
					@param {Any} msg -
					@return {String} return description
					*/
					function createPractitionerViaMFNAndAPI(action,msg){
					globalMap.put(&apos;pracReport&apos;,&quot;&quot;)
					if(action == &apos;MFN&apos;) {
					var result=null
					var count = 0
					result= createPractitionerMFN(msg,count)
					logger.info(&quot;[Practitioner MFN Creation]  : Result got from Processing MFN message &quot; + result)

					return result;
					}

					if(action == &apos;API&apos;){
					var result={}
					var count = 0
					result= createPractitionerAPI(msg,count)
					logger.info(&quot;[Practitioner API  Creation] : Result got from processing data via API&quot; + JSON.stringify(result))
					return result
					}

					}


					function createPractitionerMFN(msg,count){
					logger.info(&quot;[Practitioner Creation] : Inside createPractitionerMFN with Data &quot; + msg)
					var messageString = &quot;&quot;;

					try {
					var dateTimeTmp = new java.util.Date();
					var origfilename = sourceMap.get(&apos;originalFilename&apos;);
					var insertion_source = &quot;MIRTH&quot;;
					var eventType = &quot;M02&quot;;
					var report = &apos;&apos;
					for each (seg in msg.children()) {
					var errMessage = &quot;&quot;;
					var status = &quot;&quot;;
					if(count==0){
					report = report + (SerializerFactory.getSerializer(&apos;DELIMITED&apos;).fromXML(seg)).replace(&apos;\n&apos;,&apos;&apos;) +&quot;,Status,Filter Reason\n&quot;;
					logger.info(&quot;Header information &quot;+(SerializerFactory.getSerializer(&apos;DELIMITED&apos;).fromXML(seg)).replace(&apos;\n&apos;,&apos;&apos;));
					}else{
					logger.info(&quot;[Create Practitioner MFN] :  Iterating over Segments to create MFN message&quot;)

					var physicianName = convertCSVPhysName1(seg[&apos;physicianName&apos;].toString())
					var physicianIdentifier = seg[&apos;physicianEmail&apos;].trim()?seg[&apos;physicianEmail&apos;].trim().toString():&quot;&quot;
					var physicianEmail =  seg[&apos;physicianEmail&apos;].trim()?seg[&apos;physicianEmail&apos;].trim().toString():&quot;&quot;
					var physicianSurname=  physicianName.get(&apos;lastName&apos;)
					var physicianFirstName =   physicianName.get(&apos;firstName&apos;)
					var physicianPhoneNumber=seg[&apos;physicianPhone&apos;].trim()?seg[&apos;physicianPhone&apos;].trim().toString():&quot;&quot;
					var physicianGender=seg[&apos;physicianGender&apos;].trim()?seg[&apos;physicianGender&apos;].trim().toString():&quot;&quot;
					var physicianLocation=seg[&apos;physicianLocation&apos;].trim()?seg[&apos;physicianLocation&apos;].trim().toString().split(configurationMap.get(&apos;locationDelimiter&apos;)):&quot;&quot;

					var physicianLocationIdentifier=seg[&apos;physicianLocationIdentifier&apos;].trim()?seg[&apos;physicianLocationIdentifier&apos;].trim().toString().split(configurationMap.get(&apos;locationDelimiter&apos;)):&quot;&quot;
					var dept = seg[&apos;Dept&apos;].trim() ? seg[&apos;Dept&apos;].trim().toString() : &quot;&quot;


					var pracValidateMap = new java.util.HashMap()
					pracValidateMap.put(&apos;physicianFirstName&apos;,physicianFirstName)
					pracValidateMap.put(&apos;physicianSurname&apos;,physicianSurname)
					pracValidateMap.put(&apos;physicianEmail&apos;,physicianEmail)
					pracValidateMap.put(&apos;physicianPhone&apos;,physicianPhoneNumber)
					pracValidateMap.put(&apos;physicianLocation&apos;,physicianLocation)
					pracValidateMap.put(&apos;physicianLocationIdentifier&apos;,physicianLocationIdentifier)
					pracValidateMap.put(&apos;physicianResidentifier&apos;,physicianIdentifier)
					var filterFlag = filterCSVData(pracValidateMap)

					if(filterFlag.flag == true)	{
					var msgNew = &lt;HL7Message/&gt;;
					createSegment(&apos;MSH&apos;, msgNew);
					msgNew.MSH[&apos;MSH.1&apos;] = &apos;|&apos;;
					msgNew.MSH[&apos;MSH.2&apos;] = &apos;^~\\^&apos;;
					msgNew.MSH[&apos;MSH.3&apos;][&apos;MSH.3.1&apos;] = &apos;MINERVA&apos;;
					msgNew.MSH[&apos;MSH.4&apos;][&apos;MSH.4.1&apos;] = &apos;MPHRX&apos;;
					msgNew.MSH[&apos;MSH.5&apos;][&apos;MSH.5.1&apos;] = &apos;MPHRX&apos;;
					msgNew.MSH[&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = &apos;MPHRX&apos;;
					msgNew.MSH[&apos;MSH.6&apos;][&apos;MSH.6.2&apos;] = &apos;MPHRX&apos;
					msgNew.MSH[&apos;MSH.9&apos;][&apos;MSH.9.1&apos;] = &apos;MFN&apos;;
					msgNew.MSH[&apos;MSH.9&apos;][&apos;MSH.9.2&apos;] = eventType;
					msgNew.MSH[&apos;MSH.10&apos;][&apos;MSH.10.1&apos;] = &apos;123455&apos;;
					msgNew.MSH[&apos;MSH.11&apos;][&apos;MSH.11.1&apos;] = &apos;D&apos;;
					msgNew.MSH[&apos;MSH.12&apos;][&apos;MSH.12.1&apos;] = &apos;2.5&apos;;


					createSegment(&apos;MFI&apos;, msgNew);
					msgNew.MFI[&apos;MFI.1&apos;][&apos;MFI.1.1&apos;] = &apos;PRA&apos;;
					//msgNew.MFI[&apos;MFI.2&apos;][&apos;MFI.2.1&apos;] = &quot;RAD_INTERLOCUTORES&quot;;
					msgNew.MFI[&apos;MFI.3&apos;][&apos;MFI.3.1&apos;] = &quot;UPD&quot;;
					msgNew.MFI[&apos;MFI.6&apos;][&apos;MFI.6.1&apos;] = &quot;AL&quot;;

					createSegment(&apos;MFE&apos;, msgNew);
					msgNew.MFE[&apos;MFE.1&apos;][&apos;MFE.1.1&apos;] = &apos;MUP&apos;;


					createSegment(&apos;STF&apos;, msgNew);
					msgNew.STF[&apos;STF.2&apos;][&apos;STF.2.1&apos;] = physicianIdentifier;
					msgNew.STF[&apos;STF.3&apos;][&apos;STF.3.1&apos;] = physicianSurname;
					msgNew.STF[&apos;STF.3&apos;][&apos;STF.3.2&apos;] = physicianFirstName;
					msgNew.STF[&apos;STF.5&apos;][&apos;STF.5.1&apos;] =  physicianGender;
					msgNew.STF[&apos;STF.10&apos;][&apos;STF.10.1&apos;] = physicianPhoneNumber;
					msgNew.STF[&apos;STF.15&apos;][&apos;STF.15.1&apos;] = physicianEmail;
					logger.info(&quot;[Prcatitioner creation MFN] : Going to create MFN  Messages by Location&quot;)


					for  (loc in physicianLocation,physicianLocationIdentifier) {
					logger.info(&quot;[Practitioner Creation MFN ] Location Fetched is &quot;+ physicianLocation[loc])
					var msgPra = &lt;HL7Message/&gt;;
					createSegment(&apos;PRA&apos;, msgPra);
					msgPra.PRA[&apos;PRA.1&apos;][&apos;PRA.1.1&apos;] = &apos;01&apos;;
					msgPra.PRA[&apos;PRA.2&apos;][&apos;PRA.2.2&apos;]=physicianLocationIdentifier[loc]
					msgPra.PRA[&apos;PRA.3&apos;][&apos;PRA.3.1&apos;] = &quot;E&quot;;
					//msgNew.PRA[&apos;PRA.5&apos;][&apos;PRA.5.1&apos;] = specialtyId;
					msgPra.PRA[&apos;PRA.6&apos;][&apos;PRA.6.1&apos;] = physicianIdentifier;
					msgPra.PRA[&apos;PRA.6&apos;][&apos;PRA.6.2&apos;] =globalMap.get(&quot;custName&quot;);
					msgPra.PRA[&apos;PRA.6&apos;][&apos;PRA.6.3&apos;] =configurationMap.get(&apos;typeCode&apos;)

					var topSeg = msgNew.copy();
					topSeg.appendChild(msgPra)
					topSeg.MSH[&apos;MSH.6&apos;][&apos;MSH.6.1&apos;] = physicianLocationIdentifier[loc];
					topSeg.MSH[&apos;MSH.6&apos;][&apos;MSH.6.2&apos;] = physicianLocation[loc]
					var mesg = SerializerFactory.getSerializer(&apos;HL7V2&apos;).fromXML(topSeg);
					logger.info(&quot;[Practitioner Creation MFN] Final MFN Message Created is &quot;+mesg)
					messageString = messageString + mesg
					//messageList.add(mesg)
					status = &quot;SUCCESS&quot;
					}
					}else{
					status = &quot;FAILED&quot;
					errMessage = filterFlag.errorMsg;
					}

					report = report + (SerializerFactory.getSerializer(&apos;DELIMITED&apos;).fromXML(seg)).replace(&apos;\n&apos;,&apos;&apos;) +&quot;,&quot;+status+&quot;,&quot;+errMessage+&quot;\n&quot;;
					}
					count ++;

					}
					globalMap.put(&apos;pracReport&apos;,report)
					} catch (e) {
					logger.error(&quot;Exception Occured in creating practitioner via MFn&quot;+e + e.stack)
					}
					return messageString;
					}


					function createPractitionerAPI(msg,count){
					logger.info(&quot;Inside createPractitionet  Api&quot;)
					var result = {}
					var report =&apos;&apos;
					var reportMap = {}
					reportMap.errMessage = &quot;&quot;;
					reportMap.status = &quot;&quot;;
					reportMap.wrgMessage = &quot;&quot;;
					reportMap.wrgstatus = &quot;&quot;;
					var pracRes=null
					try {
					for each (seg in msg.children()){
					if(count==0){
					report = report + (SerializerFactory.getSerializer(&apos;DELIMITED&apos;).fromXML(seg)).replace(&apos;\n&apos;,&apos;&apos;) +&quot;,Status,Filter Reason\n&quot;;
					logger.info(&quot;Header information &quot;+(SerializerFactory.getSerializer(&apos;DELIMITED&apos;).fromXML(seg)).replace(&apos;\n&apos;,&apos;&apos;));
					}else{

					logger.info(&quot;[Practitioner Creation API]  : Reading CSV values for Practitioner creation &quot;)
					//var token = getAuthToken()
					var token = configurationMap.get(&apos;xAuthToken&apos;)
					var locations = new java.util.ArrayList()
					var orgData=null
					var physicianName = convertCSVPhysName1(seg[&apos;physicianName&apos;].toString())
					var physicianSurname=  physicianName.get(&apos;lastName&apos;) ?physicianName.get(&apos;lastName&apos;).trim() : &quot;&quot;
					var physicianFirstName =   physicianName.get(&apos;firstName&apos;) ? physicianName.get(&apos;firstName&apos;).trim() : &quot;&quot;
					var physicianEmail = seg[&apos;physicianEmail&apos;].trim()?seg[&apos;physicianEmail&apos;].trim().toString():&quot;&quot;
					var physicianPhone = seg[&apos;physicianPhone&apos;].trim()?seg[&apos;physicianPhone&apos;].trim().toString():&quot;&quot;
					var physicianGender = seg[&apos;physicianGender&apos;].trim()?seg[&apos;physicianGender&apos;].trim().toString():&quot;&quot;
					var physicianDob=seg[&apos;physicianDob&apos;].trim()?seg[&apos;physicianDob&apos;].trim().toString():&quot;&quot;
					var physicianLocation=  seg[&apos;physicianLocation&apos;]?seg[&apos;physicianLocation&apos;].toString().trim().split(configurationMap.get(&apos;locationDelimiter&apos;)):&quot;&quot;
					physicianLocation = trimListValue(physicianLocation)
					var physicianLocationIdentifier=seg[&apos;physicianLocationIdentifier&apos;]?seg[&apos;physicianLocationIdentifier&apos;].toString().trim().split(configurationMap.get(&apos;locationDelimiter&apos;)):&quot;&quot;
					physicianLocationIdentifier = trimListValue(physicianLocationIdentifier)
					//var ldapUserName=seg[&apos;ldapUserName&apos;].trim()?seg[&apos;ldapUserName&apos;].trim().toString():&quot;&quot;
					var physicianResidentifier = seg[&apos;physicianResidentifier&apos;].trim()?seg[&apos;physicianResidentifier&apos;].trim().toString():&quot;&quot;
					var dept = seg[&apos;Dept&apos;].trim() ? seg[&apos;Dept&apos;].trim().toString() : &quot;&quot;
					var physCountryCode= seg[&apos;countryCode&apos;].trim() ?seg[&apos;countryCode&apos;].trim().toString() :configurationMap.get(&apos;defaultCountryCode&apos;)
					var physCompleteName =  physicianFirstName + &quot; &quot; + physicianSurname
					//var country = seg[&apos;country&apos;].trim() ? seg[&apos;country&apos;].trim().split(configurationMap.get(&apos;locationDelimiter&apos;)):[]
					var state =  seg[&apos;state&apos;].trim() ? seg[&apos;state&apos;].trim().split(configurationMap.get(&apos;locationDelimiter&apos;)):[]
					state = trimListValue(state)
                    var city = seg[&apos;city&apos;].trim() ? seg[&apos;city&apos;].trim().split(configurationMap.get(&apos;locationDelimiter&apos;)):[]
					city = trimListValue(city)
                    var postalCode = seg[&apos;postalCode&apos;].trim() ?  seg[&apos;postalCode&apos;].trim().split(configurationMap.get(&apos;locationDelimiter&apos;)):[]
					postalCode = trimListValue(postalCode)
                    var address = seg[&apos;address&apos;].trim() ? seg[&apos;address&apos;].trim().split(configurationMap.get(&apos;locationDelimiter&apos;)):[]
					address = trimListValue(address)
					var tinNo = seg[&apos;tinNo&apos;].trim() ? seg[&apos;tinNo&apos;].trim().toString() : &quot;&quot;
					var npi = seg[&apos;npi&apos;].trim() ? seg[&apos;npi&apos;].trim().toString() : &quot;&quot;
					var facitlityTinNo = seg[&apos;facitlityTinNo&apos;].trim() ? seg[&apos;facitlityTinNo&apos;].trim().split(configurationMap.get(&apos;locationDelimiter&apos;)):[]
					facitlityTinNo = trimListValue(facitlityTinNo)


					logger.info(&quot;[Practitioner Creation API] : Practitioner Data got from CSV is Name&quot; + physicianName + &quot;Email &quot; + physicianEmail + &quot;Phone is &quot; + physicianPhone+ &quot;Gender &quot; + physicianGender + &quot;Location is &quot; + physicianLocation + &quot;Location Identfier is &quot; + physicianLocationIdentifier
					+ &quot; Physician Identifier is  &quot; + physicianResidentifier +  &quot;country Code is &quot; +physCountryCode)

					var pracValidateMap = new java.util.HashMap()
					pracValidateMap.put(&apos;physicianFirstName&apos;,physicianFirstName)
					pracValidateMap.put(&apos;physicianSurname&apos;,physicianSurname)
					pracValidateMap.put(&apos;physicianEmail&apos;,physicianEmail)
					pracValidateMap.put(&apos;physicianPhone&apos;,physicianPhone)
					pracValidateMap.put(&apos;physicianLocation&apos;,physicianLocation)
					pracValidateMap.put(&apos;physicianLocationIdentifier&apos;,physicianLocationIdentifier)
					pracValidateMap.put(&apos;physicianResidentifier&apos;,physicianResidentifier)

					var validateResponse = filterCSVData(pracValidateMap)

					if(validateResponse.flag==true){
					if(token){
					if(npi &amp;&amp; npi!=&quot;&quot;){
					physicianResidentifier = npi.toString()
					}else if(physicianResidentifier &amp;&amp; physicianResidentifier!=&quot;&quot;){
					physicianResidentifier = physicianResidentifier
					}

					var pracFindMap = {}

					pracFindMap[&quot;identifier.value.value&quot;] = physicianResidentifier
					pracFindMap[&quot;telecom.value.value&quot;] = physicianEmail
					var practitionerSearchData = findDataFromDB(&apos;PRACTITIONER&apos;,pracFindMap,&quot;OR&quot;)
					logger.info(&quot;[Practitioner Creation API]: Practitioner Search Data is &quot; + JSON.stringify(practitionerSearchData))
					var phyUniquenessMap = phyUniquenessCheck(practitionerSearchData,physicianEmail,physicianResidentifier,tinNo)
					if(phyUniquenessMap.isValid &amp;&amp; practitionerSearchData.totalCount==0){
					var closeMatchMap = closeMatchCheck(physicianFirstName,physicianSurname);
					reportMap.status = closeMatchMap.status;
					reportMap.errMessage = closeMatchMap.errMessage;
					logger.info(&quot;[Practitioner Creation API] : Going to create Practitioner&quot;)
					orgData = findOrganisation()
					var locLeng = physicianLocationIdentifier.length;
                                if(((reportMap.status) &amp;&amp; (reportMap.status != &quot;FAILED&quot;)) &amp;&amp; (locLeng != address.length ||locLeng != city.length ||locLeng != state.length ||locLeng != postalCode.length) ){
                                    //status = &quot;FAILED&quot;;
                                    logger.info(&quot;LOCATION_ADDRESS_COUNT_MISMATCH&quot;);
                                }
                                if(((reportMap.status)  &amp;&amp; (reportMap.status != &quot;FAILED&quot;)) &amp;&amp; (locLeng ==0 || (physicianLocation.length&gt;0 &amp;&amp; locLeng != physicianLocation.length))){
                                    status = &quot;FAILED&quot;;
                                    errMessage = &quot;LOCATION_ID_IS_EMPTY OR LOCATION_ID_AND_LOCATION_NAME COUNT_MISMATCH&quot;;
                                }
                                else if(reportMap.status != &quot;FAILED&quot;){
                                    logger.info(&quot;Length is &quot; + physicianLocationIdentifier.length)
                                    for(index=0; (index &lt; locLeng &amp;&amp; reportMap.status != &quot;FAILED&quot;); index++){
                                        var locMap= {};
                                        var facilityAddressMap = {}
                                        facilityAddressMap.facilityAddress = address.length &gt; index ? address[index] : &quot;&quot;;
                                        facilityAddressMap.facilityCity = city.length &gt; index ? city[index] : &quot;&quot;;
                                        facilityAddressMap.facilityState = state.length &gt; index ? state[index] : &quot;&quot;;
                                        facilityAddressMap.facilityPostalCode = postalCode.length &gt; index ? postalCode[index] : &quot;&quot;;
                                        facilityAddressMap.facilityTINNumber = facitlityTinNo.length &gt; index ? facitlityTinNo[index]:&quot;&quot;;
										//facilityAddressMap.facilityCountry = country.length &gt;index ? country[index] : &quot;&quot;;

                                        locMap = getLocationData((physicianLocation.length &gt; index ? physicianLocation[index] : &quot;&quot;),physicianLocationIdentifier[index],orgData,facilityAddressMap,true)
                                        locations.add({&quot;id&quot;:locMap.locationId})
                                        reportMap.status = locMap.status ? locMap.status : &quot;&quot;;
                                        reportMap.errMessage = locMap.errMessage ? locMap.errMessage : &quot;&quot;;
                                    }
                                }else{
                                    logger.info(&quot;Can&apos;t find Location, status is FAILED : reportMap &quot;+ JSON.stringify(reportMap));
                                }
					if(reportMap.status != &quot;FAILED&quot; &amp;&amp; physCompleteName &amp;&amp; physicianEmail &amp;&amp; physicianPhone &amp;&amp; locations &amp;&amp; physicianResidentifier &amp;&amp; orgData){
					var pracSaveUrl = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).practitionerSaveUrl
					var practCreateReqMap = new java.util.HashMap()
					practCreateReqMap.put(&quot;physFirstName&quot;,physicianFirstName)
					practCreateReqMap.put(&quot;physLastName&quot;,physicianSurname)
					practCreateReqMap.put(&quot;physName&quot;, physCompleteName)
					practCreateReqMap.put(&quot;physEmail&quot;,physicianEmail)
					practCreateReqMap.put(&quot;physPhone&quot;,physicianPhone)
					practCreateReqMap.put(&quot;physGender&quot;,physicianGender)
					practCreateReqMap.put(&quot;location&quot;,locations)
					practCreateReqMap.put(&quot;countryCode&quot;,physCountryCode)
					practCreateReqMap.put(&quot;physIdentifier&quot;,physicianResidentifier)
					practCreateReqMap.put(&quot;orgId&quot;,orgData)
					practCreateReqMap.put(&quot;practitionerUrl&quot;,pracSaveUrl)
					practCreateReqMap.put(&quot;token&quot;,token)
					//practCreateReqMap.put(&quot;country&quot;,country)
					//practCreateReqMap.put(&quot;state&quot;,state)
					//practCreateReqMap.put(&quot;city&quot;,city)
					//practCreateReqMap.put(&quot;postalCode&quot;,postalCode)
					//practCreateReqMap.put(&quot;address&quot;,address)
					practCreateReqMap.put(&quot;tinNo&quot;,tinNo)
					pracRes=createPractitioner(practCreateReqMap)

					logger.info(&quot;Practitioner response &quot; + pracRes)
					if(Object.keys(pracRes).length &gt; 0){
					result.flag=true
					result.statusCode=200
					reportMap.status = &quot;SUCCESS&quot;
					logger.info(&quot;SUCCESSFULLY SAVED PRACTITIONER&quot;)
					}else{
					result.flag=false
					result.statusCode=500
					reportMap.errMessage = &quot;EXCEPTION_WHILE_CREATING_PRACTITIONER&quot;
					reportMap.status = &quot;FAILED&quot;
					logger.info(&quot;Error occurred while creating practitioner&quot;)
					}

					}
					else if(reportMap.status != &quot;FAILED&quot;){
					reportMap.status = &quot;FAILED&quot;
					reportMap.errMessage = &quot;FAILED_TO_CREATE_PHYISICIAN : &quot;
					reportMap.errMessage = physCompleteName ? reportMap.errMessage : &quot;,physCompleteName : &quot;+ physCompleteName
					reportMap.errMessage = physicianEmail ? reportMap.errMessage : &quot;,physicianEmail : &quot;+ physicianEmail
					reportMap.errMessage = physicianPhone ? reportMap.errMessage : &quot;,physicianPhone : &quot;+physicianPhone
					reportMap.errMessage = locations ? reportMap.errMessage : &quot;,locations : &quot;+locations
					reportMap.errMessage = physicianResidentifier ? reportMap.errMessage : &quot;,physicianResidentifier : &quot;+physicianResidentifier
					reportMap.errMessage = orgData ? reportMap.errMessage : &quot;,orgData : &quot;+orgData

					}

					}
					else if (phyUniquenessMap.isValid &amp;&amp; practitionerSearchData.totalCount==1){
					logger.info(&quot;[Practitioner Creation API] :  Practitioner Update Comes&quot;)

					var physId= phyUniquenessMap._id
					orgData = findOrganisation()
					locations = new Packages.java.util.ArrayList()
                                var locLeng = physicianLocationIdentifier.length;

                                logger.info(&quot;TOTAL LOCATION COUNT IS : &quot;+locLeng+&quot;, existing locations are : &quot;+phyUniquenessMap.locationIdList);

                                if((reportMap.status != &quot;FAILED&quot;) &amp;&amp; (locLeng != address.length ||locLeng != city.length ||locLeng != state.length ||locLeng != postalCode.length) ){
                                    //status = &quot;FAILED&quot;;
                                    logger.info(&quot;LOCATION_ADDRESS_COUNT_MISMATCH&quot;);
                                }
                                if((reportMap.status != &quot;FAILED&quot;) &amp;&amp; (locLeng ==0 || (physicianLocation.length&gt;0 &amp;&amp; locLeng != physicianLocation.length))){
                                    status = &quot;FAILED&quot;;
                                    errMessage = &quot;LOCATION_ID_IS_EMPTY OR LOCATION_ID_AND_LOCATION_NAME COUNT_MISMATCH&quot;;
                                }
                                else if(reportMap.status != &quot;FAILED&quot;){
                                    logger.info(&quot;Length is &quot; + physicianLocationIdentifier.length)
                                    for(index=0; (index &lt; physicianLocation.length &amp;&amp; reportMap.status != &quot;FAILED&quot;); index++){
                                        var locMap= {};
                                        var facilityAddressMap = {}
                                        facilityAddressMap.facilityAddress = address.length &gt; index ? address[index] : &quot;&quot;;
                                        facilityAddressMap.facilityCity = city.length &gt; index ? city[index] : &quot;&quot;;
                                        facilityAddressMap.facilityState = state.length &gt; index ? state[index] : &quot;&quot;;
                                        facilityAddressMap.facilityPostalCode = postalCode.length &gt; index ? postalCode[index] : &quot;&quot;;
                                        facilityAddressMap.facilityTINNumber = facitlityTinNo.length &gt; index ? facitlityTinNo[index]:&quot;&quot;;
										//facilityAddressMap.facilityCountry = country.length &gt;index ? country[index] : &quot;&quot;;

                                        locMap = getLocationData((physicianLocation.length &gt; index ? physicianLocation[index] : &quot;&quot;),physicianLocationIdentifier[index],orgData,facilityAddressMap,true)
                                        if(phyUniquenessMap.locationIdList &amp;&amp; reportMap.locationId &amp;&amp; phyUniquenessMap.locationIdList.indexOf(reportMap.locationId) &lt; 0){
                                            reportMap.errMessage = &quot;NEW_LOCATION_ID_NOT_PERMITTED : MONGO_ID : &quot;+locationDataMap.id
                                            reportMap.status = &quot;FAILED&quot;;
                                            break;
                                        }else{
                                            locations.add({&quot;id&quot;:locMap.locationId})
                                        }
                                        reportMap.status = locMap.status ? locMap.status : &quot;&quot;;
                                        reportMap.errMessage = locMap.errMessage ? locMap.errMessage : &quot;&quot;;
                                    }
                                }else{
                                    logger.info(&quot;Can&apos;t find Location, status is FAILED : reportMap &quot;+ JSON.stringify(reportMap));
                                }

					var pracUpdateUrl= globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).practitionerUpdateUrl + physId
					if( reportMap.status != &quot;FAILED&quot; &amp;&amp; physId &amp;&amp; physCompleteName &amp;&amp; physicianEmail &amp;&amp; physicianPhone  &amp;&amp; locations &amp;&amp; physicianResidentifier &amp;&amp; orgData){
					var practCreateReqMap = new java.util.HashMap()
					practCreateReqMap.put(&quot;physFirstName&quot;,physicianFirstName)
					practCreateReqMap.put(&quot;physLastName&quot;,physicianSurname)
					practCreateReqMap.put(&quot;physId&quot;,physId)
					practCreateReqMap.put(&quot;physName&quot;, physCompleteName)
					practCreateReqMap.put(&quot;physEmail&quot;,physicianEmail)
					practCreateReqMap.put(&quot;physPhone&quot;,physicianPhone)
					practCreateReqMap.put(&quot;physGender&quot;,physicianGender)
					practCreateReqMap.put(&quot;location&quot;,locations)
					practCreateReqMap.put(&quot;physIdentifier&quot;,physicianResidentifier)
					practCreateReqMap.put(&quot;orgId&quot;,orgData)
					practCreateReqMap.put(&quot;practitionerUrl&quot;,pracUpdateUrl)
					practCreateReqMap.put(&quot;token&quot;,token)
					practCreateReqMap.put(&quot;countryCode&quot;,physCountryCode)
					//practCreateReqMap.put(&quot;country&quot;,country)
					//practCreateReqMap.put(&quot;state&quot;,state)
					//practCreateReqMap.put(&quot;city&quot;,city)
					//practCreateReqMap.put(&quot;postalCode&quot;,postalCode)
					practCreateReqMap.put(&quot;tinNo&quot;,tinNo)
					//practCreateReqMap.put(&quot;address&quot;,address)
					pracRes=createPractitioner(practCreateReqMap)

					if(Object.keys(pracRes).length &gt; 0){
					result.flag=true
					result.statusCode=200
					reportMap.status = &quot;SUCCESS&quot;
					}else{
					result.flag=false
					result.statusCode=500
					reportMap.errMessage = &quot;EXCEPTION_WHILE_UPDATING_PRACTITIONER&quot;
					reportMap.status = &quot;FAILED&quot;
					logger.info(&quot;Error occurred while updating practitioner&quot;)
					}
					}
					else if(reportMap.status != &quot;FAILED&quot;){
					//logger.info(physId +&quot; : &quot;+&quot; : &quot;+ physCompleteName +&quot; : &quot;+&quot; : &quot;+ physicianEmail +&quot; : &quot;+&quot; : &quot;+ physicianPhone  +&quot; : &quot;+&quot; : &quot;+ locations +&quot; : &quot;+&quot; : &quot;+ physicianResidentifier +&quot; : &quot;+&quot; : &quot;+ orgData)
					reportMap.status = &quot;FAILED&quot;
					reportMap.errMessage = &quot;FAILED_TO_UPDATE_PHYISICIAN : &quot;
					reportMap.errMessage = physId ? reportMap.errMessage : &quot;,physId : &quot;+ physId
					reportMap.errMessage = physCompleteName ? reportMap.errMessage : &quot;,physCompleteName : &quot;+ physCompleteName
					reportMap.errMessage = physicianEmail ? reportMap.errMessage : &quot;,physicianEmail : &quot;+ physicianEmail
					reportMap.errMessage = physicianPhone ? reportMap.errMessage : &quot;,physicianPhone : &quot;+physicianPhone
					reportMap.errMessage = locations ? reportMap.errMessage : &quot;,locations : &quot;+locations
					reportMap.errMessage = physicianResidentifier ? reportMap.errMessage : &quot;,physicianResidentifier : &quot;+physicianResidentifier
					reportMap.errMessage = orgData ? reportMap.errMessage : &quot;,orgData : &quot;+orgData
					}

					}
					else{
					result.flag=false
					result.statusCode=500
					reportMap.errMessage = phyUniquenessMap.errorMsg
					reportMap.status = &quot;FAILED&quot;

					}
					}else{
					logger.error(&quot;[Practitioner Creation API] : Error Occured while Getting Token&quot;)
					reportMap.errMessage = &quot;EXCEPTION_WHILE_GETTING_TOKEN&quot;
					reportMap.status = &quot;FAILED&quot;
					//report = report + (SerializerFactory.getSerializer(&apos;DELIMITED&apos;).fromXML(seg)).replace(&apos;\n&apos;,&apos;&apos;) +&quot;, Error Occured while geeting token from  login API \n&quot;;
					}

					}else{
					reportMap.status = &quot;FAILED&quot;
					reportMap.errMessage = validateResponse.errorMsg;

					}
					logger.info(&quot;DATA_PROCESSED_STATUS : &quot;+reportMap.status +&quot;, MESSAGE : &quot;+reportMap.errMessage +&quot; WRG_STATUS : &quot;+reportMap.wrgstatus +&quot;, WRG_MESSAGE : &quot;+reportMap.wrgMessage)
					if(reportMap.wrgMessage != &quot;&quot;){
					reportMap.errMessage = reportMap.errMessage + &quot; | &quot;+ reportMap.wrgMessage
					if(reportMap.status = &quot;SUCCESS&quot;){
					reportMap.status = &quot;WARNING&quot;
					}
					}
					if(reportMap.errMessage == undefined){
					reportMap.errMessage = &quot;&quot;;
					}
					report = report + (SerializerFactory.getSerializer(&apos;DELIMITED&apos;).fromXML(seg)).replace(&apos;\n&apos;,&apos;&apos;) +&quot;,&quot;+reportMap.status+&quot;,&quot;+reportMap.errMessage+&quot;\n&quot;;
					}

					count ++
					}
					globalMap.put(&apos;pracReport&apos;,report)
					} catch (e) {
					logger.info(&quot;DATA_PROCESSED_STATUS : &quot;+reportMap.status +&quot;, MESSAGE : &quot;+reportMap.errMessage)
					logger.error(&apos;Exception Occured while creating practitioner via API&apos;+e + e.stack)
					}


					return result
					}



					function findOrganisation(){
					var orgId = &quot;&quot;
					try {
					var orgFindMap = new java.util.HashMap()
					orgFindMap.put(&quot;keyName&quot;,&apos;name.value&apos;)
					orgFindMap.put(&quot;keyValue&quot;,configurationMap.get(&apos;organisation&apos;))

					var organizationData=findDataFromDB(&apos;ORGANIZATION&apos;,orgFindMap)
					logger.info(&quot;=============Organization Data is &quot; + JSON.stringify(organizationData))
					if(organizationData.totalCount&gt;0){
					logger.info(&quot;[Practitioner Creation API] : Going to find Organization Id&quot;)
					orgId = getId(organizationData)
					logger.info(&quot;[Practitioner Creation API] : Organization Id is &quot;+ orgId)
					}
					} catch (e) {
					logger.error(&quot;Exception Occured while finding Organisation&quot;+e + e.stack)
					}

					return orgId;
					}

					/*function getLocation(physicianLocation,organizationId,physicianLocationIdentifier,phyLocIdLists){
					logger.info(&quot;[Practitioner Creation API] : Inside get Location Function with location Data &quot; + physicianLocation  + &quot; Organisation Data &quot; + organizationId + &quot;Location Identifier &quot; +physicianLocationIdentifier)
					logger.info(&quot;EXISTING LOCATIONS IN PHYSICIAN  : &quot;+phyLocIdLists)
					var returnMap = {}
					var locationList = new Packages.java.util.ArrayList()
					try {
					for(location in physicianLocation,physicianLocationIdentifier){
					var locationDataMap = {}
					logger.info(&quot;[Practitioner Creation API] : Going to Search Data for location&quot; + physicianLocationIdentifier[location].trim() )
					var locationFindMap = new java.util.HashMap()
					locationFindMap.put(&quot;keyName&quot;,&apos;identifier.value.value&apos;)
					locationFindMap.put(&quot;keyValue&quot;,physicianLocationIdentifier[location].trim())

					var locationData= findDataFromDB(&apos;LOCATION&apos;,locationFindMap)
					if(locationData.totalCount &gt; 0){
					logger.info(&quot;[Practitioner Creation API] : Going to find Location Id&quot;)
					var locationId= getId(locationData,&quot;LOCATION&quot;)
					logger.info(&quot;Location is &quot;+ locationId)
					if(typeof(locationId) == &quot;string&quot; &amp;&amp; locationId.match(/NOT_VALID/)){
					returnMap.errMessage = &quot;LOCATION_IS_DISABLED_&quot;+locationId
					returnMap.status = false
					break;
					}
					else{
					locationDataMap.id=locationId
					}

					}else {
					locationFindMap.put(&apos;keyName&apos;, &apos;name.value&apos;)
					locationFindMap.put(&apos;keyValue&apos;, physicianLocation[location].trim())
					locationData = findDataFromDB(&apos;LOCATION&apos;, locationFindMap)
					if(locationData.totalCount &gt; 1){
					//throw(&quot;A LOCATION WITH SAME LOCATION NAME EXISTS WITH DIFFERENT IDENTIFIER&quot;)
					returnMap.errMessage = &quot;A LOCATION WITH SAME LOCATION NAME EXISTS WITH DIFFERENT IDENTIFIER&quot;
					returnMap.status = &quot;FAILED&quot;
					}else{
					logger.info(&quot;[Practitioner Creation API] :  Going to Create Location with name &quot; + physicianLocation[location])
					var locationCreateMap= new java.util.HashMap()
					locationCreateMap.put(&quot;locationName&quot;, physicianLocation[location].trim())
					locationCreateMap.put(&quot;locIdentifier&quot;, physicianLocationIdentifier[location].trim())
					locationCreateMap.put(&quot;orgId&quot;, organizationId)
					var locationRes = createLocation(locationCreateMap)
					if(Object.keys(locationRes).length &gt; 0){
					locationDataMap.id=locationRes.id
					}
					}
					}
					if(phyLocIdLists &amp;&amp; locationDataMap.id &amp;&amp; phyLocIdLists.indexOf(locationDataMap.id) &lt; 0){
					returnMap.errMessage = &quot;NEW_LOCATION_ID_NOT_PERMITTED : MONGO_ID : &quot;+locationDataMap.id
					returnMap.status = &quot;FAILED&quot;;
					break;
					}

					locationList.add(locationDataMap)
					}
					} catch (e) {
					logger.error(&quot;Exception Occured while Getting location/creating location&quot;+e + e.stack)
					returnMap.errMessage = &quot;EXCEPTION_WHILE_GETTING_LOCATION_IDS&quot;
					returnMap.status = &quot;FAILED&quot;
					}

					returnMap.locationList = locationList
					return returnMap
					}*/

					function getId(jsonData,collectionName) {
					var dataId;
					try {
					logger.info(&quot;[Practitioner Creation API] : Going to search id &quot;)
					var cursor =jsonData.message
					var lookUpEntry=JSON.parse(cursor.next())
					if(collectionName == &quot;LOCATION&quot;){
					dataId = (lookUpEntry.status &amp;&amp; lookUpEntry.status.value == &quot;active&quot;) ? lookUpEntry._id : &quot;NOT_VALID : &quot;+ lookUpEntry._id
					}
					else{
					dataId = lookUpEntry._id;
					}
					} catch (e) {
					logger.error(&apos;Exception Occured while getting id&apos;+e + e.stack)
					}
					return dataId
					}

					function phyUniquenessCheck(jsonData,physicianEmail,physicianResidentifier,tinNo){
					var returnMap = {}
					returnMap.isValid = false
					returnMap.errorMsg = &quot;&quot;;

					if(!jsonData || jsonData.totalCount == undefined){
					logger.info(&quot;ERROR_WHILE_FETCHING_PHYSICIAN&quot;)
					returnMap.errorMsg = &quot;ERROR_WHILE_FETCHING_PHYSICIAN&quot;
					returnMap.isValid = false
					}
					else if(jsonData.totalCount == 0){
					logger.info(&quot;NO_PHYSICIAN_FOUND&quot;)
					returnMap.isValid = true
					}
					else if(jsonData.totalCount &gt; 1){
					logger.info(&quot;MULTIPLE_PHYSICIAN_FOUND&quot;)
					returnMap.errorMsg = &quot;MULTIPLE_PHYSICIAN_FOUND_WITH_SAME_EMAIL_OR_NPI&quot;
					returnMap.isValid = false
					}
					else{
					logger.info(&quot;ONE_PHYSICIAN_FOUND&quot;)
					try {
					var cursor =jsonData.message
					var lookUpEntry=JSON.parse(cursor.next())
					logger.info(&quot;Working for Physician Id : &quot;+lookUpEntry._id);
					var tinNumFound = false;
					var sameTinFound = false;
					var npiFound = false

					for(index in lookUpEntry.identifier){
					if(lookUpEntry.identifier[index].value.value == physicianResidentifier ){
					logger.info(&quot;PHYSICIAN_FOUND_WITH_NPI : &quot;+physicianResidentifier)
					npiFound = true
					returnMap.isValid = true
					returnMap.phyNPI = lookUpEntry.identifier[index].value.value
					returnMap._id = lookUpEntry._id
					returnMap.locationIdList = lookUpEntry.location ? lookUpEntry.location : []
					}
					if(lookUpEntry.identifier[index].type &amp;&amp; lookUpEntry.identifier[index].type.coding &amp;&amp; lookUpEntry.identifier[index].type.coding[0].code.value == &quot;TIN&quot;){
					tinNumFound = true;
					if(lookUpEntry.identifier[index].value.value == tinNo){
					logger.info(&quot;TIN_NUMBER_MATCHED : &quot;+lookUpEntry.identifier[index].value.value )
					sameTinFound = true;
					}
					}
					}
					if(tinNumFound){
					if(!sameTinFound){
					logger.info(&quot;DIFFERENT TIN FOUND : &quot;)
					returnMap.isValid = false;
					returnMap.errorMsg = &quot;DIFFERENT_TIN_FOUND_IN_PRACTITIONER : &quot;+ tinNo
					returnMap.status = &quot;FAILED&quot;
					}
					}
					if(!npiFound){
					returnMap.isValid = false;
					returnMap.errorMsg = &quot;OTHER_PRACTITIONER_FOUND_WITH_SAME_EMAIL : &quot;+ lookUpEntry._id
					returnMap.status = &quot;FAILED&quot;
					}
					} catch (e) {
					logger.error(&apos;Exception while parsing practitioner response&apos;+e + e.stack)
					returnMap.errorMsg = &quot;EXCEPTION_WHILE_PARSING_RESPONSE&quot;
					returnMap.isValid = false
					}

					}
					logger.info(&quot;phyUniquenessCheck : &quot; + JSON.stringify(returnMap) )
					return returnMap

					}

					function filterCSVData(requestMap){

					var filter = {&quot;flag&quot; : true , &quot;errorMsg&quot; :&quot;&quot;}
					var error = &quot;&quot;
					try {
					logger.info(requestMap.get(&apos;physicianLocation&apos;)+ &quot;Value is &quot; + requestMap.get(&apos;physicianLocation&apos;).length + &quot;locationIdentifier is &quot;+requestMap.get(&apos;physicianLocationIdentifier&apos;)+&quot;===========&quot; +requestMap.get(&apos;physicianLocationIdentifier&apos;).length)
					if(requestMap.get(&apos;physicianLocation&apos;).length != requestMap.get(&apos;physicianLocationIdentifier&apos;).length){
					filter.flag=false
					filter.errorMsg=&quot;LOC_IDENTIFIER_AND_LOC_NAME_COUNT_MISMATCH&quot;
					return filter
					}else{
					/*if((!requestMap.get(&apos;physicianFirstName&apos;) == null || (requestMap.get(&apos;physicianFirstName&apos;) &amp;&amp;  !(requestMap.get(&apos;physicianFirstName&apos;).match(/[a-zA-Z]/)))) ||  (!requestMap.get(&apos;physicianSurname&apos;) == null || (requestMap.get(&apos;physicianSurname&apos;) &amp;&amp;  !(requestMap.get(&apos;physicianSurname&apos;).match(/[a-zA-Z]/)))) ){
					error=&quot;Either  first Name or LastName is Missing or nvalid&quot;
					}

					if(!requestMap.get(&apos;physicianSurname&apos;) == null || (requestMap.get(&apos;physicianSurname&apos;) &amp;&amp;  !(requestMap.get(&apos;physicianSurname&apos;).match(/[a-zA-Z]/)))){
					error=&quot;Either surname  Name is Missing or nvalid&quot;
					}*/

					if(!requestMap.get(&apos;physicianEmail&apos;) || (requestMap.get(&apos;physicianEmail&apos;) &amp;&amp; !(	requestMap.get(&apos;physicianEmail&apos;).match(/^[\w\.\-]+([\w\.\-]+)*\@[\w\.\-]+\.[\w]{2,}$/)))){
					//	filter.flag=false
					error= requestMap.get(&apos;physicianEmail&apos;) ? &quot;PHYSICIAN_EMAIL_IS_INVALID&quot; : &quot;PHYSICIAN_EMAIL_IS_EMPTY&quot;;
					}


					if(!requestMap.get(&apos;physicianPhone&apos;) ||  (requestMap.get(&apos;physicianPhone&apos;)  &amp;&amp;  !(requestMap.get(&apos;physicianPhone&apos;).match(/^[1-9][0-9]{9}$/)))){
					error= requestMap.get(&apos;physicianPhone&apos;) ? &quot;PHYSICIAN_PHONE_IS_INVALID : CHAR_SET_OUT_OF [1-9][0-9]{9}&quot; : &quot;PHYSICIAN_PHONE_IS_EMPTY&quot;;
					}

					for each (loc in requestMap.get(&apos;physicianLocation&apos;)){
					if(!loc || (loc &amp;&amp; !(loc.match(/^[\w\/&amp;\.,:_\- \\]+$/)))){

					error=&quot;LOCATION_NAME_IS_INVALID : CHAR_SET_OUT_OF [a-zA-Z0-9&amp;.,:_- \\]&quot;
					}
					}

					if(! requestMap.get(&apos;physicianResidentifier&apos;)|| requestMap.get(&apos;physicianResidentifier&apos;)==&quot;&quot;){//( requestMap.get(&apos;physicianResidentifier&apos;) &amp;&amp; !( requestMap.get(&apos;physicianResidentifier&apos;).match(/^[\w\.\-]+([\w\.\-]+)*\@[\w\.\-]+\.[\w]{2,}$/)))){
					error=requestMap.get(&apos;physicianResidentifier&apos;) ? &quot;PHYSICIAN_IDENTIFIER_IS_INVALID&quot; : &quot;PHYSICIAN_IDENTIFIER_IS_EMPTY&quot;;
					}
					}


					if(error || error!=&quot;&quot;){
					filter.flag = false
					filter.errorMsg =  error

					}

					} catch (e) {
					logger.error(&apos;Exception Occured while filtering CSv Data&apos; + e + e.stack);
					filter.flag = false
					filter.errorMsg = &quot;ERROR_IN_PARSING_MESSAGE&quot;
					}

					return filter;
					}

					function closeMatchCheck(firstName, lastName) {

					var returnMap = {&quot;errMessage&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;}
					var pracFindMap = {}

					//var firstNameLen = firstName.length()
					//var lastNameLen = lastName.length()
					//var regexString = &quot;&quot;
					logger.info(firstName.length()+&quot;------&quot;+lastName.length())
					if(firstName.length()&gt;=4){
					firstName = firstName.substring(0,4).toString()
					}
					if(lastName.length() &gt;= 4){
					lastName = lastName.substring(lastName.length() -4,lastName.length()).toString()
					}

					var regexString = &quot;^&quot;+firstName.toLowerCase()+&quot;.*&quot;+lastName.toLowerCase()+&quot;$&quot;

					logger.info(&quot;regexString :&quot;+regexString+&quot; Type:&quot;+typeof(regexString))
					pracFindMap[&quot;lowerCaseName.text.value&quot;] = {&quot;$regex&quot;:regexString.toString()}

					//pracFindMap[&quot;lowerCaseName.text.value&quot;] = {&quot;$regex&quot;:firstName.toLowerCase()}
					//pracFindMap[&quot;lowerCaseName.text.value&quot;] = {&quot;$regex&quot;:lastName.toLowerCase()}
					try{
					var  pracResource = findDataFromDB(&apos;PRACTITIONER&apos;,pracFindMap,&quot;OR&quot;)
					if(pracResource.totalCount  &amp;&amp; pracResource.totalCount &gt; 0){
					logger.info(&quot;FOUND_MULTIPLE_PHYSICIAN_WITH_SIMILAR_NAME&quot;+pracResource)
					returnMap = {&quot;errMessage&quot;:&quot;FOUND_MULTIPLE_PHYSICIAN_WITH_SIMILAR_NAME : &quot;+getId(pracResource),&quot;status&quot;:&quot;FAILED&quot;}
					}
					}
					catch(ex){
					logger.error(&quot;EXCEPTION_WHILE_FETCHING_CLOSE_MATCH_OF_PHYSICIAN&quot;+ex + ex.stack)
					returnMap = {&quot;errMessage&quot;:&quot;EXCEPTION_WHILE_FETCHING_CLOSE_MATCH_OF_PHYSICIAN&quot;,&quot;status&quot;:&quot;FAILED&quot;}
					}

					return returnMap
					}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>e6692be3-a828-4cb0-84a3-7dfd1004cef0</id>
            <name>createUserViaCSV</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522847731</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
 Modify the description here. Modify the function name and parameters as needed. One function per
 template is recommended; create a new code template for each new function.

 @param {Any} row -
 @param {Any} status -
 @param {Any} errMessage -
 @return {Any}
 */
function createUserViaCSV(row, status, errMessage ){
    logger.info(&quot;createUserViaCSV : Working for CSV Row : &quot;+JSON.stringify(row));
    var userValidateMap = new java.util.HashMap()
    userValidateMap.put(&apos;firstName&apos;, row.firstName)
    userValidateMap.put(&apos;lastName&apos;, row.lastName)
    userValidateMap.put(&apos;email&apos;, row.email)
    userValidateMap.put(&apos;phone&apos;, row.phone)
    userValidateMap.put(&apos;userGroupName&apos;, row.userGroupName)
    userValidateMap.put(&apos;gender&apos;, row.gender)
    userValidateMap.put(&apos;locationName&apos;, row.locationName)
    userValidateMap.put(&apos;locationIdentifier&apos;, row.locationIdentifier)
    userValidateMap.put(&apos;resourceidentifier&apos;, row.resourceidentifier)
	userValidateMap.put(&apos;locationNameList&apos;, row.locationNameList)
	userValidateMap.put(&apos;locationIdentifierList&apos;, row.locationIdentifierList)
    userValidateMap.put(&apos;userType&apos;, row.userType)
    logger.info(&quot;createUserViaCSV UserValidationMap : &quot;+userValidateMap)

    var validateRes = validateData_User(userValidateMap)
    if (validateRes.flag == true) {
        // var token = getAuthToken()
        var token = configurationMap.get(&apos;xAuthToken&apos;)
        var userCreation_result = {}
        var userGroupCreateMap = new java.util.HashMap()

        if (token) {
            var userGroupId = null
            var userGroupReqParams = {}//new java.util.HashMap()
            userGroupReqParams[&apos;name&apos;] = row.userGroupName;

            var userGroupCreationMap = JSON.parse(configurationMap.get(&apos;userGroupCreationMap&apos;))
            logger.info(&quot;userGroupReqParams:&quot; + userGroupReqParams)
            var userGroupSerach_res = findDataFromDB(&apos;USERGROUP&apos;, userGroupReqParams)

            if (userGroupSerach_res.totalCount == 0) {
                userGroupCreateMap.put(&quot;userGroupName&quot;, row.userGroupName)
				userGroupCreateMap.put(&quot;userGroupType&quot;, row.userGroupType)
				if(row.singleUGMultiLoc){
					userGroupCreateMap.put(&quot;locationNameList&quot;, row.locationNameList)
					userGroupCreateMap.put(&quot;locationIdentifierList&quot;, row.locationIdentifierList)
					userGroupCreateMap.put(&quot;facilityAddressList&quot;, row.facilityAddressList)
					userGroupCreateMap.put(&quot;facilityCityList&quot;, row.facilityCityList)
					userGroupCreateMap.put(&quot;facilityStateList&quot;, row.facilityStateList)
					userGroupCreateMap.put(&quot;facilityPostalCodeList&quot;, row.facilityPostalCodeList)
					userGroupCreateMap.put(&quot;facilityTINNumberList&quot;, row.facilityTINNumberList)
				}
				else{
					userGroupCreateMap.put(&quot;locationName&quot;, row.locationName)
					userGroupCreateMap.put(&quot;locationIdentifier&quot;, row.locationIdentifier)
					userGroupCreateMap.put(&quot;facilityAddress&quot;, row.facilityAddress)
					userGroupCreateMap.put(&quot;facilityCity&quot;, row.facilityCity)
					userGroupCreateMap.put(&quot;facilityState&quot;, row.facilityState)
					userGroupCreateMap.put(&quot;facilityPostalCode&quot;, row.facilityPostalCode)
					userGroupCreateMap.put(&quot;facilityTINNumber&quot;, row.facilityTINNumber)
				}

                logger.info(&quot;createUserViaCSV : userGroupCreateMap : &quot;+userGroupCreateMap)

                var result = createUserGroupvViaCSV_User(userGroupCreateMap, token, null)
                var res = JSON.parse(result);

                if (status != &quot;FAILED&quot; &amp;&amp; res.httpStatusCode == 200) {
                    logger.info(&quot;User Group Creation Successful&quot;)
                    var userGroupSerach_res = findDataFromDB(&apos;USERGROUP&apos;, userGroupReqParams)
                    var cursor = userGroupSerach_res.message
                    var lookUpEntry = JSON.parse(cursor.next())
                    userGroupId = lookUpEntry._id
                    logger.info(&quot;Got usergroup as :&quot;+JSON.stringify(lookUpEntry))
                    userGroupCreateMap.put(&quot;userGroupName&quot;, row.userGroupName)
                    userGroupCreateMap.put(&quot;userGroupType&quot;, row.userGroupType)
                    logger.info(&quot;Test3 : &quot;+userGroupCreateMap)
                    logger.info(&quot;Test3 : &quot;+row.facilityAddress)

                    if (row.userGroupType in userGroupCreationMap) {
                        userGroupCreateMap.put(&quot;userGroupId&quot;, userGroupId)
                        var res = createUserGroupvViaCSV_User(userGroupCreateMap, token,null)
                    }
                } else if (status != &quot;FAILED&quot;) {
                    status = &quot;FAILED&quot;
                    errMessage = &quot;FAILED_TO_CREATE_USERGROUP : &quot; + JSON.stringify(res)
                }

            } else {
                logger.info(&quot;User Group already exists.Going to find user group Id&quot;)
                var cursor = userGroupSerach_res.message
                var lookUpEntry = JSON.parse(cursor.next())
                userGroupId = lookUpEntry._id
                userGroupCreateMap.put(&quot;userGroupName&quot;, row.userGroupName)
				userGroupCreateMap.put(&quot;userGroupType&quot;, row.userGroupType)
				if(row.singleUGMultiLoc){
					userGroupCreateMap.put(&quot;locationNameList&quot;, row.locationNameList)
					userGroupCreateMap.put(&quot;locationIdentifierList&quot;, row.locationIdentifierList)
					userGroupCreateMap.put(&quot;facilityAddressList&quot;, row.facilityAddressList)
					userGroupCreateMap.put(&quot;facilityCityList&quot;, row.facilityCityList)
					userGroupCreateMap.put(&quot;facilityStateList&quot;, row.facilityStateList)
					userGroupCreateMap.put(&quot;facilityPostalCodeList&quot;, row.facilityPostalCodeList)
					userGroupCreateMap.put(&quot;facilityTINNumberList&quot;, row.facilityTINNumberList)
				}
				else{
					userGroupCreateMap.put(&quot;locationName&quot;, row.locationName)
					userGroupCreateMap.put(&quot;locationIdentifier&quot;, row.locationIdentifier)
					userGroupCreateMap.put(&quot;facilityAddress&quot;, row.facilityAddress)
					userGroupCreateMap.put(&quot;facilityCity&quot;, row.facilityCity)
					userGroupCreateMap.put(&quot;facilityState&quot;, row.facilityState)
					userGroupCreateMap.put(&quot;facilityPostalCode&quot;, row.facilityPostalCode)
					userGroupCreateMap.put(&quot;facilityTINNumber&quot;, row.facilityTINNumber)
				}
                logger.info(&quot;Test3 : &quot;+userGroupCreateMap)
                logger.info(&quot;Test3 : &quot;+row.facilityAddress)

                if (row.userGroupType in userGroupCreationMap) {
                    userGroupCreateMap.put(&quot;userGroupId&quot;, userGroupId)
                    var res = createUserGroupvViaCSV_User(userGroupCreateMap, token, lookUpEntry)
                    logger.info(&quot;User Group updated sucessFully&quot; + JSON.stringify(res))
                }

                logger.info(&quot;Got User Group ID:   &quot; + userGroupId)

            }

            if (userGroupId) {
                var userGroupIdList = new java.util.ArrayList()
                userGroupIdList.add(userGroupId)
                logger.info(&quot;Going to search whether the user exists or not with email &quot; + row.email)
                var userReqParams = {}
                userReqParams[&apos;username&apos;] = row.username
                var userSearch_res = findDataFromDB(&apos;USER&apos;, userReqParams)
                logger.info(&quot;User Search response &quot; + userSearch_res)

                var createUserRequestMap = new java.util.HashMap()
                createUserRequestMap.put(&quot;firstName&quot;, row.firstName)
                createUserRequestMap.put(&quot;lastName&quot;, row.lastName)
                createUserRequestMap.put(&quot;email&quot;, row.email)
                createUserRequestMap.put(&quot;phone&quot;, row.phone)
                createUserRequestMap.put(&quot;dob&quot;, row.dob)
                createUserRequestMap.put(&quot;gender&quot;, row.gender)
                createUserRequestMap.put(&quot;userType&quot;, row.userType)
                createUserRequestMap.put(&quot;token&quot;, token)
                createUserRequestMap.put(&apos;countryCode&apos;, row.countryCode)
                createUserRequestMap.put(&apos;prefix&apos;, row.prefix)
                createUserRequestMap.put(&apos;countryCodeFax&apos;, row.countryCodeFax)
                createUserRequestMap.put(&apos;faxNo&apos;, row.faxNo)
                createUserRequestMap.put(&apos;username&apos;, row.username)

                if (userSearch_res.totalCount == 0) {
                    var userSaveUrl = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userCreate_url
                    createUserRequestMap.put(&quot;userGroups&quot;, userGroupIdList)
                    createUserRequestMap.put(&quot;userCreateUrl&quot;, userSaveUrl)
                    createUserRequestMap.put(&apos;userId&apos;, null)

                    	 var closeMatchCheckFlag =  configurationMap.get(&apos;isCloseMatchCheckEnabledUser&apos;)
                           logger.info(&quot;CloseMatch Check Flag &quot; + closeMatchCheckFlag)
                            if(closeMatchCheckFlag == &quot;true&quot;){ 	 	
                            	 	var closeMatchMap = closeMatchCheck_User(row.firstName, row.lastName)
                                   errMessage = closeMatchMap.errMessage
                                   status = closeMatchMap.status
                            	 }
                    

                    if (status != &quot;FAILED&quot; &amp;&amp; (row.firstName != &quot;&quot; || row.lastName != &quot;&quot; || row.email != &quot;&quot;)) {
                        userCreation_result = createAndUpdateUser(createUserRequestMap)
                        if (userCreation_result.httpStatusCode == 200) {
                            logger.info(&quot;[User Creation Successful&quot;)
                            status = &quot;SUCCESS&quot;
                        } else {
                            status = &quot;FAILED&quot;
                            errMessage = &quot;ERROR_OCCURRED_WHILE_USER_CREATION : &quot; + userCreation_result ? JSON.stringify(userCreation_result) : userCreation_result
                        }
                    } else if (status != &quot;FAILED&quot;) {
                        status = &quot;FAILED&quot;
                        errMessage = &quot;ERROR_MANDATORY_FIELDS_ARE_EMPTY : &quot;
                        errMessage = row.firstName ? errMessage + &quot;,firstName : &quot; + row.firstName : errMessage
                        errMessage = row.lastName ? errMessage + &quot;,lastName : &quot; + row.lastName : errMessage
                        errMessage = row.email ? errMessage + &quot;,email : &quot; + row.email : errMessage
                    }

                } else {
                    var cursor = userSearch_res.message
                    var lookUpEntry = JSON.parse(cursor.next())

                    if (lookUpEntry.userGroups.indexOf(userGroupId) &gt;= 0) {
                        logger.info(&quot;[User Creation] :  User Group Id already exist in user Not going to update&quot;)
                        status = &quot;FAILED&quot;
                        errMessage = &quot;USER_GROUP_ALREADY_EXISTS_IN_USER : &quot; + lookUpEntry._id
                    } else {
                        logger.info(&quot;Going to update usergroup : &quot;+userGroupIdList+&quot;, in user : &quot;+lookUpEntry._id)

                        var userUpdateUrl = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userUpdateUrl
                        for (id in lookUpEntry.userGroups) {
                            userGroupIdList.add(lookUpEntry.userGroups[id])
                        }

                        createUserRequestMap.put(&apos;username&apos;, lookUpEntry.username)
                        createUserRequestMap.put(&apos;userGroups&apos;, userGroupIdList)
                        createUserRequestMap.put(&apos;userCreateUrl&apos;, userUpdateUrl)
                        createUserRequestMap.put(&apos;userId&apos;, lookUpEntry._id)
                        createUserRequestMap.put(&apos;id&apos;, lookUpEntry._id)
                        userCreation_result = createAndUpdateUser(createUserRequestMap)
                        if(userCreation_result &amp;&amp; (userCreation_result.httpStatusCode == 200 || userCreation_result.httpStatusCode == &quot;200&quot;) )
                        {
                            status = &quot;SUCCESS&quot;
                        }
                        else{
                            status = &quot;FAILED&quot;;
                            errMessage = userCreation_result ? JSON.stringify(userCreation_result) : &quot;UNABLE_TO_CREATE_USER : &quot;+userCreation_result
                        }
                        //errMessage = &quot;ADDING_NEW_USER_GROUP_IS_NOT_PERMITTED : If you want to add another User Group Please contact System Administrator&quot;
                    }
                }
            } else {
                logger.error(&quot;[User Group] : User group Id not found &quot;)
                status = &quot;FAILED&quot;
                errMessage = &quot;FAILED_TO_UPDATE_USER_GROUP : &quot; + userGroupId
            }
        } else {
            status = &quot;FAILED&quot;
            errMessage = &quot;EXCEPTION_WHILE_GETTING_TOKEN&quot;
        }

    } else {
        status = &quot;FAILED&quot;
        errMessage = validateRes.errorMsg;
    }

    var returnMap = {
        &quot;status&quot; : status,
        &quot;errMessage&quot; : errMessage
    }
    return returnMap
}

function createUserGroupvViaCSV_User(userGroupMap, token , lookUpEntry ) {
    logger.info(&quot;Test4 : &quot;+userGroupMap)
    logger.info(&quot;[User Group Creation] :  Inside createUserGroupvViaCSV_User function with userGroupMap ==&quot; + userGroupMap)
    //var token =getAuthToken()
    var userGroup_res = {}

    try {
        var userGroupName = userGroupMap.get(&apos;userGroupName&apos;)
        var userGroupType = userGroupMap.get(&apos;userGroupType&apos;)
        var locationName = userGroupMap.get(&apos;locationName&apos;)
        var locIdentifier = userGroupMap.get(&apos;locationIdentifier&apos;)
        if (token) {

            var rolesName = {}
            var orgId = null

            var orgReqParams = new java.util.HashMap()
            orgReqParams.put(&apos;keyName&apos;, &apos;name.value&apos;)
            orgReqParams.put(&apos;keyValue&apos;, configurationMap.get(&apos;organisation&apos;))
            var orgData = findDataFromDB(&apos;ORGANIZATION&apos;, orgReqParams)
            orgId = getId_User(orgData)

            var menuList = getMenuItems_User(userGroupType)
            logger.info(&quot;Menu List :&quot;+JSON.stringify(menuList))
            var patientBannerList = getPatientBannerMenuItems_User(userGroupType,userGroupName)
            logger.info(&quot;PatientBannerList :&quot;+JSON.stringify(patientBannerList))

            if(lookUpEntry){
                var MenuIdlist = []
                for (i in menuList){
                    logger.info(&quot;menuItem to add &quot;+menuList[i].menuItem)
                    MenuIdlist.push(menuList[i].menuItem)
                }
                logger.info(&quot;MenuIdlist : &quot;+MenuIdlist)
                //var flag = 0;
                logger.info(&quot;Inside if : &quot;+JSON.stringify(lookUpEntry.menuItems));
                for(i in lookUpEntry.menuItems){

                    logger.info(&quot;lookUpEntry.menuItemId :&quot;+lookUpEntry.menuItems[i].menuItem)
                    if(MenuIdlist.indexOf(lookUpEntry.menuItems[i].menuItem)== -1 ){
                        menuList.push(lookUpEntry.menuItems[i]);
                        MenuIdlist.push(lookUpEntry.menuItems[i].menuItem)
                    }
                }

                var patientBannerMenuIdList = []//new Packages.java.util.ArrayList()
                for(i in patientBannerList){
                    patientBannerMenuIdList.push(patientBannerList[i].menuItem)
                }
                logger.info(&quot;patientBannerMenuIdList : &quot;+patientBannerMenuIdList)

                for (i in lookUpEntry.patientBannerMenuItems){
                    //logger.info(lookUpEntry.patientBannerMenuItems[i].menuItem)
                    if(patientBannerMenuIdList.indexOf(lookUpEntry.patientBannerMenuItems[i].menuItem )== -1 ){
                        patientBannerList.push(lookUpEntry.patientBannerMenuItems[i]);
                        patientBannerMenuIdList.push(lookUpEntry.patientBannerMenuItems[i].menuItem)
                    }
                }
            }

            logger.info(&quot;Menu List After:&quot;+JSON.stringify(menuList))
            logger.info(&quot;PatientBannerList After:&quot;+JSON.stringify(patientBannerList))

            var userGroupRequestMap = new java.util.HashMap()
            if (orgId &amp;&amp; userGroupName &amp;&amp; menuList &amp;&amp; patientBannerList) {
                logger.info(&quot;[UserGroup] : Going to create User Group with Data&quot;)
                var userGroupSaveUrl = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userGroupCreate_url
                
                userGroupRequestMap.put(&quot;userGroupName&quot;, userGroupName)
                userGroupRequestMap.put(&quot;location&quot;, &quot;&quot;)
                userGroupRequestMap.put(&quot;token&quot;, token)
                userGroupRequestMap.put(&quot;menuList&quot;, menuList)
                userGroupRequestMap.put(&quot;orgId&quot;, orgId)
                userGroupRequestMap.put(&quot;patientBannerList&quot;, patientBannerList)
                userGroupRequestMap.put(&quot;token&quot;, token)
                userGroupRequestMap.put(&quot;rolesJson&quot;, rolesName)

                if (userGroupMap.get(&apos;userGroupId&apos;)) {
                    var userGroupUpdateUrl = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userGroupUpdateUrl
                    var userGroupId = userGroupMap.get(&apos;userGroupId&apos;)
                    userGroupRequestMap.put(&quot;userGroupUrl&quot;, userGroupUpdateUrl)
                    userGroupRequestMap.put(&quot;userGroupId&quot;, userGroupId)
                    rolesName = getRoles_User(userGroupType, locationName, locIdentifier, orgId, userGroupId, userGroupName, userGroupMap)
                    if (rolesName) {
                        logger.info(&quot;going to get roles from userGroup&quot;)
                        if(lookUpEntry){
                            for(id in lookUpEntry.authorities){
                                var rolesReqParam = new java.util.HashMap()
                                rolesReqParam.put(&apos;keyName&apos;, &apos;_id&apos;)
                                rolesReqParam.put(&apos;keyValue&apos;, parseInt(id))

                                var rolesData = findDataFromDB(&apos;ROLES&apos;, rolesReqParam)
                                if (rolesData.totalCount &gt; 0) {
                                    logger.info(&quot;[User Group Creation] : Roles Data Count is &quot; + rolesData.totalCount)
                                    var cursor = null
                                    var lookUpEntry1 = null
                                    cursor = rolesData.message
                                    var lookUpEntry1 = JSON.parse(cursor.next())
                                    var roleName = lookUpEntry1.authority
                                    logger.info(&quot;roleName :&quot;+roleName+&quot;test : &quot;+rolesName[roleName])
                                    if(rolesName[roleName]){
                                        for (i in lookUpEntry.authorities[id]) {
                                            if (rolesName[roleName].indexOf(lookUpEntry.authorities[id][i]) == -1) rolesName[roleName].add(lookUpEntry.authorities[id][i])
                                        }
                                    }else{
                                        rolesName[roleName]=lookUpEntry.authorities[id]
                                    }
                                }
                            }

                        }

                        userGroupRequestMap.put(&quot;rolesJson&quot;, rolesName)
                        logger.info(&quot;Roles Name:&quot;+JSON.stringify(rolesName))
                    } else {
                        FileUtil.write(&apos;/tmp/log.txt&apos;, true, channelName + &quot;:&quot; + &quot;[User Group] : Role is not Found for userGroup Id &quot; + userGroupId + &quot;\n&quot;);
                    }
                } else {
                    userGroupRequestMap.put(&quot;userGroupUrl&quot;, userGroupSaveUrl)
                }
                userGroup_res = createAndUpdateUserGroup(userGroupRequestMap)

                if (userGroup_res.status == 200) {
                    logger.info([&quot;User Group Created Successfully&quot;])
                }
            } else {
                FileUtil.write(&apos;/tmp/log.txt&apos;, true, channelName + &quot;:&quot; + &quot;[User Group] : Some Fields are missing for creating user group&quot; + &quot;\n&quot;);
                //logger.error(&quot;[User Group] : Some Fields are missing for creating user group &quot;)
            }
        } else {
            // logger.error(&quot;[User Group Creation ] createUserGroupvViaCSV_User : Error occured while getting token from login API&quot;)
            FileUtil.write(&apos;/tmp/log.txt&apos;, true, channelName + &quot;:&quot; + &quot;[User Group Creation ] createUserGroupvViaCSV_User : Error occured while getting token from login API in CreateuserGroup&quot;);
        }
    } catch (e) {
        logger.error(&quot;Exception Occured while creating user/userGroup&quot;+e + e.stack)
        throw(e)
    }

    return userGroup_res
}

function getRoles_User(userGroupType, locationName, locationIdentifier, orgId, userGroupId, userGroupName, userGroupDataMap) {
    logger.info(&quot;Test4 : &quot;+userGroupDataMap)
    logger.info(&quot;[User Group Creation] : Inside Get Roles Function &quot;)

    try {
        var rolesName = {}
        var userGroupMap = JSON.parse(configurationMap.get(&apos;userGroupCreationMap&apos;))
        var roleLocatioIdList = new java.util.ArrayList()
        
        if (userGroupType in userGroupMap) {
            logger.info(&quot;[User Group] Going to get Roles Data for Team ==&quot; + JSON.stringify(userGroupMap[userGroupType]))
            for (rolesArray in userGroupMap[userGroupType].roles) {
                logger.info(&apos;Roles Team is :&apos;+userGroupMap[userGroupType].roles[rolesArray])
                var cursor = null
                var lookUpEntry = null
                var rolesReqParam = new java.util.HashMap()
                rolesReqParam.put(&apos;keyName&apos;, &apos;authority&apos;)
                rolesReqParam.put(&apos;keyValue&apos;, userGroupMap[userGroupType].roles[rolesArray])

                var rolesData = findDataFromDB(&apos;ROLES&apos;, rolesReqParam)

                if (rolesData.totalCount &gt; 0) {
                    logger.info(&quot;[User Group Creation] : Roles Data Count is &quot; + rolesData.totalCount)
                    cursor = rolesData.message
                    lookUpEntry = JSON.parse(cursor.next())
                    var userGroupIdList = new java.util.ArrayList()
                    if (userGroupMap[userGroupType].roles[rolesArray] == &quot;ROLE_LOCATION_ACCESS&quot;) {

                        if (locationName &amp;&amp; locationIdentifier) {
                        	var facilityAddressMap = {}
                        	facilityAddressMap.facilityAddress = userGroupDataMap.get(&quot;facilityAddress&quot;);
                            facilityAddressMap.facilityCity = userGroupDataMap.get(&quot;facilityCity&quot;);
                            facilityAddressMap.facilityState = userGroupDataMap.get(&quot;facilityState&quot;);
                            facilityAddressMap.facilityPostalCode = userGroupDataMap.get(&quot;facilityPostalCode&quot;);
                            facilityAddressMap.facilityTINNumber = userGroupDataMap.get(&quot;facilityTINNumber&quot;);
                            var locDataMap = getLocationData(locationName, locationIdentifier, orgId, facilityAddressMap, true)
                            logger.info(&quot;FROM getLocationData : &quot;+JSON.stringify(locDataMap))
                            if(locDataMap.status==&quot;FAILED&quot;){
                                throw(locDataMap.errMessage);
                            }else{
                                roleLocatioIdList.add(locDataMap.locationId)
                            }
                        }else if(userGroupDataMap.get(&quot;locationNameList&quot;) &amp;&amp; userGroupDataMap.get(&quot;locationIdentifierList&quot;)){
                        			logger.info(&quot;locationIdentifierList: &quot;+JSON.stringify(userGroupDataMap.get(&quot;locationIdentifierList&quot;))+&quot; lengt: &quot;+userGroupDataMap.get(&quot;locationIdentifierList&quot;).length)
							for(index = 0;index &lt; userGroupDataMap.get(&quot;locationIdentifierList&quot;).length; index++){
								var facilityAddressMap = {}
								facilityAddressMap.facilityAddress = (userGroupDataMap.get(&quot;facilityAddressList&quot;).length &gt; index) ? userGroupDataMap.get(&quot;facilityAddressList&quot;)[index] : &quot;&quot;
								facilityAddressMap.facilityCity = (userGroupDataMap.get(&quot;facilityCityList&quot;).length &gt; index) ? userGroupDataMap.get(&quot;facilityCityList&quot;)[index] : &quot;&quot;;
								facilityAddressMap.facilityState= (userGroupDataMap.get(&quot;facilityStateList&quot;).length &gt; index) ? userGroupDataMap.get(&quot;facilityStateList&quot;)[index] : &quot;&quot;;
								facilityAddressMap.facilityPostalCode = (userGroupDataMap.get(&quot;facilityPostalCodeList&quot;).length &gt; index) ? userGroupDataMap.get(&quot;facilityPostalCodeList&quot;)[index] : &quot;&quot;;
								facilityAddressMap.facilityTINNumber = (userGroupDataMap.get(&quot;facilityTINNumberList&quot;).length &gt; index) ? userGroupDataMap.get(&quot;facilityTINNumberList&quot;)[index] : &quot;&quot;;
								var locDataMap = getLocationData(userGroupDataMap.get(&quot;locationNameList&quot;)[index], userGroupDataMap.get(&quot;locationIdentifierList&quot;)[index], orgId, facilityAddressMap, true)
								logger.info(&quot;FROM getLocationData : &quot;+JSON.stringify(locDataMap))
								if(locDataMap.status==&quot;FAILED&quot;){
									throw(locDataMap.errMessage);
								}else{
									roleLocatioIdList.add(locDataMap.locationId)
								}
							}
						}
                        rolesName[lookUpEntry.authority] = roleLocatioIdList
                    }else if(userGroupMap[userGroupType].roles[rolesArray] == &quot;ROLE_DELETE_FORM&quot;){
					rolesName[lookUpEntry.authority] = []
				}else {
                        	rolesName[lookUpEntry.authority] = &quot;&quot;
                    }
                    if (userGroupMap[userGroupType].roles[rolesArray] == &quot;ROLE_TASK_ACCESS&quot;) {
                        //userGroupIdList.add(userGroupId)
                        //rolesName[lookUpEntry.authority] = userGroupIdList
                        logger.info(&quot;Role Task Access Data&quot; + lookUpEntry._id)
                        var userGroupParam = {}
                        userGroupParam[&apos;authorities&apos;+&apos;.&apos;+lookUpEntry._id] = {&quot;$exists&quot;:true};
                        userGroupParam[&quot;_id&quot;] = userGroupId;

                        var auscUserGroupData = findDataFromDB(&apos;USERGROUP&apos;,userGroupParam)
                        logger.info(&quot;auscUserGroupData:&quot;+JSON.stringify(auscUserGroupData))

                        //logger.info(list)
                        if (auscUserGroupData.totalCount &gt; 0) {
                            var cursor2 = auscUserGroupData.message
                            logger.info(&quot;cursor2 &quot; + JSON.stringify(cursor2))
                            var lookUpEntry1 = JSON.parse(cursor2.next())
                            logger.info(&quot;lookUpEntry1&quot; + JSON.stringify(lookUpEntry1))
                            logger.info( &quot;Task Value:&quot;+lookUpEntry1.authorities[lookUpEntry._id.toString()])
                            logger.info(&quot;Task Exists in Db&quot;)
                            logger.info(&quot;ROLE_TASK_ACCESS_ALREADY_EXISTS_IN_USERGROUP : &quot;+userGroupId);
                            userGroupIdList.add(userGroupId)
                            logger.info(&quot;Got authority &quot;+lookUpEntry._id.toString()+&quot; as :&quot;+JSON.stringify(lookUpEntry1.authorities[lookUpEntry._id.toString()]))
                            //userGroupIdList.add(lookUpEntry1.authorities[lookUpEntry._id.toString()])
                            for(i in lookUpEntry1.authorities[lookUpEntry._id.toString()]){
                                if(userGroupIdList.indexOf(lookUpEntry1.authorities[lookUpEntry._id.toString()][i])== -1){
                                    userGroupIdList.add(lookUpEntry1.authorities[lookUpEntry._id.toString()][i])
                                }
                            }
                            //var set = new Set(userGroupIdList);
                            //userGroupIdList = Array.from(set)
                            logger.info(&quot;userGroupIdList&quot;+JSON.stringify(userGroupIdList))
                            rolesName[lookUpEntry.authority] = userGroupIdList

                        }else{
                            logger.info(&quot;Task Access Not exist in userGroup&quot;)
                            userGroupIdList.add(userGroupId)
                            rolesName[lookUpEntry.authority] = userGroupIdList
                        }

                    }
                }
            }
            if(userGroupMap[userGroupType].formRoles &amp;&amp; (userGroupName != &quot;LHH Operating Room&quot; &amp;&amp; userGroupName != &quot;LHH PAT&quot; &amp;&amp; userGroupName != &quot;LHH Booking&quot;)){
                for(rolesArray in userGroupMap[userGroupType].formRoles){
                    logger.info(&apos;Form Roles Team is :&apos;+userGroupMap[userGroupType].formRoles[rolesArray])
                    var cursor = null
                    var lookUpEntry = null
                    var rolesReqParam = new java.util.HashMap()
                    rolesReqParam.put(&apos;keyName&apos;, &apos;authority&apos;)
                    rolesReqParam.put(&apos;keyValue&apos;, rolesArray)

                    var rolesData = findDataFromDB(&apos;ROLES&apos;, rolesReqParam)

                    if (rolesData.totalCount &gt; 0) {
                        logger.info(&quot;[User Group Creation] : Roles Data Count is &quot; + rolesData.totalCount)
                        cursor = rolesData.message
                        lookUpEntry = JSON.parse(cursor.next())
                        rolesName[lookUpEntry.authority] = userGroupMap[userGroupType].formRoles[rolesArray]
                    }
                }
            }
        } else {
            FileUtil.write(&apos;/tmp/log.txt&apos;, true, channelName + &quot;: &quot; + &quot;[User Group Creation]  getRoles_User: userGroupType Key doesnot exist in Json&quot; + userGroupType + &quot;\n&quot;);
            // logger.error(&quot;[User Group Creation] getRoles_User: userGroupType Key doesnot exist in Json&quot;)
        }

        return rolesName;
    } catch (e) {
        logger.error(&apos;Exception occured while getting roles&apos;+e + e.stack)
        throw(e)
    }
    
}

function getMenuItems_User(userGroupType) {
    logger.info(&quot;[User Group Creation ] : Inside getMenuItems_User with userGroupType&quot; + userGroupType)
    var menuList = []//new Packages.java.util.ArrayList()
    try {
        var menuJson = JSON.parse(configurationMap.get(&apos;userGroupCreationMap&apos;))

        if (userGroupType in menuJson) {
            for (menu in menuJson[userGroupType].menuItems) {
                logger.info(&quot;[UserGroup]: User Group Menu Data Inside Loop &quot; + menuJson[userGroupType].menuItems[menu])
                var menuItemReqParam = new java.util.HashMap()
                menuItemReqParam.put(&apos;keyName&apos;, &apos;name&apos;)
                menuItemReqParam.put(&apos;keyValue&apos;, menuJson[userGroupType].menuItems[menu])

                var menuData = findDataFromDB(&apos;MENUITEM&apos;, menuItemReqParam)
                logger.info(&quot;[User Group Creation] : Menu Items Count is &quot; + menuData.totalCount)
                if (menuData.totalCount &gt; 0) {

                    var menusId = {}
                    var menuId = getId_User(menuData)
                    menusId.menuItem = menuId

                    if (menuJson[userGroupType].menuItems[menu] == menuJson[userGroupType].defaultMenuBar) {

                        menusId.isDefault = true
                    } else {
                        menusId.isDefault = false
                    }

                    menuList.push(menusId)
                    logger.info(&quot;[User  Group Creation] :  Menu List Created is &quot; + JSON.stringify(menuList))
                }
            }

        } else {
            FileUtil.write(&apos;/tmp/log.txt&apos;, true, channelName + &quot;: &quot; + &quot;[User Group Creation] getMenuItems_User: userGroupType Key doesnot exist in Json&quot; + userGroupType + &quot;\n&quot;);
            // logger.error(&quot;[User Group Creation] getMenuItems_User: userGroupType Key doesnot exist in Json&quot;)
        }
    } catch (e) {
        logger.error(&quot;Exception occured while getting menu items&quot;+e + e.stack)
    }
    
    return menuList;

}

function getPatientBannerMenuItems_User(userGroupType,userGroupName) {
    logger.info(&quot;[User Group Creation] :  Inside getPatientBannerMenuItems_User for userGroupType&quot; + userGroupType)
    var patientBannerList = []// new Packages.java.util.ArrayList()

    try {
        var patientBannerMenuJson = JSON.parse(configurationMap.get(&apos;userGroupCreationMap&apos;))

        if (userGroupType in patientBannerMenuJson) {
            for (patientMenu in patientBannerMenuJson[userGroupType].patientBanner) {
                logger.info(&quot;[UserGroup]: User Group patient Banner Menu Data Inside Loop &quot; + patientBannerMenuJson[userGroupType].patientBanner[patientMenu])
                if(patientBannerMenuJson[userGroupType].patientBanner[patientMenu]== &quot;eforms&quot; &amp;&amp; (userGroupName == &quot;LHH Operating Room&quot; || userGroupName == &quot;LHH PAT&quot; || userGroupName == &quot;LHH Booking&quot;)){
                    continue;
                }
                var menuItemReqParam = new java.util.HashMap()
                menuItemReqParam.put(&apos;keyName&apos;, &apos;name&apos;)
                menuItemReqParam.put(&apos;keyValue&apos;, patientBannerMenuJson[userGroupType].patientBanner[patientMenu])

                var patientMenuData = findDataFromDB(&apos;MENUITEM&apos;, menuItemReqParam)
                logger.info(&quot;Patient Banner Menu Data is &quot; + patientMenuData)
                if (patientMenuData.totalCount &gt; 0) {
                    logger.info(&quot;[User Group] :Inside Search Data count for patient Banner menuItems&quot;)
                    var patientBanner = {}
                    var patientMenuId = getId_User(patientMenuData)
                    patientBanner.menuItem = patientMenuId
                    if (patientBannerMenuJson[userGroupType].patientBanner[patientMenu] == patientBannerMenuJson[userGroupType].defaultPatientBanner) {
                        patientBanner.isDefault = true
                    } else {
                        patientBanner.isDefault = false
                    }

                    patientBannerList.push(patientBanner)

                    logger.info(&quot;===========Patient Banner List&quot; + JSON.stringify(patientBannerList))

                } else {
                    logger.error(&quot;PatientMenuData Not Found&quot;)
                }
            }
        } else {
            FileUtil.write(&apos;/tmp/log.txt&apos;, true, channelName + &quot;: &quot; + &quot;[User Group Creation] getPatientBannerMenuItems_User : userGroupType Key doesnot exist in Json&quot; + userGroupType + &quot;\n&quot;);
            //	logger.error(&quot;[User Group Creation] getPatientBannerMenuItems_User:  userGroupType doesnot exist in Json&quot;)

        }

    } catch (e) {
        logger.error(&quot;Exception Occured while getting patient banner Items&quot;+e + e.stack)
    }
    return patientBannerList;

}

function updateUserGroupRoles_User(requestMap) {
    logger.info(&quot;Going to Update UserGroup &quot; + accessRole)
    var userGroup_res = null
    try {
        var userGroupUpdateUrl = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).userGroupUpdateUrl

        var userGroupData = requestMap.get(&apos;userGroupData&apos;)
        //  var token = getAuthToken()
        var token = configurationMap.get(&apos;xAuthToken&apos;)
        logger.info(&quot;rolesReq&quot; + JSON.stringify(lookUpEntry.authorities))

        var userUpdateRequestMap = new java.util.HashMap()
        userUpdateRequestMap.put(&quot;orgId&quot;, userGroupData.organizationId)
        userUpdateRequestMap.put(&quot;userGroupName&quot;, userGroupData.name)
        userUpdateRequestMap.put(&quot;location&quot;, userGroupData.locationId)
        userUpdateRequestMap.put(&quot;rolesJson&quot;, requestMap.get(&apos;roles&apos;))
        userUpdateRequestMap.put(&quot;menuList&quot;, userGroupData.menuItems)
        userUpdateRequestMap.put(&quot;patientBannerList&quot;, userGroupData.patientBannerMenuItems)
        userUpdateRequestMap.put(&quot;token&quot;, requestMap.get(&apos;token&apos;))
        userUpdateRequestMap.put(&quot;userGroupUrl&quot;, userGroupUpdateUrl)
        userUpdateRequestMap.put(&quot;userGroupId&quot;, userGroupData._id)
        userGroup_res = createAndUpdateUserGroup(userUpdateRequestMap)

        logger.info(&quot;Result =======&quot; + userGroup_res)

        if (userGroup_res.status == 200) {
            logger.info([&quot;User Group Updated Successfully&quot;])
        } else {
            FileUtil.write(&apos;/tmp/log.txt&apos;, true, channelName + &quot;:&quot; + &quot;Error occured while updating userGroup Task role for userGroup Id&quot; + lookUpEntry._id + &quot;\n&quot;);
            //logger.error(&quot;[User Group] : Some Fields are missing for creating user group &quot;)
        }

    } catch (e) {
        logger.error(&quot;Exception Occured while updating user Group Roles&quot;+e + e.stack)
    }

    return userGroup_res
}

function getId_User(jsonData) {
    try {
        logger.info(&quot;Inside getId_User function with json Response =======&quot; + jsonData)
        var cursor = jsonData.message
        var lookUpEntry = JSON.parse(cursor.next())

        return lookUpEntry._id
    } catch (e) {
        logger.error(&quot;Exception Occured while Getting id&quot;+e + e.stack)
    }
}

function validateData_User(requestMap) {
    var filter = {
        &quot;flag&quot;: true,
        &quot;errorMsg&quot;: &quot;&quot;
    }
    var error = &quot;&quot;
    try {
        /*if((!requestMap.get(&apos;firstName&apos;) == null || (requestMap.get(&apos;firstName&apos;) &amp;&amp;  !(requestMap.get(&apos;firstName&apos;).match(/[a-zA-Z]/)))) || (!requestMap.get(&apos;lastName&apos;)|| (requestMap.get(&apos;lastName&apos;) &amp;&amp;  !(requestMap.get(&apos;lastName&apos;).match(/[a-zA-Z]/))) )){
        error=&quot;Either  Name is Missing or invalid&quot;
        }*/

        if(!requestMap.get(&apos;locationIdentifier&apos;) || requestMap.get(&apos;locationIdentifier&apos;) == &quot;&quot;){
            error=error + &quot; | LOCATION_ID_IS_INVALID&quot;
        }

        if(!requestMap.get(&apos;locationName&apos;) || (requestMap.get(&apos;locationName&apos;) &amp;&amp; !(requestMap.get(&apos;locationName&apos;).match(/^[\w\/&amp;\.,:_\- \\]+$/)))){
        	error = error + &quot;| INVALID_LOCATION_NAME_CONTAINS_CHARACTER/s(&apos;)&quot;
		}

        if(requestMap.get(&apos;locationIdentifier&apos;)){
            var locationFindMap = new java.util.HashMap()
            locationFindMap.put(&quot;keyName&quot;,&apos;identifier.value.value&apos;)
            logger.info(&quot;locationIdentifier found : &quot;+requestMap.get(&apos;locationIdentifier&apos;))
            locationFindMap.put(&quot;keyValue&quot;,requestMap.get(&apos;locationIdentifier&apos;).toString())
            var locationData= findDataFromDB(&apos;LOCATION&apos;,locationFindMap)
            logger.info(&quot;Total Location Count : &quot;+locationData.totalCount)
            if(locationData.totalCount &gt; 0){
                var cursor =locationData.message
                var lookUpEntry=JSON.parse(cursor.next())
                if(lookUpEntry.status &amp;&amp; lookUpEntry.status.value != &quot;active&quot;)
                    error = error + &quot; | THE LOCATION &quot;+requestMap.get(&apos;locationIdentifier&apos;)+&quot; IS DISABLED. ENABLE IT TO PROCESS THE USER&quot;
            }
        }

        if (!requestMap.get(&apos;email&apos;) || (requestMap.get(&apos;email&apos;) &amp;&amp; !(requestMap.get(&apos;email&apos;).match(/^[\w\.\-]+([\w\.\-]+)*\@[\w\.\-]+\.[\w]{2,}$/)))) {
            //	filter.flag=false
            error = error + &quot; | &quot;+(requestMap.get(&apos;email&apos;) ? &quot;EMAIL_IS_INVALID : CHAR_SET_OUT_OF [a-zA-Z0-9@._-]&quot; : &quot;EMAIL_IS_EMPTY&quot;);
        }

        if (!requestMap.get(&apos;userGroupName&apos;) ) {

            error =  error + &quot; | USER_GROUP_NAME_IS_EMPTY&quot;;
        }

        if(requestMap.get(&apos;userGroupName&apos;) &amp;&amp; requestMap.get(&apos;userGroupName&apos;).indexOf(&quot;\&apos;&quot;) != -1){
        	error =  error + &quot; | INVALID_USER_GROUP_NAME_CONTAINS_CHARACTER/s(&apos;)&quot;;
        }

        if (!requestMap.get(&apos;userType&apos;) || (requestMap.get(&apos;userType&apos;) &amp;&amp; !(requestMap.get(&apos;userType&apos;).match(/^[a-zA-Z]+$/)))) {
            error = error + &quot; | &quot;+(requestMap.get(&apos;userType&apos;) ? &quot;USER_TYPE_IS_INVALID : CHAR_SET_OUT_OF [a-zA-Z]&quot; : &quot;USER_TYPE_IS_EMPTY&quot;)
        }

        if (error || error != &quot;&quot;) {
            filter.flag = false
            filter.errorMsg = error
        }
		
		if(requestMap.get(&apos;locationNameList&apos;) &amp;&amp; requestMap.get(&apos;locationIdentifierList&apos;)){
			var locationNameList = requestMap.get(&apos;locationNameList&apos;)
			var locationIdentifierList = requestMap.get(&apos;locationIdentifierList&apos;)
			for (loc in locationNameList, locationIdentifierList) {
				if(!locationIdentifierList[loc] || locationIdentifierList[loc] == &quot;&quot;){
					error=error + &quot; | LOCATION_ID_IS_INVALID&quot;
				}

				if(!locationNameList[loc] || (locationNameList[loc] &amp;&amp; !(locationNameList[loc].match(/^[\w\/&amp;\.,:_\- \\]+$/)))){
					error = error + &quot;| INVALID_LOCATION_NAME_CONTAINS_CHARACTER/s(&apos;)&quot;
				}
				
				var locationFindMap = new java.util.HashMap()
				locationFindMap.put(&quot;keyName&quot;,&apos;identifier.value.value&apos;)
				logger.info(&quot;locationIdentifier found : &quot;+locationIdentifierList[loc])
				locationFindMap.put(&quot;keyValue&quot;,locationIdentifierList[loc].toString())
				var locationData= findDataFromDB(&apos;LOCATION&apos;,locationFindMap)
				logger.info(&quot;Total Location Count : &quot;+locationData.totalCount)
				if(locationData.totalCount &gt; 0){
					var cursor =locationData.message
					var lookUpEntry=JSON.parse(cursor.next())
					if(lookUpEntry.status &amp;&amp; lookUpEntry.status.value != &quot;active&quot;)
						error = error + &quot; | THE LOCATION &quot;+locationIdentifierList[loc]+&quot; IS DISABLED. ENABLE IT TO PROCESS THE USER&quot;
				}				
			}
		}
		
    } catch (e) {
        logger.error(&quot;Exception Occured while filtering CSV Data : &quot;+e +e.stack )
        filter.flag = false
        filter.errorMsg = &quot;ERROR_IN_PARSING_MESSAGE&quot;
    }
    return filter;
}

function closeMatchCheck_User(firstName, lastName) {

    var returnMap = {&quot;errMessage&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;}
    var userFindMap = {}

    if(firstName.length()&gt;=4){
        firstName = firstName.substring(0,4).toString()
    }
    if(lastName.length() &gt;= 4){
        lastName = lastName.substring(lastName.length() -4,lastName.length()).toString()
    }

    userFindMap[&quot;firstName&quot;] = {&quot;$regex&quot;:(&quot;^&quot;+firstName).toString(),&quot;$options&quot;:&quot;i&quot;}
    userFindMap[&quot;lastName&quot;] = {&quot;$regex&quot;:(lastName+&quot;$&quot;).toString(), &quot;$options&quot; : &quot;i&quot;}
    try{
        var  userResource = findDataFromDB(&apos;USER&apos;,userFindMap,&quot;AND&quot;)
        if(userResource.totalCount  &amp;&amp; userResource.totalCount &gt; 0){
            logger.info(&quot;FOUND_MULTIPLE_USER_WITH_SIMILAR_NAME&quot;+userResource)
            returnMap = {&quot;errMessage&quot;:&quot;FOUND_MULTIPLE_USER_WITH_SIMILAR_NAME&quot;,&quot;status&quot;:&quot;FAILED&quot;}
        }
    }
    catch(ex){
        logger.error(&quot;EXCEPTION_WHILE_FETCHING_CLOSE_MATCH_OF_USER&quot;+ex + ex.stack)
        returnMap = {&quot;errMessage&quot;:&quot;EXCEPTION_WHILE_FETCHING_CLOSE_MATCH_OF_USER&quot;,&quot;status&quot;:&quot;FAILED&quot;}
    }

    return returnMap
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>58f0cb2f-994a-4b03-8137-5414dc6a95f3</id>
            <name>enableJob</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522848703</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {String} arg1 - arg1 description
					@return {String} return description
					*/
					function enableJob(serviceName) {
					try{
					var jobMap = {}
					jobMap.collectionName = &quot;jobConfiguration&quot;
					jobMap.document = new Packages.com.mongodb.BasicDBObject(&quot;enabled&quot;,true)
					jobMap.find = new Packages.com.mongodb.BasicDBObject(&quot;serviceName&quot;,new Packages.com.mongodb.BasicDBObject(&quot;\$in&quot;,serviceName))
					jobMap.multi = true
					var jobUpdateRes = MongoGlobalService(&quot;update&quot;, jobMap)
					logger.info(&quot;Job enabled sucessfully &quot;+jobUpdateRes)
					}catch(ex){
					logger.error(e);
					}
					}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>56fac295-d2ad-4ec6-9494-9138d5a6e4b2</id>
            <name>findDataFromDB</name>
            <revision>2</revision>
            <lastModified>
              <time>1671608682803</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {String} arg1 - arg1 description
					@return {String} return description
					*/
					function findDataFromDB(action,requestMap,groupBy) {
					// TODO: Enter code here

					var result = null
					if(action == &quot;PRACTITIONER&quot;){
					return result = findPractitioner(requestMap,groupBy)
					}

					if(action == &quot;LOCATION&quot;){
					return result = findLocation(requestMap)
					}

					if(action == &quot;USER&quot;){
					return result = findUser(requestMap,groupBy)
					}

					if(action == &quot;USERGROUP&quot;){
					return result = findUserGroup(requestMap,groupBy)
					}

					if(action == &quot;ORGANIZATION&quot;){
					return result = findOrganization(requestMap)
					}
					if(action == &quot;ROLES&quot;){
					return result = findRoles(requestMap)
					}

					if(action==&quot;MENUITEM&quot;){
					return result = findMenuItem(requestMap)
					}

					if(action == &quot;COUNTRIESSET&quot;){
					return result = findCountriesSet(requestMap,groupBy)
					}
					
					if(action == &quot;CITIESSET&quot;){
					return result = findCitiesSet(requestMap,groupBy)
					}
					
					if(action == &quot;STATESSET&quot;){
					return result = findStatesSet(requestMap,groupBy)
					}
         
					}

					function findLocation(requestMap){&#xd;  	  logger.info(&quot;Inside Find Location function With &quot; + requestMap.get(&apos;keyName&apos;))
					var locationData=null
					var queryMap ={}
					if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).locationCollectionName){
					var locationQuery= new Packages.com.mongodb.BasicDBObject(requestMap.get(&apos;keyName&apos;),requestMap.get(&apos;keyValue&apos;))
					queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).locationCollectionName
					queryMap.find = locationQuery
					locationData =MongoGlobalService(&quot;search&quot;,queryMap)
					}else{
					logger.error(&quot;Location Collection name is not defined in configurationMap&quot;)
					}

					return locationData;
					}

					function findUserGroup(requestMap,groupBy){
					logger.info(&quot;Inside findUsergroup Function&quot; + requestMap)
					var userGroupSearchResponse=null
					var queryMap ={}
					if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userGroupCollectionName){
					var searchList = new Packages.java.util.ArrayList();
					for (key in requestMap){
					//logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
					searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
					}
					queryMap.collectionName=JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userGroupCollectionName;
					if(groupBy == &quot;OR&quot;){
					queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
					}else{
					queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);

					}
					userGroupCollectionName =  MongoGlobalService(&quot;search&quot;,queryMap)
					}else{
					logger.error(&quot;userGroup Collection Name is not defined in configurationMap&quot;)
					}
					return userGroupCollectionName;
					}



					function findUser(requestMap,groupBy){
					logger.info(&quot;Inside Search User Function&quot; + requestMap)
					var userSearch_res=null
					var queryMap ={}
					if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userCollectionName){
					var searchList = new Packages.java.util.ArrayList();
					for (key in requestMap){
					//logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
					searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
					}
					queryMap.collectionName=JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userCollectionName;
					if(groupBy == &quot;OR&quot;){
					queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
					}else{
					queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);

					}
					userSearch_res =  MongoGlobalService(&quot;search&quot;,queryMap)
					}else{
					logger.error(&quot;User Collection Name is not defined in configurationMap&quot;)
					}
					return userSearch_res;
					}

					function findPractitioner(requestMap,groupBy){
					logger.info(&quot;Inside Find Practitioner&quot;)
					var practitionerSearchData=null
					var queryMap= {}
					if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).practitionerCollectionName){
					var searchList = new Packages.java.util.ArrayList();
					for (key in requestMap){
					//logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
					searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
					}
					queryMap.collectionName=JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).practitionerCollectionName;
					if(groupBy == &quot;OR&quot;){
					queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
					}else{
					queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);

					}

					//logger.info(&quot;FINDQUERY : &quot;+queryMap.find)
					practitionerSearchData  =  MongoGlobalService(&quot;search&quot;,queryMap)
					}else{
					logger.error(&quot;Practitioner collection Name is not defined in configurationMap&quot;)
					}

					return practitionerSearchData;

					}


					function findOrganization(requestMap){
					logger.info(&quot;[Find Organization ] :  Inside getOrganization Function &quot; +requestMap.get(&apos;keyName&apos;))
					var organizationData=null
					var queryMap = {}
					if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).orgCollectionName){
					var organizationQuery=new Packages.com.mongodb.BasicDBObject(requestMap.get(&apos;keyName&apos;),requestMap.get(&apos;keyValue&apos;))
					queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).orgCollectionName;
					queryMap.find=  organizationQuery
					organizationData= MongoGlobalService(&quot;search&quot;,queryMap)

					}else{
					logger.error(&quot;Organization collectionName is not defined in configurationMap&quot;)
					}
					return organizationData;&#xd;
					}

					function findRoles(requestMap){
					logger.info(&quot;[Find Roles ] :  Inside findRoles Function &quot;)
					var rolesData=null
					var queryMap = {}
					if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).roleCollectionName){
					var rolesQuery = new Packages.com.mongodb.BasicDBObject(requestMap.get(&apos;keyName&apos;),requestMap.get(&apos;keyValue&apos;))
					queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).roleCollectionName;
					queryMap.find=  rolesQuery
					rolesData= MongoGlobalService(&quot;search&quot;,queryMap)

					}else{
					logger.error(&quot;Roles collectionName is not defined in configurationMap&quot;)
					}
					return rolesData
					}


					function findMenuItem(requestMap){
					logger.info(&quot;[Find Roles ] :  Inside findMenuItem Function &quot;)
					var menuData=null
					var queryMap={}
					if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).menuCollectionName){
					var menuQuery = new Packages.com.mongodb.BasicDBObject(requestMap.get(&apos;keyName&apos;),requestMap.get(&apos;keyValue&apos;))
					queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).menuCollectionName;
					queryMap.find=  menuQuery
					menuData= MongoGlobalService(&quot;search&quot;, queryMap)
					}else{
					logger.error(&quot;menuItem collectionName is not defined in configurationMap&quot;)
					}
					return menuData
					}

					/*
					function searchDataFromCollection(queryMap,collectionName) {
					// TODO: Enter code here
					logger.info(&quot;[User Group] : Inside Search Function &quot;)
					logger.info(&quot;Query Object is &quot;+queryMap)
					var requestMap={};
					requestMap.collectionName=collectionName;
					requestMap.find=new Packages.com.mongodb.BasicDBObject(queryMap);
					logger.info(&quot;Search Map Created : &quot;+ requestMap);
					var searchResponse=MongoGlobalService(&quot;search&quot;,requestMap);
					logger.info(&quot;Search Map Cursor is :&quot;+ JSON.stringify(searchResponse));
					logger.info(&quot;Count for this query is :&quot;+ searchResponse.totalCount)
					logger.info(&quot;Search Map response  is : &quot;+ searchResponse.success);
					return searchResponse;

					}*/
								function findCitiesSet(requestMap,groupBy){
                                logger.info(&quot;[Find CitesSet ] :  Inside findCitesSet Function &quot;)
                                var citiesSetData=null
                                var queryMap={}
                                if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).citiesSetCollectionName){
                                var searchList = new Packages.java.util.ArrayList();
                                for (key in requestMap){
                                //logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
                                searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
                                }
                                queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).citiesSetCollectionName;
								
								if(groupBy == &quot;OR&quot;){
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
                                }else{
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);
                                }
                                citiesSetData= MongoGlobalService(&quot;search&quot;, queryMap)
                                }else{
                                logger.error(&quot;CitesSet collectionName is not defined in configurationMap&quot;)
                                }
                                return citiesSetData
                                }
								
							function findCountriesSet(requestMap,groupBy){
                                logger.info(&quot;[Find CountriesSet ] :  Inside findCountriesSet Function &quot;)
                                var countriesSetData=null
                                var queryMap={}
                                if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).countriesSetCollectionName){
                                	logger.info(&quot;inside 1st if of code template&quot;)
                                var searchList = new Packages.java.util.ArrayList();
                                for (key in requestMap){
                                //logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
                                searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
                                }
                                queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).countriesSetCollectionName;
								
								if(groupBy == &quot;OR&quot;){
									logger.info(&quot;inside 1.1 if of code template&quot;)
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
                                }else{
                                	logger.info(&quot;inside 1.1 else of code template&quot;)
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);
                                }
                                countriesSetData= MongoGlobalService(&quot;search&quot;, queryMap)
                                }else{
                                	logger.info(&quot;inside 1 else of code template&quot;)
                                logger.error(&quot;CountriesSet collectionName is not defined in configurationMap&quot;)
                                }
                                logger.info(&quot;countriesSetData - &quot;+countriesSetData)
                                return countriesSetData
                                }
								
								function findStatesSet(requestMap,groupBy){
                                logger.info(&quot;[Find StatesSet ] :  Inside FindStatesSet Function &quot;)
                                var statesSetData=null
                                var queryMap={}
                                if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).statesSetCollectionName){
                                var searchList = new Packages.java.util.ArrayList();
                                for (key in requestMap){
                                //logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
                                searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
                                }
                                queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).statesSetCollectionName;
								
								if(groupBy == &quot;OR&quot;){
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
                                }else{
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);
                                }
                                statesSetData= MongoGlobalService(&quot;search&quot;, queryMap)
                                }else{
                                logger.error(&quot;StatesSet collectionName is not defined in configurationMap&quot;)
                                }
                                return statesSetData
                                }</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>3ad6edb9-3bb1-4f92-ad5c-e421f56c9576</id>
            <name>GenerateUserNameAndPassword</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522846811</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {String} arg1 - arg1 description
					@return {String} return description
					*/
					function GenerateUserNameAndPassword(userMap) {
					logger.debug(&quot;[Generate Random user Name Password] : Inside GenerateUserNameAndPassword with Params&quot; +  + userMap.get(&apos;firstname&apos;) + &quot; &quot; + userMap.get(&apos;email&apos;))
					// TODO: Enter code here
					var userNameAndPassword = {}
					try {
					var requestMap = {}
					requestMap.collectionName = &apos;counters&apos;
					requestMap.nextIdType=&quot;custom&quot;
					requestMap.customCounterCollection =&quot;counters&quot;
					var id = MongoGlobalService(&quot;getMongoNextId&quot;, requestMap)

					// var generatedUserName = userMap.get(&apos;firstname&apos;).length() &lt; 4 ? userMap.get(&apos;firstname&apos;) + &quot;_&quot; +  id.next_id : userMap.get(&apos;firstname&apos;).substring(0,4) + &quot;_&quot; +  id.next_id

					//var generatedUserName = userMap.get(&apos;email&apos;).split(&apos;@&apos;)[0]
					// userNameAndPassword.username = generatedUserName;
					var generateRandomPassword = SHA512(userMap.get(&apos;email&apos;))
					userNameAndPassword.password = generateRandomPassword.substring(0, 8)
					logger.info(&quot;[Generate Random user Name Password] : Random Password and Name Generated is &quot;  +  JSON.stringify(userNameAndPassword))
					} catch (e) {
					logger.error(&quot;Exception occured while generating username and password&quot;+e)
					}

					return userNameAndPassword;
					}

					function SHA512(str){
					logger.info(&quot;[SHA512] :  Going to generate SHA hash for data&quot; + str)
					function int64(msint_32,lsint_32){this.highOrder=msint_32;this.lowOrder=lsint_32;}
					var H=[new int64(0x6a09e667,0xf3bcc908),new int64(0xbb67ae85,0x84caa73b),new int64(0x3c6ef372,0xfe94f82b),new int64(0xa54ff53a,0x5f1d36f1),new int64(0x510e527f,0xade682d1),new int64(0x9b05688c,0x2b3e6c1f),new int64(0x1f83d9ab,0xfb41bd6b),new int64(0x5be0cd19,0x137e2179)];var K=[new int64(0x428a2f98,0xd728ae22),new int64(0x71374491,0x23ef65cd),new int64(0xb5c0fbcf,0xec4d3b2f),new int64(0xe9b5dba5,0x8189dbbc),new int64(0x3956c25b,0xf348b538),new int64(0x59f111f1,0xb605d019),new int64(0x923f82a4,0xaf194f9b),new int64(0xab1c5ed5,0xda6d8118),new int64(0xd807aa98,0xa3030242),new int64(0x12835b01,0x45706fbe),new int64(0x243185be,0x4ee4b28c),new int64(0x550c7dc3,0xd5ffb4e2),new int64(0x72be5d74,0xf27b896f),new int64(0x80deb1fe,0x3b1696b1),new int64(0x9bdc06a7,0x25c71235),new int64(0xc19bf174,0xcf692694),new int64(0xe49b69c1,0x9ef14ad2),new int64(0xefbe4786,0x384f25e3),new int64(0x0fc19dc6,0x8b8cd5b5),new int64(0x240ca1cc,0x77ac9c65),new int64(0x2de92c6f,0x592b0275),new int64(0x4a7484aa,0x6ea6e483),new int64(0x5cb0a9dc,0xbd41fbd4),new int64(0x76f988da,0x831153b5),new int64(0x983e5152,0xee66dfab),new int64(0xa831c66d,0x2db43210),new int64(0xb00327c8,0x98fb213f),new int64(0xbf597fc7,0xbeef0ee4),new int64(0xc6e00bf3,0x3da88fc2),new int64(0xd5a79147,0x930aa725),new int64(0x06ca6351,0xe003826f),new int64(0x14292967,0x0a0e6e70),new int64(0x27b70a85,0x46d22ffc),new int64(0x2e1b2138,0x5c26c926),new int64(0x4d2c6dfc,0x5ac42aed),new int64(0x53380d13,0x9d95b3df),new int64(0x650a7354,0x8baf63de),new int64(0x766a0abb,0x3c77b2a8),new int64(0x81c2c92e,0x47edaee6),new int64(0x92722c85,0x1482353b),new int64(0xa2bfe8a1,0x4cf10364),new int64(0xa81a664b,0xbc423001),new int64(0xc24b8b70,0xd0f89791),new int64(0xc76c51a3,0x0654be30),new int64(0xd192e819,0xd6ef5218),new int64(0xd6990624,0x5565a910),new int64(0xf40e3585,0x5771202a),new int64(0x106aa070,0x32bbd1b8),new int64(0x19a4c116,0xb8d2d0c8),new int64(0x1e376c08,0x5141ab53),new int64(0x2748774c,0xdf8eeb99),new int64(0x34b0bcb5,0xe19b48a8),new int64(0x391c0cb3,0xc5c95a63),new int64(0x4ed8aa4a,0xe3418acb),new int64(0x5b9cca4f,0x7763e373),new int64(0x682e6ff3,0xd6b2b8a3),new int64(0x748f82ee,0x5defb2fc),new int64(0x78a5636f,0x43172f60),new int64(0x84c87814,0xa1f0ab72),new int64(0x8cc70208,0x1a6439ec),new int64(0x90befffa,0x23631e28),new int64(0xa4506ceb,0xde82bde9),new int64(0xbef9a3f7,0xb2c67915),new int64(0xc67178f2,0xe372532b),new int64(0xca273ece,0xea26619c),new int64(0xd186b8c7,0x21c0c207),new int64(0xeada7dd6,0xcde0eb1e),new int64(0xf57d4f7f,0xee6ed178),new int64(0x06f067aa,0x72176fba),new int64(0x0a637dc5,0xa2c898a6),new int64(0x113f9804,0xbef90dae),new int64(0x1b710b35,0x131c471b),new int64(0x28db77f5,0x23047d84),new int64(0x32caab7b,0x40c72493),new int64(0x3c9ebe0a,0x15c9bebc),new int64(0x431d67c4,0x9c100d4c),new int64(0x4cc5d4be,0xcb3e42b6),new int64(0x597f299c,0xfc657e2a),new int64(0x5fcb6fab,0x3ad6faec),new int64(0x6c44198c,0x4a475817)];var W=new Array(64);var a,b,c,d,e,f,g,h,i,j;var T1,T2;var charsize=8;function utf8_encode(str){return unescape(encodeURIComponent(str));}
					function str2binb(str){var bin=[];var mask=(1&lt;&lt;charsize)-1;var len=str.length*charsize;for(var i=0;i&lt;len;i+=charsize){bin[i&gt;&gt;5]|=(str.charCodeAt(i/charsize)&amp;mask)&lt;&lt;(32-charsize-(i % 32));}
					return bin;}
					function binb2hex(binarray){var hex_tab=&apos;0123456789abcdef&apos;;var str=&apos;&apos;;var length=binarray.length*4;var srcByte;for(var i=0;i&lt;length;i+=1){srcByte=binarray[i&gt;&gt;2]&gt;&gt;((3-(i % 4))*8);str+=hex_tab.charAt((srcByte&gt;&gt;4)&amp;0xF)+hex_tab.charAt(srcByte&amp;0xF);}
					return str;}
					function safe_add_2(x,y){var lsw,msw,lowOrder,highOrder;lsw=(x.lowOrder&amp;0xFFFF)+(y.lowOrder&amp;0xFFFF);msw=(x.lowOrder&gt;&gt;&gt;16)+(y.lowOrder&gt;&gt;&gt;16)+(lsw&gt;&gt;&gt;16);lowOrder=((msw&amp;0xFFFF)&lt;&lt;16)|(lsw&amp;0xFFFF);lsw=(x.highOrder&amp;0xFFFF)+(y.highOrder&amp;0xFFFF)+(msw&gt;&gt;&gt;16);msw=(x.highOrder&gt;&gt;&gt;16)+(y.highOrder&gt;&gt;&gt;16)+(lsw&gt;&gt;&gt;16);highOrder=((msw&amp;0xFFFF)&lt;&lt;16)|(lsw&amp;0xFFFF);return new int64(highOrder,lowOrder);}
					function safe_add_4(a,b,c,d){var lsw,msw,lowOrder,highOrder;lsw=(a.lowOrder&amp;0xFFFF)+(b.lowOrder&amp;0xFFFF)+(c.lowOrder&amp;0xFFFF)+(d.lowOrder&amp;0xFFFF);msw=(a.lowOrder&gt;&gt;&gt;16)+(b.lowOrder&gt;&gt;&gt;16)+(c.lowOrder&gt;&gt;&gt;16)+(d.lowOrder&gt;&gt;&gt;16)+(lsw&gt;&gt;&gt;16);lowOrder=((msw&amp;0xFFFF)&lt;&lt;16)|(lsw&amp;0xFFFF);lsw=(a.highOrder&amp;0xFFFF)+(b.highOrder&amp;0xFFFF)+(c.highOrder&amp;0xFFFF)+(d.highOrder&amp;0xFFFF)+(msw&gt;&gt;&gt;16);msw=(a.highOrder&gt;&gt;&gt;16)+(b.highOrder&gt;&gt;&gt;16)+(c.highOrder&gt;&gt;&gt;16)+(d.highOrder&gt;&gt;&gt;16)+(lsw&gt;&gt;&gt;16);highOrder=((msw&amp;0xFFFF)&lt;&lt;16)|(lsw&amp;0xFFFF);return new int64(highOrder,lowOrder);}
					function safe_add_5(a,b,c,d,e){var lsw,msw,lowOrder,highOrder;lsw=(a.lowOrder&amp;0xFFFF)+(b.lowOrder&amp;0xFFFF)+(c.lowOrder&amp;0xFFFF)+(d.lowOrder&amp;0xFFFF)+(e.lowOrder&amp;0xFFFF);msw=(a.lowOrder&gt;&gt;&gt;16)+(b.lowOrder&gt;&gt;&gt;16)+(c.lowOrder&gt;&gt;&gt;16)+(d.lowOrder&gt;&gt;&gt;16)+(e.lowOrder&gt;&gt;&gt;16)+(lsw&gt;&gt;&gt;16);lowOrder=((msw&amp;0xFFFF)&lt;&lt;16)|(lsw&amp;0xFFFF);lsw=(a.highOrder&amp;0xFFFF)+(b.highOrder&amp;0xFFFF)+(c.highOrder&amp;0xFFFF)+(d.highOrder&amp;0xFFFF)+(e.highOrder&amp;0xFFFF)+(msw&gt;&gt;&gt;16);msw=(a.highOrder&gt;&gt;&gt;16)+(b.highOrder&gt;&gt;&gt;16)+(c.highOrder&gt;&gt;&gt;16)+(d.highOrder&gt;&gt;&gt;16)+(e.highOrder&gt;&gt;&gt;16)+(lsw&gt;&gt;&gt;16);highOrder=((msw&amp;0xFFFF)&lt;&lt;16)|(lsw&amp;0xFFFF);return new int64(highOrder,lowOrder);}
					function maj(x,y,z){return new int64((x.highOrder&amp;y.highOrder)^(x.highOrder&amp;z.highOrder)^(y.highOrder&amp;z.highOrder),(x.lowOrder&amp;y.lowOrder)^(x.lowOrder&amp;z.lowOrder)^(y.lowOrder&amp;z.lowOrder));}
					function ch(x,y,z){return new int64((x.highOrder&amp;y.highOrder)^(~x.highOrder&amp;z.highOrder),(x.lowOrder&amp;y.lowOrder)^(~x.lowOrder&amp;z.lowOrder));}
					function rotr(x,n){if(n&lt;=32){return new int64((x.highOrder&gt;&gt;&gt;n)|(x.lowOrder&lt;&lt;(32-n)),(x.lowOrder&gt;&gt;&gt;n)|(x.highOrder&lt;&lt;(32-n)));}else{return new int64((x.lowOrder&gt;&gt;&gt;n)|(x.highOrder&lt;&lt;(32-n)),(x.highOrder&gt;&gt;&gt;n)|(x.lowOrder&lt;&lt;(32-n)));}}
					function sigma0(x){var rotr28=rotr(x,28);var rotr34=rotr(x,34);var rotr39=rotr(x,39);return new int64(rotr28.highOrder^rotr34.highOrder^rotr39.highOrder,rotr28.lowOrder^rotr34.lowOrder^rotr39.lowOrder);}
					function sigma1(x){var rotr14=rotr(x,14);var rotr18=rotr(x,18);var rotr41=rotr(x,41);return new int64(rotr14.highOrder^rotr18.highOrder^rotr41.highOrder,rotr14.lowOrder^rotr18.lowOrder^rotr41.lowOrder);}
					function gamma0(x){var rotr1=rotr(x,1),rotr8=rotr(x,8),shr7=shr(x,7);return new int64(rotr1.highOrder^rotr8.highOrder^shr7.highOrder,rotr1.lowOrder^rotr8.lowOrder^shr7.lowOrder);}
					function gamma1(x){var rotr19=rotr(x,19);var rotr61=rotr(x,61);var shr6=shr(x,6);return new int64(rotr19.highOrder^rotr61.highOrder^shr6.highOrder,rotr19.lowOrder^rotr61.lowOrder^shr6.lowOrder);}
					function shr(x,n){if(n&lt;=32){return new int64(x.highOrder&gt;&gt;&gt;n,x.lowOrder&gt;&gt;&gt;n|(x.highOrder&lt;&lt;(32-n)));}else{return new int64(0,x.highOrder&lt;&lt;(32-n));}}
					str=utf8_encode(str);strlen=str.length*charsize;str=str2binb(str);str[strlen&gt;&gt;5]|=0x80&lt;&lt;(24-strlen % 32);str[(((strlen+128)&gt;&gt;10)&lt;&lt;5)+31]=strlen;for(var i=0;i&lt;str.length;i+=32){a=H[0];b=H[1];c=H[2];d=H[3];e=H[4];f=H[5];g=H[6];h=H[7];for(var j=0;j&lt;80;j++){if(j&lt;16){W[j]=new int64(str[j*2+i],str[j*2+i+1]);}else{W[j]=safe_add_4(gamma1(W[j-2]),W[j-7],gamma0(W[j-15]),W[j-16]);}
					T1=safe_add_5(h,sigma1(e),ch(e,f,g),K[j],W[j]);T2=safe_add_2(sigma0(a),maj(a,b,c));h=g;g=f;f=e;e=safe_add_2(d,T1);d=c;c=b;b=a;a=safe_add_2(T1,T2);}
					H[0]=safe_add_2(a,H[0]);H[1]=safe_add_2(b,H[1]);H[2]=safe_add_2(c,H[2]);H[3]=safe_add_2(d,H[3]);H[4]=safe_add_2(e,H[4]);H[5]=safe_add_2(f,H[5]);H[6]=safe_add_2(g,H[6]);H[7]=safe_add_2(h,H[7]);}
					var binarray=[];for(var i=0;i&lt;H.length;i++){binarray.push(H[i].highOrder);binarray.push(H[i].lowOrder);}
					return binb2hex(binarray);
					}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>0f13282b-f96d-487f-9bf6-d1318a027c7b</id>
            <name>getAuthToken</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522847450</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {String} arg1 - arg1 description
					@return {String} return description
					*/
					function getAuthToken(username,password,url) {
					// TODO: Enter code here
					logger.info(&quot;[Get Auth Token] : Going to get Token via API &quot;)
					try {
					var loginUrl =globalMap.get(&quot;publicUrl&quot;) +  JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).login_url
					var json_data = {}
					if(username &amp;&amp; password){
					json_data.username = username
					json_data.password = password
					}else{
					json_data.username=configurationMap.get(&apos;username&apos;)
					json_data.password=configurationMap.get(&apos;password&apos;)
					}

					var attr= new java.util.HashMap()
					if(url){

					attr.put(&apos;url&apos;,url)
					}else{
					attr.put(&quot;url&quot;,loginUrl)

					}

					// attr.put(&quot;url&quot;,configurationMap.get(&apos;login_url&apos;))
					var login_response = apiRequest(&apos;POST&apos;,json_data,attr)
					logger.info(&quot;Auth login response x-auth-token generated ====== &quot;+ login_response);
					var res = JSON.parse(login_response);
					logger.info(&quot;Auth token Generated :&quot;+ res.token);
					return res.token
					}catch(e){
					logger.error(&apos;Exception Occured while Getting api token&apos;+e)
					}
					}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>6daa90fc-922b-459c-bb64-f9c3e7c19528</id>
            <name>getCountryCodePrefix</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522845445</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function getCountryCodePrefix(countryCode) {
					if(countryCode.startsWith(&quot;+&quot;) == false){
					countryCode  = &quot;+&quot; + countryCode
					}

					return countryCode
					}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>8d5f64c5-0f5b-402a-9ce7-2c6e49e29b9f</id>
            <name>MongoGlobalService</name>
            <revision>8</revision>
            <lastModified>
              <time>1676358819796</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {Any} action - getMongoNextId, update, insert, delete, getMongoCon, search
					@param {Any} requestMap - colletcionName and other parameters
					@param {Any} mongoCon - mongoCon if exist otherwise null
					@return {Map} return Return the Response in form of Map
					*/
					function MongoGlobalService(action, requestMap, mongoCon) {
					var result = {}; //It will return the response as the method call.

					//Function to get the new/existing mongo connection
					logger.info(&quot;Inside MongoGlobalService with action &quot;+action+&quot; ,requestMap=&quot;+JSON.stringify(requestMap));
					if(requestMap.find){
						logger.info(&quot;inside 1st if of code template&quot;)
					logger.info(&quot;FIND QUERY : &quot;+requestMap.find)
					}
					if((mongoCon == undefined) || (mongoCon == null) || (action &amp;&amp; action == &quot;getMongoCon&quot;))
					{logger.info(&quot;inside 2nd if of code template&quot;)
					mongoCon = globalMap.get(&apos;mongoClient&apos;);
					if(!mongoCon || mongoCon == null || mongoCon == undefined || (action &amp;&amp; action == &quot;getMongoCon&quot;))
					{logger.info(&quot;inside 3rd if of code template&quot;)
						
					mongoCon = getMongoConnection();
					logger.info(&quot;printing logger for mongocon&quot;+mongocon)
					}
					if(action &amp;&amp; action == &quot;getMongoCon&quot;)
					{
					result.mongoCon = mongoCon;
					}
					}
					//Action to get newSequenceNumber from counter collection or other collection if defined.
					if(action &amp;&amp; action == &quot;getMongoNextId&quot;)
					{
					result.next_id = getMongoNextId(requestMap, mongoCon);
					}

					//Action to  insert data in collection
					if(action &amp;&amp; action == &quot;insert&quot;)
					{
					result = insertData(requestMap, mongoCon);
					}
					//Action to update  data in collection
					if(action &amp;&amp; action == &quot;update&quot;)
					{
					result = updateData(requestMap, mongoCon);
					}
					//Action to search/find data from database
					if(action &amp;&amp; action == &quot;search&quot;)
					{
					result = searchData(requestMap, mongoCon);
					}

					//Action to search/find data from database
					if(action &amp;&amp; action == &quot;delete&quot;)
					{
					result = deleteData(requestMap, mongoCon);
					}
					return result;
					}

					function getMongoNextId(requestMap, mongoCon)
					{
					var collectionName = requestMap.collectionName;
					var finalCollection = &quot;&quot;;
					var nextIdType = 	requestMap.nextIdType;  //It could be custom(using counter) or domain(using collection.next_id)
					var customCounterCollection = &quot;counters&quot;  //Default use for customIdGenerator
					var nextIdName = &quot;seq&quot;;
					if(requestMap.customCounterCollection)
					{
					customCounterCollection = requestMap.customCounterCollection;
					}
					if(nextIdType == &quot;domain&quot;)
					{
					finalCollection = collectionName+&quot;.next_id&quot;;
					nextIdName = &quot;next_id&quot;;
					}
					else
					{
					finalCollection = 	customCounterCollection;
					}
					var collection1 = mongoCon.getDB(configurationMap.get(&apos;mongoDBName&apos;)).getCollection(finalCollection);
					var cursor1;
					var result = &quot;&quot;;
					var updateObj = new Packages.com.mongodb.BasicDBObject();
					var find = new Packages.com.mongodb.BasicDBObject();
					find.put(&quot;_id&quot;, collectionName);
					updateObj.put(&quot;$inc&quot;, new Packages.com.mongodb.BasicDBObject(nextIdName,1));
					cursor1 = collection1.findAndModify(find, null, null, false, updateObj, true, true);
					result = cursor1.get(nextIdName);
					return result+&quot;&quot;
					}

					function insertData(requestMap, mongoCon)  //Should contains requestMap.document as mongo document object Map
					{
					var collection1 = mongoCon.getDB(configurationMap.get(&apos;mongoDBName&apos;)).getCollection(requestMap.collectionName);
					var cursor1;
					var result = {};
					cursor1 = collection1.insert(new Packages.com.mongodb.BasicDBObject(requestMap.document));
					result.success = &quot;OK&quot;;
					result.message = cursor1;
					return result;
					}

					//Update data with requestMap.find, requestMap.document and requestMap.multi
					function updateData(requestMap, mongoCon)  //Should contains requestMap.document as mongo document object Map
					{
					var collection1 = mongoCon.getDB(configurationMap.get(&apos;mongoDBName&apos;)).getCollection(requestMap.collectionName);
					var cursor1;
					var result = {};
					var findObj = requestMap.find //It Should be mongo DB Object
					var multi = (requestMap.multi) ? requestMap.multi : false //It should be boolean
					var updateObj = new Packages.com.mongodb.BasicDBObject();
					updateObj.put(&quot;$set&quot;, new Packages.com.mongodb.BasicDBObject(requestMap.document));
					cursor1 = collection1.update(findObj, updateObj, false,multi);
					result.success = &quot;OK&quot;;
					result.message = cursor1;
					return result;
					}
					//Search/find data with requestMap.find, requestMap.limit and  requestMap.sort
					function searchData(requestMap, mongoCon)
					{
					logger.info(&quot;mongoCon in search Data &quot;+mongoCon);
					var collection1 = mongoCon.getDB(configurationMap.get(&apos;mongoDBName&apos;)).getCollection(requestMap.collectionName);
					logger.info(&quot;collection1 &quot;+collection1);
					var cursor1;
					var result = {};
					var findObj = requestMap.find //It Should be mongo DB Object
					var limit = (requestMap.limit) ? requestMap.limit : &quot;0&quot; //It should be String
					var sort = (requestMap.sort) ? requestMap.sort : new Packages.com.mongodb.BasicDBObject();

					cursor1 = collection1.find(findObj).sort(sort).limit(parseInt(limit));
					logger.info(&quot;search Result &quot;+cursor1);
					result.success = &quot;OK&quot;;
					result.message = cursor1;
					result.totalCount = cursor1.count();
					return result;
					}
					//Delete data with requestMap.find
					function deleteData(requestMap, mongoCon)
					{
					var collection1 = mongoCon.getDB(configurationMap.get(&apos;mongoDBName&apos;)).getCollection(requestMap.collectionName);
					var cursor1;
					var result = {};
					var findObj = requestMap.find //It Should be mongo DB Object

					cursor1 = collection1.remove(findObj);
					result.success = &quot;OK&quot;;
					result.message = cursor1;
					return result;
					}
					function getMongoConnection()
					{
					var mongoIp = configurationMap.get(&apos;mongoIP&apos;)
					var mongoPort = configurationMap.get(&apos;mongoPort&apos;)
					var mongoDbName = configurationMap.get(&apos;mongoDBName&apos;)
					var mongoUsername = configurationMap.get(&apos;mongoUsername&apos;)
					var mongoPassword = configurationMap.get(&apos;mongoPassword&apos;)
					var connectionsPerHost = parseInt(configurationMap.get(&apos;connectionsPerHost&apos;))
					var mongoClient

					if (!mongoClient || mongoClient == null) {
					var options = Packages.com.mongodb.MongoClientOptions.builder()
					.connectionsPerHost(connectionsPerHost)
					.build();

					var sa = new Packages.com.mongodb.ServerAddress(mongoIp, parseInt(mongoPort));

					if (mongoUsername &amp;&amp; mongoPassword) {
					var mongoCredentialList = new java.util.ArrayList();

					mongoCredentialList.add(Packages.com.mongodb.MongoCredential.createCredential(mongoUsername, mongoDbName, mongoPassword.toCharArray()));

					globalMap.put(&apos;mongoClient&apos;,new Packages.com.mongodb.MongoClient(sa, mongoCredentialList, options))

					} else {
					globalMap.put(&apos;mongoClient&apos;,new Packages.com.mongodb.MongoClient(sa, options))

					}
					} else {
					globalMap.put(&apos;mongoClient&apos;,mongoClient);
					}

					mongoClient = globalMap.get(&apos;mongoClient&apos;)
					return mongoClient
					}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>5b63c5bd-ec5e-4f2a-9076-0f67461d9987</id>
            <name>searchDataFromCollection</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522846128</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {String} arg1 - arg1 description
					@return {String} return description
					*/
					function searchDataFromCollection(queryMap,collectionName) {
					// TODO: Enter code here
					logger.info(&quot;[User Group] : Inside Search Function &quot;+queryMap+&quot;============collectionName===&quot;+collectionName)
					logger.info(&quot;Query Object is &quot;+queryMap)
					var requestMap={};
					requestMap.collectionName=collectionName;
					requestMap.find=new Packages.com.mongodb.BasicDBObject(queryMap);
					logger.info(&quot;Search Map Created : &quot;+ requestMap);
					var searchResponse=MongoGlobalService(&quot;search&quot;,requestMap);
					logger.info(&quot;====Search Map Cursor is :&quot;+ JSON.stringify(searchResponse));
					logger.info(&quot;Count for this query is :&quot;+ searchResponse.totalCount)
					logger.info(&quot;Search Map response  is : &quot;+ searchResponse.success);
					return searchResponse;

					}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>0fdbf9cd-63ef-4695-9c12-63eabeff662f</id>
            <name>sendEmailNotification</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522846372</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {String} arg1 - arg1 description
					@return {String} return description
					*/
					function sendEmailNotification(requestMap) {
					// TODO: Enter code here
					logger.info(&quot;[Send Email Notiification] :  Inside Send Email Notification Function&quot; )
					try {
					var notificationSaveUrl = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).notificationCreateUrl
					var logoUrl = globalMap.get(&quot;publicUrl&quot;) + JSON.parse(configurationMap.get(&apos;apiInformation&apos;)).logoUrl
					//  var emailContent = JSON.parse(configurationMap.get(&apos;notificationInfo&apos;)).emailBody.replace(/USERNAME/g,requestMap.get(&apos;username&apos;)).replace(/PASSWORD/g,requestMap.get(&apos;password&apos;))
					var keyVariables ={}
					var messageVariable = {};
					//    var subjectVariables = new java.util.HashMap();
					messageVariable[&quot;&lt;userName&gt;&quot;]=requestMap.get(&apos;username&apos;);
					messageVariable[&quot;&lt;password&gt;&quot;]=requestMap.get(&apos;password&apos;);
					messageVariable[&quot;&lt;logoUrl&gt;&quot;]=logoUrl;

					keyVariables[&apos;messageVariables&apos;] = messageVariable
					//  keyVariables[&apos;subjectVariables&apos;] = subjectVariables;
					logger.info(&quot;KeyVariables Json is &quot; +keyVariables +  &quot;Message Variables are &quot; +  messageVariable)

					var notification_json_data = {
					&quot;message&quot;:&quot;notificationMessage.meethActivity.notification.email.m62&quot;,
					&quot;notificationType&quot;: &quot;email&quot;,
					&quot;overrideUserPreference&quot;: false,
					&quot;priority&quot;: &quot;INFO_MSG&quot;,
					&quot;read&quot;: false,
					&quot;recipientType&quot;: &quot;REGISTERED_USER&quot;,
					&quot;sentDate&quot;: new java.util.Date(),
					&quot;status&quot;: &quot;PENDING&quot;,
					&quot;subject&quot;:&quot;notificationSubject.meethActivity.notification.email.s62&quot;,
					// &quot;subject&quot;: JSON.parse(configurationMap.get(&apos;notificationInfo&apos;)).emailSubject,
					&quot;toEmail&quot;:requestMap.get(&apos;userEmail&apos;),
					&quot;keyVariables&quot;:keyVariables
					}

					logger.info(&quot;Notifictaion Create Json is &quot; + JSON.stringify(notification_json_data))
					var attr = new java.util.HashMap()
					attr.put(&quot;url&quot;,notificationSaveUrl)
					attr.put(&quot;token&quot;,requestMap.get(&apos;token&apos;))
					attr.put(&quot;apiInfo&quot;,configurationMap.get(&apos;apiInfo&apos;))
					var notificationRes = apiRequest(&apos;POST&apos;,notification_json_data,attr)
					return notificationRes
					} catch (e) {
					logger.error(&apos;Exception occured while sending email notification&apos;+e)
					}

					}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>fb33dad2-448f-496b-9dcf-9016fde29d9b</id>
            <name>trimListValue</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522845861</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>
function trimListValue(list) {
	logger.info(&quot;list.length : &quot;+list.length)
	for(var i=0; i&lt;list.length; i++){
		list[i] = list[i].trim()
	}
	return list
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>abb4b9e2-abbb-4030-bd8e-20e59ed4bfa1</id>
            <name>unzipFile</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522845131</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {Any} filePath -
					@return {String} return description
					*/
					function unzipFile(filePath) {
					importPackage(java.io);
					importPackage(java.util.zip);

					// Log that we are beginning to download files from the pharmacy FTP Server
					logger.info(logPrefix + &apos;Beginning unzziping of file(s)&apos;);

					// Get the directory where we want to store our unzipped files from the Global Channel Map
					var unZipDestDir = configurationMap.get(&apos;fileUnzipPath&apos;);

					// Set Buffer Size for our I/O Streams
					var bufSize = 1024;

					try {

					// If the destination directory does not exist we must create it
					var outputFolder = new java.io.File(unZipDestDir);
					if(!outputFolder.exists()) {
					outputFolder.mkdir();
					}

					// Get the raw data from the message and turn it into a ByteStream we can work with
					var strBase64Data = connectorMessage.getRawData().replaceAll(&apos;[^0-9a-zA-Z\\+\\/\\=]&apos;,&apos;&apos;);
					var decodedBytes = FileUtil.decode(strBase64Data);
					var bais = new java.io.ByteArrayInputStream(decodedBytes);

					// Load ByteStream into a ZipInputStream to decompress ZIP file(s) into individual files
					var zis = new ZipInputStream(bais);
					var ze = zis.getNextEntry();

					while(ze != null) {

					// Get the file name and output folder of the file we are currently processing
					// from the ZIP archive
					var fileName = ze.getName();
					var newFile = new File(outputFolder + File.separator + fileName);

					// We must make sure to create any folders that were contained
					// within the ZIP or we risk getting a FileNotFoundException
					new File(newFile.getParent()).mkdirs();

					var baos = new ByteArrayOutputStream();

					var length = -1;
					var data = getBlankByteArray(bufSize);
					while((length = zis.read(data, 0, bufSize)) != -1) {
					baos.write(data, 0, length);
					}

					// Write file out to the filesystem
					// Note: the 2nd param of FileUtil.write indicates whether or not to append if
					// the file exists.  Here we have set to false as we want to overwrite
					FileUtil.write(newFile, false, baos.toByteArray());

					// Log the filename to INFO
					logger.info(logPrefix + &quot;Unzipped New File: &quot; + newFile.getAbsoluteFile());

					// Clean up open resources
					baos.close();
					zis.closeEntry();

					// Continue to next file in the archive
					ze = zis.getNextEntry();

					}
					}
					catch(e){
					throw(e);
					}
					finally {
					// Clean up open resources
					zis.close();

					// Log that we have finished downloading files from the pharmacy FTP Server
					logger.info(logPrefix + &apos;Finished unzipping file(s) &apos;);
					}
					}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>ae4e0a95-97b3-4b58-b946-e2a7e0e25f83</id>
            <name>updateFirstTimePassword</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522848350</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {String} arg1 - arg1 description
					@return {String} return description
					*/
					function updateFirstTimePassword(username) {
					// TODO: Enter code here
					var queryMap = {}
					var userSearchQuery=new Packages.com.mongodb.BasicDBObject(&apos;username&apos;,username)
					queryMap.collectionName=JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userCollectionName;
					queryMap.find= userSearchQuery
					if(username.indexOf(&apos;ldap1&apos;) &gt; 0){
					queryMap.document = {
					&quot;password&quot; : &quot;$2a$10$BvOQAAgtZvMSPCM/zdtgpOwWgDq.8dgmBMHid8hXSIH9Mtj/0rrpy&quot;,
					&quot;passwordChangedTimeStamp&quot; :new Packages.java.util.Date(),
					&quot;previousPasswords&quot; : [ ],
					&quot;adminCreatedPasswordNeverChanged&quot; : false,
					&quot;lastLoginTimeStamp&quot; : new Packages.java.util.Date()
					}

					}else {
					queryMap.document = {
					&quot;password&quot; : &quot;$2a$10$BvOQAAgtZvMSPCM/zdtgpOwWgDq.8dgmBMHid8hXSIH9Mtj/0rrpy&quot;
					}
					}
					var passwordUpdate =  MongoGlobalService(&quot;update&quot;,queryMap)
					if(passwordUpdate.success === &quot;OK&quot;){
					logger.info(&quot;Password Updated Succesfully&quot;)
					}

					}</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
      <codeTemplateLibrary version="3.9.1">
        <id>34ac358b-664c-4431-a961-a2591c1d0898</id>
        <name>HL7Library</name>
        <revision>5</revision>
        <lastModified>
          <time>1676491698575</time>
          <timezone>UTC</timezone>
        </lastModified>
        <description></description>
        <includeNewChannels>true</includeNewChannels>
        <enabledChannelIds>
          <string>8ffc3435-69a9-4e3c-a7b3-d92bfe08016a</string>
          <string>5dd1cce0-fcd2-4756-900f-47b157f17690</string>
          <string>5132c870-257f-48e3-b84e-debac4e0e5a9</string>
          <string>e008e757-f101-41e7-ac81-a419eccf03e7</string>
          <string>c26500eb-4156-4b43-a728-7fc83ea66ef5</string>
          <string>c6466272-70fe-487b-9a58-d324da917123</string>
          <string>b0583467-c7c3-47c6-8b17-8aa320566e3f</string>
          <string>445eabb1-95d3-4aef-b62b-f09aca726e54</string>
          <string>7417b5c9-167d-4454-b000-938d0cfca42d</string>
          <string>7b7806be-7905-4903-a811-d9066889a438</string>
          <string>b7f713c7-9538-4fe5-8217-622ba55ac61d</string>
          <string>b9ef20c1-c6e5-4f04-b3fa-40798e5e8338</string>
          <string>4dad803b-8ae7-4ccd-8a63-f5b7ad900c34</string>
          <string>f6261a9b-8e35-45c7-bf71-eaf64d284e8c</string>
          <string>22a6ce40-6759-402c-8659-bca069ddfe01</string>
          <string>e84827ea-74b1-4f4c-a3be-96a9346be3bb</string>
          <string>e6076476-33c6-4be3-941b-bad549d0474d</string>
          <string>7bf4680d-681f-4e7c-8d10-9e46f09c6db2</string>
          <string>68aa9bb6-1660-41ce-9350-75b8346ed0b8</string>
          <string>4c4573eb-8d5e-42e3-b9b4-601cdeabc52c</string>
          <string>d3080587-4d1e-43dd-b781-ae0af20a5080</string>
          <string>21f51dff-edbd-470a-8b2b-ac699af9efdc</string>
          <string>b40ddb05-b83f-4f2f-893e-5832148a0ff0</string>
          <string>1847a579-d828-424e-8cf7-572c7d01b8e9</string>
          <string>17457ef9-620e-4483-8350-63712c280a17</string>
          <string>9e1ff5bf-d9f6-48ef-8abb-f17be6ccbaf6</string>
          <string>52813cf4-4010-4933-836f-fed56c4b3eee</string>
          <string>df92d515-874e-49c9-a657-1cc61f9c71f1</string>
          <string>4160d5f3-b0cb-460a-b251-3fe11e3b88d6</string>
          <string>e3d7e84a-4137-4309-9da8-cd0135aa4135</string>
          <string>4c6a94d2-e3ff-4a5b-bd8f-e255df225c77</string>
          <string>52d24934-4dfd-43ee-9efd-e4e5a8a31fca</string>
          <string>29c4042f-f4a3-44ba-aab6-c60c4d963d1c</string>
          <string>4909ccd0-ba5b-469d-afb3-9864e09cd468</string>
          <string>b8752714-2ffb-4c15-a27b-a1b02592f0f2</string>
          <string>063d6304-cd71-45d6-92a5-d9efbdb2fdfa</string>
        </enabledChannelIds>
        <disabledChannelIds/>
        <codeTemplates>
          <codeTemplate version="3.9.1">
            <id>f67c0fb0-4381-49ae-84d0-169159664a15</id>
            <name>ConvertDateTimeFormat</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522845619</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function ConvertDateTimeFormat(DataDateTime, pattern) {
								return DateUtil.convertDate(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;, pattern, DataDateTime);
								}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>65f604e9-7853-421e-80a8-f23035c0c14c</id>
            <name>createPIDSegment</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522846718</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function createPIDSegment(lookUpEntry, PatientTempID, msg1) {

								logger.info(&quot;Inside createPIDSegment code template&quot;);

								msg1.PID[&apos;PID.1&apos;][&apos;PID.1.1&apos;] = 1;

								if (lookUpEntry.UHID  != &apos;&apos;){
								msg1.PID[&apos;PID.2&apos;][&apos;PID.2.1&apos;] = lookUpEntry.UHID;
								msg1.PID[&apos;PID.2&apos;][&apos;PID.2.4&apos;] = lookUpEntry.UHIDIssuingAuthority;
								msg1.PID[&apos;PID.2&apos;][&apos;PID.2.5&apos;] = lookUpEntry.UHIDIdentifier;
								}

								var MIDCounter =0;

								if (lookUpEntry.MRN  != &apos;&apos;){

								var tmpPID_3_MRN = &lt;PID.3/&gt;;

								tmpPID_3_MRN[&apos;PID.3.1&apos;] = lookUpEntry.MRN;
								tmpPID_3_MRN[&apos;PID.3.4&apos;] = lookUpEntry.CompanyCode;
								tmpPID_3_MRN[&apos;PID.3.5&apos;] = lookUpEntry.MRNIdentifier;

								msg1.PID[&apos;PID.3&apos;][MIDCounter] =tmpPID_3_MRN;
								MIDCounter++;
								}

								if (PatientTempID  != &apos;&apos;){

								var tmpPID_3_TempID = &lt;PID.3/&gt;;

								tmpPID_3_TempID[&apos;PID.3.1&apos;] = PatientTempID;
								tmpPID_3_TempID[&apos;PID.3.4&apos;] = lookUpEntry.TempIDIssuingAuthority;
								tmpPID_3_TempID[&apos;PID.3.5&apos;] = lookUpEntry.TempIDIdentifier;

								msg1.PID[&apos;PID.3&apos;][MIDCounter] =tmpPID_3_TempID;
								MIDCounter++;
								}

								var NIDCounter =0;

								if (lookUpEntry.NationalIdNo  != &apos;&apos;){

								var tmpPID_4_NPI = &lt;PID.4/&gt;;

								tmpPID_4_NPI[&apos;PID.4.1&apos;] = lookUpEntry.NationalIdNo;
								tmpPID_4_NPI[&apos;PID.4.4&apos;] = lookUpEntry.NationalIdIssuingAuthority;
								tmpPID_4_NPI[&apos;PID.4.5&apos;] = lookUpEntry.NationalIdIdentifier;
								tmpPID_4_NPI[&apos;PID.4.7&apos;] = &apos;&apos;;
								tmpPID_4_NPI[&apos;PID.4.8&apos;] = &apos;&apos;;

								msg1.PID[&apos;PID.4&apos;][NIDCounter] =tmpPID_4_NPI;
								NIDCounter++;
								}

								if (lookUpEntry.PassportNo  != &apos;&apos;){

								var tmpPID_4_PPN = &lt;PID.4/&gt;;

								tmpPID_4_PPN[&apos;PID.4.1&apos;] = lookUpEntry.PassportNo;
								tmpPID_4_PPN[&apos;PID.4.4&apos;] = lookUpEntry.PassportIssueingAuthority;
								tmpPID_4_PPN[&apos;PID.4.5&apos;] = lookUpEntry.PassportIdentifier;
								tmpPID_4_PPN[&apos;PID.4.7&apos;] = &apos;&apos;;
								tmpPID_4_PPN[&apos;PID.4.8&apos;] = lookUpEntry.PassportExpiryDate;

								msg1.PID[&apos;PID.4&apos;][NIDCounter] =tmpPID_4_PPN;
								NIDCounter++;
								}

								var tmpPID_5 = &lt;PID.5/&gt;;

								tmpPID_5[&apos;PID.5.1&apos;] = lookUpEntry.LastName;
								tmpPID_5[&apos;PID.5.2&apos;] = lookUpEntry.FirstName;
								tmpPID_5[&apos;PID.5.3&apos;] = lookUpEntry.MiddleName;
								tmpPID_5[&apos;PID.5.4&apos;] = &apos;&apos;;
								tmpPID_5[&apos;PID.5.7&apos;] = lookUpEntry.PrimaryNameLanguage;

								msg1.PID[&apos;PID.5&apos;] = tmpPID_5;


								// TO DO - additional name support
								//var tmpPID_5 = &lt;PID.5/&gt;;

								//tmpPID_5[&apos;PID.5.1&apos;] = lookUpEntry.LastName;
								//tmpPID_5[&apos;PID.5.2&apos;] = lookUpEntry.FirstName;
								//tmpPID_5[&apos;PID.5.3&apos;] = lookUpEntry.MiddleName;
								//tmpPID_5[&apos;PID.5.4&apos;] = &apos;&apos;;
								//tmpPID_5[&apos;PID.5.7&apos;] = lookUpEntry.SecondaryNameLanguage;

								//msg1.PID[&apos;PID.5&apos;] =+ tmpPID_5;


								msg1.PID[&apos;PID.7&apos;][&apos;PID.7.1&apos;] = lookUpEntry.DOB;
								msg1.PID[&apos;PID.8&apos;][&apos;PID.8.1&apos;] = lookUpEntry.Gender;

								msg1.PID[&apos;PID.11&apos;][&apos;PID.11.1&apos;] = lookUpEntry.Street1;
								msg1.PID[&apos;PID.11&apos;][&apos;PID.11.2&apos;] = lookUpEntry.Street2;
								msg1.PID[&apos;PID.11&apos;][&apos;PID.11.3&apos;] = lookUpEntry.City;
								msg1.PID[&apos;PID.11&apos;][&apos;PID.11.4&apos;] = lookUpEntry.StateName;
								msg1.PID[&apos;PID.11&apos;][&apos;PID.11.5&apos;] = lookUpEntry.Postcode;
								msg1.PID[&apos;PID.11&apos;][&apos;PID.11.6&apos;] = lookUpEntry.CountryName;


								var CNCounter =0;

								if (lookUpEntry.HomePhone  != &apos;&apos;){
								var tmpPID_13_HP = &lt;PID.13/&gt;;

								tmpPID_13_HP[&apos;PID.13.1&apos;] = lookUpEntry.HomePhone;
								tmpPID_13_HP[&apos;PID.13.3&apos;] = &apos;PH&apos;
								tmpPID_13_HP[&apos;PID.13.5&apos;] = &apos;&apos;;

								msg1.PID[&apos;PID.13&apos;][CNCounter] = tmpPID_13_HP;
								CNCounter++;
								}


								if (lookUpEntry.MobilePhone  != &apos;&apos;){
								var tmpPID_13_MP = &lt;PID.13/&gt;;

								tmpPID_13_MP[&apos;PID.13.1&apos;] = lookUpEntry.MobilePhone;
								tmpPID_13_MP[&apos;PID.13.3&apos;] = &apos;CP&apos;
								tmpPID_13_MP[&apos;PID.13.5&apos;] = &apos;&apos;;

								msg1.PID[&apos;PID.13&apos;][CNCounter] = tmpPID_13_MP;
								CNCounter++;
								}


								if (lookUpEntry.MobilePhone  != &apos;&apos;){
								var tmpPID_13_EM = &lt;PID.13/&gt;;

								tmpPID_13_EM[&apos;PID.13.1&apos;] = &apos;&apos;
								tmpPID_13_EM[&apos;PID.13.3&apos;] = &apos;Internet&apos;
								tmpPID_13_EM[&apos;PID.13.4&apos;] = lookUpEntry.Email;

								msg1.PID[&apos;PID.13&apos;][CNCounter] = tmpPID_13_EM;
								CNCounter++;
								}



								msg1.PID[&apos;PID.14&apos;][&apos;PID.14.1&apos;] = lookUpEntry.OfficePhone;
								msg1.PID[&apos;PID.14&apos;][&apos;PID.14.3&apos;] = &apos;PH&apos;;
								msg1.PID[&apos;PID.14&apos;][&apos;PID.14.5&apos;] = &apos;&apos;


								msg1.PID[&apos;PID.16&apos;][&apos;PID.16.1&apos;] = lookUpEntry.MaritialStatus;
								msg1.PID[&apos;PID.28&apos;][&apos;PID.28.1&apos;] = lookUpEntry.Nationality;

								if (lookUpEntry.IsDeceased == &apos;Y&apos;){
								msg1.PID[&apos;PID.29&apos;][&apos;PID.29.1&apos;] = DateUtil.convertDate(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;, &quot;yyyyMMddHHmmss&quot;, lookUpEntry.DeathDateTime);
								msg1.PID[&apos;PID.30&apos;][&apos;PID.30.1&apos;] = lookUpEntry.IsDeceased;
								}else{
								msg1.PID[&apos;PID.29&apos;][&apos;PID.29.1&apos;] = &apos;&apos;;
								msg1.PID[&apos;PID.30&apos;][&apos;PID.30.1&apos;] = &apos;N&apos;;
								}

								logger.info(&quot;Returning the created PID as: &quot;+msg1);
								return msg1;
								}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>9c981900-5338-49e4-b851-0bac62c64380</id>
            <name>createPV1Segment</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522848004</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function createPV1Segment(lookUpEntry, msg1) {

								logger.info(&quot;Inside createPV1Segment code template&quot;);

								var dbConn;
								var result;

								var CA_RPT_URL = configurationMap.get(&apos;CA_RPT_URL&apos;);
								var CA_RPT_User = configurationMap.get(&apos;CA_RPT_User&apos;);
								var CA_RPT_Pass = configurationMap.get(&apos;CA_RPT_Pass&apos;);

								msg1.PV1[&apos;PV1.1&apos;][&apos;PV1.1.1&apos;] = 1;
								msg1.PV1[&apos;PV1.2&apos;][&apos;PV1.2.1&apos;] = lookUpEntry.ChargeType;

								try{

								dbConn = DatabaseConnectionFactory.createDatabaseConnection(&apos;net.sourceforge.jtds.jdbc.Driver&apos;, CA_RPT_URL, CA_RPT_User, CA_RPT_Pass);
								logger.info(&apos;dbConn =&gt; &apos; + dbConn);

								query = &quot;EXEC MV_ADT_A01_usp_AttendingDocDetail_Get &apos;&quot; + lookUpEntry.MRN + &quot;&apos;,&apos;&quot; + lookUpEntry.VisitNumber + &quot;&apos;&quot;;
								logger.info(&quot;Query is: &quot;+query);

								result = dbConn.executeCachedQuery(query);

								var atd_count = 0;

								while (result.next()) {

								lookUpEntry.AtdDoctorID 			= result.getString(&apos;AtdDoctorID&apos;);
								lookUpEntry.AtdDocName			= result.getString(&apos;AtdDocName&apos;);
								lookUpEntry.AtdIssueingAuthority	= result.getString(&apos;AtdIssueingAuthority&apos;);

								// all registrered docs for the patient

								logger.info(&apos;createSegment =&gt; PV1.7 count=&apos; + atd_count);
								var tmpPV1_7 = &lt;PV1.7/&gt;;

								tmpPV1_7[&apos;PV1.7.1&apos;] = lookUpEntry.AtdDoctorID;
								tmpPV1_7[&apos;PV1.7.2&apos;] = &apos;&apos;;
								tmpPV1_7[&apos;PV1.7.3&apos;] = lookUpEntry.AtdDocName;
								tmpPV1_7[&apos;PV1.7.4&apos;] = &apos;&apos;;
								tmpPV1_7[&apos;PV1.7.6&apos;] = &apos;&apos;;
								tmpPV1_7[&apos;PV1.7.9&apos;] = lookUpEntry.AtdIssueingAuthority;
								tmpPV1_7[&apos;PV1.7.13&apos;] = lookUpEntry.DocIdentifierTypeCode ;

								msg1.PV1[&apos;PV1.7&apos;][atd_count] = tmpPV1_7;
								atd_count++;
								&#xd;
								}
								}catch(e){
								logger.error(e);
								} finally {
								if (result) {
								result.close();
								}
								}

								/// 1 only - referring doc - registration table
								msg1.PV1[&apos;PV1.8&apos;][&apos;PV1.8.1&apos;] = &apos;&apos;;
								msg1.PV1[&apos;PV1.8&apos;][&apos;PV1.8.2&apos;] = &apos;&apos;;
								msg1.PV1[&apos;PV1.8&apos;][&apos;PV1.8.3&apos;] = lookUpEntry.RefDocName;
								msg1.PV1[&apos;PV1.8&apos;][&apos;PV1.8.4&apos;] = &apos;&apos;;
								msg1.PV1[&apos;PV1.8&apos;][&apos;PV1.8.6&apos;] = &apos;&apos;;
								msg1.PV1[&apos;PV1.8&apos;][&apos;PV1.8.9&apos;] = &apos;&apos;;
								msg1.PV1[&apos;PV1.8&apos;][&apos;PV1.8.13&apos;] = &apos;&apos;;

								//blank
								msg1.PV1[&apos;PV1.9&apos;][&apos;PV1.9.1&apos;] = &apos;&apos;;
								msg1.PV1[&apos;PV1.9&apos;][&apos;PV1.9.2&apos;] = &apos;&apos;;
								msg1.PV1[&apos;PV1.9&apos;][&apos;PV1.9.3&apos;] = &apos;&apos;;
								msg1.PV1[&apos;PV1.9&apos;][&apos;PV1.9.4&apos;] = &apos;&apos;;
								msg1.PV1[&apos;PV1.9&apos;][&apos;PV1.9.6&apos;] = &apos;&apos;;
								msg1.PV1[&apos;PV1.9&apos;][&apos;PV1.9.9&apos;] = &apos;&apos;;
								msg1.PV1[&apos;PV1.9&apos;][&apos;PV1.9.13&apos;] = &apos;&apos;;

								// 1 only - primary doc
								msg1.PV1[&apos;PV1.17&apos;][&apos;PV1.17.1&apos;] = lookUpEntry.PrimaryDocID;
								msg1.PV1[&apos;PV1.17&apos;][&apos;PV1.17.2&apos;] = &apos;&apos;;
								msg1.PV1[&apos;PV1.17&apos;][&apos;PV1.17.3&apos;] = lookUpEntry.PrimaryDocName;
								msg1.PV1[&apos;PV1.17&apos;][&apos;PV1.17.4&apos;] = &apos;&apos;;
								msg1.PV1[&apos;PV1.17&apos;][&apos;PV1.17.6&apos;] = &apos;&apos;;
								msg1.PV1[&apos;PV1.17&apos;][&apos;PV1.17.9&apos;] = lookUpEntry.DocIssueingAuthority;
								msg1.PV1[&apos;PV1.17&apos;][&apos;PV1.17.13&apos;] = lookUpEntry.DocIdentifierTypeCode ;

								msg1.PV1[&apos;PV1.19&apos;][&apos;PV1.19.1&apos;] = lookUpEntry.VisitNumber;

								msg1.PV1[&apos;PV1.44&apos;][&apos;PV1.44.1&apos;] =DateUtil.convertDate(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;, &quot;yyyyMMddHHmmss&quot;, lookUpEntry.AdmissionDate);
								if (lookUpEntry.IsPatientDischarged ==&apos;Y&apos;)
								{
								msg1.PV1[&apos;PV1.45&apos;][&apos;PV1.45.1&apos;] =DateUtil.convertDate(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;, &quot;yyyyMMddHHmmss&quot;, lookUpEntry.DischargeDate);
								}

								logger.info(&quot;Returning the created PV1 as: &quot;+msg1);
								return msg1;
								}</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
      <codeTemplateLibrary version="3.9.1">
        <id>3f3fb9f6-c357-47e8-ba9f-3e0f6e1d78fd</id>
        <name>Library 1</name>
        <revision>1</revision>
        <lastModified>
          <time>1678190895063</time>
          <timezone>UTC</timezone>
        </lastModified>
        <description></description>
        <includeNewChannels>false</includeNewChannels>
        <enabledChannelIds>
          <string>5dd1cce0-fcd2-4756-900f-47b157f17690</string>
          <string>f6261a9b-8e35-45c7-bf71-eaf64d284e8c</string>
          <string>e84827ea-74b1-4f4c-a3be-96a9346be3bb</string>
        </enabledChannelIds>
        <disabledChannelIds/>
        <codeTemplates>
          <codeTemplate version="3.9.1">
            <id>d000c5d8-61e6-4bee-8016-42c842b21c8f</id>
            <name>MongoGlobalService</name>
            <revision>1</revision>
            <lastModified>
              <time>1678190895099</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
					Modify the description here. Modify the function name and parameters as needed. One function per
					template is recommended; create a new code template for each new function.

					@param {Any} action - getMongoNextId, update, insert, delete, getMongoCon, search
					@param {Any} requestMap - colletcionName and other parameters
					@param {Any} mongoCon - mongoCon if exist otherwise null
					@return {Map} return Return the Response in form of Map
					*/
					function MongoGlobalService(action, requestMap, mongoCon) {
					var result = {}; //It will return the response as the method call.

					//Function to get the new/existing mongo connection
					logger.info(&quot;Inside MongoGlobalService with action &quot;+action+&quot; ,requestMap=&quot;+JSON.stringify(requestMap));
					if(requestMap.find){
						logger.info(&quot;inside 1st if of code template&quot;)
					logger.info(&quot;FIND QUERY : &quot;+requestMap.find)
					}
					if((mongoCon == undefined) || (mongoCon == null) || (action &amp;&amp; action == &quot;getMongoCon&quot;))
					{logger.info(&quot;inside 2nd if of code template&quot;)
					mongoCon = globalMap.get(&apos;mongoClient&apos;);
					if(!mongoCon || mongoCon == null || mongoCon == undefined || (action &amp;&amp; action == &quot;getMongoCon&quot;))
					{logger.info(&quot;inside 3rd if of code template&quot;)
						
					mongoCon = getMongoConnection();
					logger.info(&quot;printing logger for mongocon&quot;+mongocon)
					}
					if(action &amp;&amp; action == &quot;getMongoCon&quot;)
					{
					result.mongoCon = mongoCon;
					}
					}
					//Action to get newSequenceNumber from counter collection or other collection if defined.
					if(action &amp;&amp; action == &quot;getMongoNextId&quot;)
					{
					result.next_id = getMongoNextId(requestMap, mongoCon);
					}

					//Action to  insert data in collection
					if(action &amp;&amp; action == &quot;insert&quot;)
					{
					result = insertData(requestMap, mongoCon);
					}
					//Action to update  data in collection
					if(action &amp;&amp; action == &quot;update&quot;)
					{
					result = updateData(requestMap, mongoCon);
					}
					//Action to search/find data from database
					if(action &amp;&amp; action == &quot;search&quot;)
					{
					result = searchData(requestMap, mongoCon);
					}

					//Action to search/find data from database
					if(action &amp;&amp; action == &quot;delete&quot;)
					{
					result = deleteData(requestMap, mongoCon);
					}
					return result;
					}

					function getMongoNextId(requestMap, mongoCon)
					{
					var collectionName = requestMap.collectionName;
					var finalCollection = &quot;&quot;;
					var nextIdType = 	requestMap.nextIdType;  //It could be custom(using counter) or domain(using collection.next_id)
					var customCounterCollection = &quot;counters&quot;  //Default use for customIdGenerator
					var nextIdName = &quot;seq&quot;;
					if(requestMap.customCounterCollection)
					{
					customCounterCollection = requestMap.customCounterCollection;
					}
					if(nextIdType == &quot;domain&quot;)
					{
					finalCollection = collectionName+&quot;.next_id&quot;;
					nextIdName = &quot;next_id&quot;;
					}
					else
					{
					finalCollection = 	customCounterCollection;
					}
					var collection1 = mongoCon.getDB(configurationMap.get(&apos;mongoDBName&apos;)).getCollection(finalCollection);
					var cursor1;
					var result = &quot;&quot;;
					var updateObj = new Packages.com.mongodb.BasicDBObject();
					var find = new Packages.com.mongodb.BasicDBObject();
					find.put(&quot;_id&quot;, collectionName);
					updateObj.put(&quot;$inc&quot;, new Packages.com.mongodb.BasicDBObject(nextIdName,1));
					cursor1 = collection1.findAndModify(find, null, null, false, updateObj, true, true);
					result = cursor1.get(nextIdName);
					return result+&quot;&quot;
					}

					function insertData(requestMap, mongoCon)  //Should contains requestMap.document as mongo document object Map
					{
					var collection1 = mongoCon.getDB(configurationMap.get(&apos;mongoDBName&apos;)).getCollection(requestMap.collectionName);
					var cursor1;
					var result = {};
					cursor1 = collection1.insert(new Packages.com.mongodb.BasicDBObject(requestMap.document));
					result.success = &quot;OK&quot;;
					result.message = cursor1;
					return result;
					}

					//Update data with requestMap.find, requestMap.document and requestMap.multi
					function updateData(requestMap, mongoCon)  //Should contains requestMap.document as mongo document object Map
					{
					var collection1 = mongoCon.getDB(configurationMap.get(&apos;mongoDBName&apos;)).getCollection(requestMap.collectionName);
					var cursor1;
					var result = {};
					var findObj = requestMap.find //It Should be mongo DB Object
					var multi = (requestMap.multi) ? requestMap.multi : false //It should be boolean
					var updateObj = new Packages.com.mongodb.BasicDBObject();
					updateObj.put(&quot;$set&quot;, new Packages.com.mongodb.BasicDBObject(requestMap.document));
					cursor1 = collection1.update(findObj, updateObj, false,multi);
					result.success = &quot;OK&quot;;
					result.message = cursor1;
					return result;
					}
					//Search/find data with requestMap.find, requestMap.limit and  requestMap.sort
					function searchData(requestMap, mongoCon)
					{
					logger.info(&quot;mongoCon in search Data &quot;+mongoCon);
					var collection1 = mongoCon.getDB(configurationMap.get(&apos;mongoDBName&apos;)).getCollection(requestMap.collectionName);
					logger.info(&quot;collection1 &quot;+collection1);
					var cursor1;
					var result = {};
					var findObj = requestMap.find //It Should be mongo DB Object
					var limit = (requestMap.limit) ? requestMap.limit : &quot;0&quot; //It should be String
					var sort = (requestMap.sort) ? requestMap.sort : new Packages.com.mongodb.BasicDBObject();

					cursor1 = collection1.find(findObj).sort(sort).limit(parseInt(limit));
					logger.info(&quot;search Result &quot;+cursor1);
					result.success = &quot;OK&quot;;
					result.message = cursor1;
					result.totalCount = cursor1.count();
					return result;
					}
					//Delete data with requestMap.find
					function deleteData(requestMap, mongoCon)
					{
					var collection1 = mongoCon.getDB(configurationMap.get(&apos;mongoDBName&apos;)).getCollection(requestMap.collectionName);
					var cursor1;
					var result = {};
					var findObj = requestMap.find //It Should be mongo DB Object

					cursor1 = collection1.remove(findObj);
					result.success = &quot;OK&quot;;
					result.message = cursor1;
					return result;
					}
					function getMongoConnection()
					{
					var mongoIp = configurationMap.get(&apos;mongoIP&apos;)
					var mongoPort = configurationMap.get(&apos;mongoPort&apos;)
					var mongoDbName = configurationMap.get(&apos;mongoDBName&apos;)
					var mongoUsername = configurationMap.get(&apos;mongoUsername&apos;)
					var mongoPassword = configurationMap.get(&apos;mongoPassword&apos;)
					var connectionsPerHost = parseInt(configurationMap.get(&apos;connectionsPerHost&apos;))
					var mongoClient

					if (!mongoClient || mongoClient == null) {
					var options = Packages.com.mongodb.MongoClientOptions.builder()
					.connectionsPerHost(connectionsPerHost)
					.build();

					var sa = new Packages.com.mongodb.ServerAddress(mongoIp, parseInt(mongoPort));

					if (mongoUsername &amp;&amp; mongoPassword) {
					var mongoCredentialList = new java.util.ArrayList();

					mongoCredentialList.add(Packages.com.mongodb.MongoCredential.createCredential(mongoUsername, mongoDbName, mongoPassword.toCharArray()));

					globalMap.put(&apos;mongoClient&apos;,new Packages.com.mongodb.MongoClient(sa, mongoCredentialList, options))

					} else {
					globalMap.put(&apos;mongoClient&apos;,new Packages.com.mongodb.MongoClient(sa, options))

					}
					} else {
					globalMap.put(&apos;mongoClient&apos;,mongoClient);
					}

					mongoClient = globalMap.get(&apos;mongoClient&apos;)
					return mongoClient
					}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>15b14470-c1e3-41b7-a052-0edebf65c99b</id>
            <name>Template 1</name>
            <revision>1</revision>
            <lastModified>
              <time>1678190895218</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function findDataFromDB(action,requestMap,groupBy) {
					var result = null
					if(action == &quot;PRACTITIONER&quot;){
					return result = findPractitioner(requestMap,groupBy)
					}

					if(action == &quot;LOCATION&quot;){
					return result = findLocation(requestMap)
					}

					if(action == &quot;USER&quot;){
					return result = findUser(requestMap,groupBy)
					}

					if(action == &quot;USERGROUP&quot;){
					return result = findUserGroup(requestMap,groupBy)
					}

					if(action == &quot;ORGANIZATION&quot;){
					return result = findOrganization(requestMap)
					}
					if(action == &quot;ROLES&quot;){
					return result = findRoles(requestMap)
					}

					if(action==&quot;MENUITEM&quot;){
					return result = findMenuItem(requestMap)
					}

					if(action == &quot;COUNTRIESSET&quot;){
					return result = findCountriesSet(requestMap,groupBy)
					}
					
					if(action == &quot;CITIESSET&quot;){
					return result = findCitiesSet(requestMap,groupBy)
					}
					
					if(action == &quot;STATESSET&quot;){
					return result = findStatesSet(requestMap,groupBy)
					}
         
					}

function findLocation(requestMap){
  	  logger.info(&quot;Inside Find Location function With &quot; + requestMap.get(&apos;keyName&apos;))
					var locationData=null
					var queryMap ={}
					if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).locationCollectionName){
					var locationQuery= new Packages.com.mongodb.BasicDBObject(requestMap.get(&apos;keyName&apos;),requestMap.get(&apos;keyValue&apos;))
					queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).locationCollectionName
					queryMap.find = locationQuery
					locationData =MongoGlobalService(&quot;search&quot;,queryMap)
					}else{
					logger.error(&quot;Location Collection name is not defined in configurationMap&quot;)
					}

					return locationData;
					}

function findUserGroup(requestMap,groupBy){
					logger.info(&quot;Inside findUsergroup Function&quot; + requestMap)
					var userGroupSearchResponse=null
					var queryMap ={}
					if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userGroupCollectionName){
					var searchList = new Packages.java.util.ArrayList();
					for (key in requestMap){
					//logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
					searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
					}
					queryMap.collectionName=JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userGroupCollectionName;
					if(groupBy == &quot;OR&quot;){
					queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
					}else{
					queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);

					}
					userGroupCollectionName =  MongoGlobalService(&quot;search&quot;,queryMap)
					}else{
					logger.error(&quot;userGroup Collection Name is not defined in configurationMap&quot;)
					}
					return userGroupCollectionName;
					}

function findUser(requestMap,groupBy){
					logger.info(&quot;Inside Search User Function&quot; + requestMap)
					var userSearch_res=null
					var queryMap ={}
					if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userCollectionName){
					var searchList = new Packages.java.util.ArrayList();
					for (key in requestMap){
					//logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
					searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
					}
					queryMap.collectionName=JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).userCollectionName;
					if(groupBy == &quot;OR&quot;){
					queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
					}else{
					queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);

					}
					userSearch_res =  MongoGlobalService(&quot;search&quot;,queryMap)
					}else{
					logger.error(&quot;User Collection Name is not defined in configurationMap&quot;)
					}
					return userSearch_res;
					}


function findPractitioner(requestMap,groupBy){
					logger.info(&quot;Inside Find Practitioner&quot;)
					var practitionerSearchData=null
					var queryMap= {}
					if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).practitionerCollectionName){
					var searchList = new Packages.java.util.ArrayList();
					for (key in requestMap){
					//logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
					searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
					}
					queryMap.collectionName=JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).practitionerCollectionName;
					if(groupBy == &quot;OR&quot;){
					queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
					}else{
					queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);

					}

					//logger.info(&quot;FINDQUERY : &quot;+queryMap.find)
					practitionerSearchData  =  MongoGlobalService(&quot;search&quot;,queryMap)
					}else{
					logger.error(&quot;Practitioner collection Name is not defined in configurationMap&quot;)
					}

					return practitionerSearchData;

					}


function findOrganization(requestMap){
					logger.info(&quot;[Find Organization ] :  Inside getOrganization Function &quot; +requestMap.get(&apos;keyName&apos;))
					var organizationData=null
					var queryMap = {}
					if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).orgCollectionName){
					var organizationQuery=new Packages.com.mongodb.BasicDBObject(requestMap.get(&apos;keyName&apos;),requestMap.get(&apos;keyValue&apos;))
					queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).orgCollectionName;
					queryMap.find=  organizationQuery
					organizationData= MongoGlobalService(&quot;search&quot;,queryMap)

					}else{
					logger.error(&quot;Organization collectionName is not defined in configurationMap&quot;)
					}
					return organizationData;
					}


function findRoles(requestMap){
					logger.info(&quot;[Find Roles ] :  Inside findRoles Function &quot;)
					var rolesData=null
					var queryMap = {}
					if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).roleCollectionName){
					var rolesQuery = new Packages.com.mongodb.BasicDBObject(requestMap.get(&apos;keyName&apos;),requestMap.get(&apos;keyValue&apos;))
					queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).roleCollectionName;
					queryMap.find=  rolesQuery
					rolesData= MongoGlobalService(&quot;search&quot;,queryMap)

					}else{
					logger.error(&quot;Roles collectionName is not defined in configurationMap&quot;)
					}
					return rolesData
					}


function findMenuItem(requestMap){
					logger.info(&quot;[Find Roles ] :  Inside findMenuItem Function &quot;)
					var menuData=null
					var queryMap={}
					if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).menuCollectionName){
					var menuQuery = new Packages.com.mongodb.BasicDBObject(requestMap.get(&apos;keyName&apos;),requestMap.get(&apos;keyValue&apos;))
					queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).menuCollectionName;
					queryMap.find=  menuQuery
					menuData= MongoGlobalService(&quot;search&quot;, queryMap)
					}else{
					logger.error(&quot;menuItem collectionName is not defined in configurationMap&quot;)
					}
					return menuData
					}

</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>95a762a5-c732-4885-a1bd-9268087298c9</id>
            <name>Template 2</name>
            <revision>1</revision>
            <lastModified>
              <time>1678190895343</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function findCitiesSet(requestMap,groupBy){
                                logger.info(&quot;[Find CitesSet ] :  Inside findCitesSet Function &quot;)
                                var citiesSetData=null
                                var queryMap={}
                                if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).citiesSetCollectionName){
                                var searchList = new Packages.java.util.ArrayList();
                                for (key in requestMap){
                                //logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
                                searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
                                }
                                queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).citiesSetCollectionName;
								
								if(groupBy == &quot;OR&quot;){
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
                                }else{
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);
                                }
                                citiesSetData= MongoGlobalService(&quot;search&quot;, queryMap)
                                }else{
                                logger.error(&quot;CitesSet collectionName is not defined in configurationMap&quot;)
                                }
                                return citiesSetData
                                }

function findCountriesSet(requestMap,groupBy){
                                logger.info(&quot;[Find CountriesSet ] :  Inside findCountriesSet Function &quot;)
                                var countriesSetData=null
                                var queryMap={}
                                if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).countriesSetCollectionName){
                                	logger.info(&quot;inside 1st if of code template&quot;)
                                var searchList = new Packages.java.util.ArrayList();
                                for (key in requestMap){
                                //logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
                                searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
                                }
                                queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).countriesSetCollectionName;
								
								if(groupBy == &quot;OR&quot;){
									logger.info(&quot;inside 1.1 if of code template&quot;)
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
                                }else{
                                	logger.info(&quot;inside 1.1 else of code template&quot;)
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);
                                }
                                countriesSetData= MongoGlobalService(&quot;search&quot;, queryMap)
                                }else{
                                	logger.info(&quot;inside 1 else of code template&quot;)
                                logger.error(&quot;CountriesSet collectionName is not defined in configurationMap&quot;)
                                }
                                logger.info(&quot;countriesSetData - &quot;+countriesSetData)
                                return countriesSetData
                                }

function findStatesSet(requestMap,groupBy){
                                logger.info(&quot;[Find StatesSet ] :  Inside FindStatesSet Function &quot;)
                                var statesSetData=null
                                var queryMap={}
                                if(JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).statesSetCollectionName){
                                var searchList = new Packages.java.util.ArrayList();
                                for (key in requestMap){
                                //logger.info(&quot;Iteration of searchMap : &quot;+key+&quot; : &quot;+requestMap[key])
                                searchList.add(new Packages.com.mongodb.BasicDBObject(key, requestMap[key]));
                                }
                                queryMap.collectionName = JSON.parse(configurationMap.get(&apos;collectionsName&apos;)).statesSetCollectionName;
								
								if(groupBy == &quot;OR&quot;){
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$or&apos;, searchList);
                                }else{
                                queryMap.find = new Packages.com.mongodb.BasicDBObject(&apos;$and&apos;, searchList);
                                }
                                statesSetData= MongoGlobalService(&quot;search&quot;, queryMap)
                                }else{
                                logger.error(&quot;StatesSet collectionName is not defined in configurationMap&quot;)
                                }
                                return statesSetData
                                }</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
      <codeTemplateLibrary version="3.9.1">
        <id>5d548eec-46c6-4f53-a581-36c9b7158f28</id>
        <name>Library3</name>
        <revision>5</revision>
        <lastModified>
          <time>1676491698559</time>
          <timezone>UTC</timezone>
        </lastModified>
        <description>This library was added upon migration to version 3.3.0. It includes all pre-existing
					code templates, and is set to be included on all pre-existing and new channels.

					You should create your own new libraries and assign code templates to them as you
					see fit. You should also link libraries to specific channels, so that you&apos;re not
					necessarily including all code templates on all channels all the time.</description>
        <includeNewChannels>true</includeNewChannels>
        <enabledChannelIds>
          <string>8ffc3435-69a9-4e3c-a7b3-d92bfe08016a</string>
          <string>5dd1cce0-fcd2-4756-900f-47b157f17690</string>
          <string>5132c870-257f-48e3-b84e-debac4e0e5a9</string>
          <string>e008e757-f101-41e7-ac81-a419eccf03e7</string>
          <string>c26500eb-4156-4b43-a728-7fc83ea66ef5</string>
          <string>c6466272-70fe-487b-9a58-d324da917123</string>
          <string>b0583467-c7c3-47c6-8b17-8aa320566e3f</string>
          <string>445eabb1-95d3-4aef-b62b-f09aca726e54</string>
          <string>7417b5c9-167d-4454-b000-938d0cfca42d</string>
          <string>7b7806be-7905-4903-a811-d9066889a438</string>
          <string>b7f713c7-9538-4fe5-8217-622ba55ac61d</string>
          <string>b9ef20c1-c6e5-4f04-b3fa-40798e5e8338</string>
          <string>4dad803b-8ae7-4ccd-8a63-f5b7ad900c34</string>
          <string>f6261a9b-8e35-45c7-bf71-eaf64d284e8c</string>
          <string>22a6ce40-6759-402c-8659-bca069ddfe01</string>
          <string>e84827ea-74b1-4f4c-a3be-96a9346be3bb</string>
          <string>e6076476-33c6-4be3-941b-bad549d0474d</string>
          <string>7bf4680d-681f-4e7c-8d10-9e46f09c6db2</string>
          <string>68aa9bb6-1660-41ce-9350-75b8346ed0b8</string>
          <string>4c4573eb-8d5e-42e3-b9b4-601cdeabc52c</string>
          <string>d3080587-4d1e-43dd-b781-ae0af20a5080</string>
          <string>21f51dff-edbd-470a-8b2b-ac699af9efdc</string>
          <string>b40ddb05-b83f-4f2f-893e-5832148a0ff0</string>
          <string>1847a579-d828-424e-8cf7-572c7d01b8e9</string>
          <string>17457ef9-620e-4483-8350-63712c280a17</string>
          <string>9e1ff5bf-d9f6-48ef-8abb-f17be6ccbaf6</string>
          <string>52813cf4-4010-4933-836f-fed56c4b3eee</string>
          <string>df92d515-874e-49c9-a657-1cc61f9c71f1</string>
          <string>4160d5f3-b0cb-460a-b251-3fe11e3b88d6</string>
          <string>e3d7e84a-4137-4309-9da8-cd0135aa4135</string>
          <string>4c6a94d2-e3ff-4a5b-bd8f-e255df225c77</string>
          <string>52d24934-4dfd-43ee-9efd-e4e5a8a31fca</string>
          <string>29c4042f-f4a3-44ba-aab6-c60c4d963d1c</string>
          <string>4909ccd0-ba5b-469d-afb3-9864e09cd468</string>
          <string>b8752714-2ffb-4c15-a27b-a1b02592f0f2</string>
          <string>063d6304-cd71-45d6-92a5-d9efbdb2fdfa</string>
        </enabledChannelIds>
        <disabledChannelIds/>
        <codeTemplates>
          <codeTemplate version="3.9.1">
            <id>34684e0a-f581-45e7-b1a8-666876131ca1</id>
            <name>Convert CSV Date Format</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522847823</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
								Convert CSV Date Format
								*/
								// modify function_name and parameters as you wish.
								// one function per template is recommended. i.e.) create a new code template for each new function.
								function convertCSVDateString(dtStr) {

								var convertedString;
								var dateStrLength = dtStr.length;
								//logger.info(&quot;convertCSVDateString: The date string -&quot; +  dtStr + &quot;- is of length &quot; + dateStrLength);

								try{
								if(dateStrLength == 19){
								convertedString = DateUtil.convertDate(&quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;yyyyMMddHHmmss&quot;, dtStr);

								}else if(dateStrLength == 16){
								convertedString = DateUtil.convertDate(&quot;yyyy-MM-dd HH:mm&quot;, &quot;yyyyMMddHHmmss&quot;, dtStr);

								}else if(dateStrLength == 13){
								convertedString = DateUtil.convertDate(&quot;yyyy-MM-dd HH&quot;, &quot;yyyyMMddHHmmss&quot;, dtStr);

								}else if(dateStrLength == 10){
								convertedString = DateUtil.convertDate(&quot;yyyy-MM-dd&quot;, &quot;yyyyMMddHHmmss&quot;, dtStr);

								}else{
								convertedString = dtStr;
								}
								}catch(mee){

								//logger.error(&quot;There was an exception in parsing the datetime: &quot; + mee.message);
								logger.error(&quot;There was an exception in parsing the datetime in code template: &quot; + dtStr + &quot;-&quot; + mee.message);
								convertedString = null;
								}

								//logger.info(&quot;convertCSVDateString: The converted date string is : &quot; +  convertedString);
								return convertedString;
								}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>b41f3032-0e7b-460d-9532-0c07f98eafb8</id>
            <name>Convert CSV Physician Name to HL7 format</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522845365</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
								Convert CSV Physician Name to HL7 format
								*/
								// modify function_name and parameters as you wish.
								// one function per template is recommended. i.e.) create a new code template for each new function.
								function convertCSVPhysName(physName) {
								//logger.info(&quot;The physician name recieved is : &quot; + physName);

								// write code here.
								var salutation = &quot;&quot;;
								var firstName = &quot;&quot;;
								var middleName = &quot;&quot;;
								var lastName = &quot;&quot;;
								var listOfSalutations = [&apos;Dr&apos;,&apos;Dr.&apos;,&apos;Mr&apos;,&apos;Mr.&apos;,&apos;Mrs&apos;,&apos;Mrs.&apos;,&apos;Ms&apos;,&apos;Ms.&apos;];

								var nameArr = physName.split(&quot; &quot;);

								lastName = nameArr[nameArr.length - 1 ];

								//checking to see if the 1st word is a salutation
								for (var i = 0; i&lt; listOfSalutations.length; i++){
								if (listOfSalutations[i] == nameArr[0]){ salutation = nameArr[0]; }
								}
								var salutationLen = salutation.length;

								//determining first and middle name
								if (listOfSalutations.length == 2) {
								if (salutationLen == 0){ firstName = nameArr[0];}
								} else if (listOfSalutations.length == 3) {
								if (salutationLen == 0){
								firstName = nameArr[0];
								middleName = nameArr[1];
								} else {
								firstName = nameArr[1];
								}
								} else if (listOfSalutations.length &gt;= 4) {
								middleName = nameArr[nameArr.length - 2];
								if(!middleName)
								middleName = &apos;&apos;;

								if (salutationLen == 0){
								// second last work is middle name and rest is first name.
								for ( var j = 0; j &lt; nameArr.length - 2; j++){	firstName += nameArr[j]+&quot; &quot;; }
								} else {
								for ( var j = 1; j &lt; nameArr.length - 2; j++){	firstName +=  nameArr[j]+&quot; &quot;; }
								}
								firstName = firstName.replace(/\s+$/g, &apos;&apos;);
								}

								//logger.info(&quot;The extracted name is : Last Name = &quot; + lastName + &quot;, First Name = &quot; + firstName + &quot;, Middle = &quot; + middleName + &quot; and salutation = &quot; + salutation);
								var hl7Name = lastName + &quot;^&quot; + firstName + &quot;^&quot; + middleName + &quot;^&quot; + salutation;
								return hl7Name;
								}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>73ea412e-64b6-4029-90fb-72f6cff57e2a</id>
            <name>Convert Microbiogy Result Text to Code</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522847007</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
								Convert Microbiogy Result Text to Code
								*/
								// modify function_name and parameters as you wish.
								// one function per template is recommended. i.e.) create a new code template for each new function.
								function convertMBResultText(resultText) {
								var codeHash = new Object();
								codeHash[&apos;Sensitive&apos;] = &quot;S&quot;;
								codeHash[&apos;Resistant&apos;] = &quot;R&quot;;
								codeHash[&apos;Intermediate&apos;] = &quot;I&quot;;

								var mbCodeVal = codeHash[resultText];

								if ((mbCodeVal) &amp;&amp; (mbCodeVal.length &gt; 0)){
								return mbCodeVal;
								} else {
								return resultText;
								}

								}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>49b028b1-4295-4b75-86eb-6229148f8aeb</id>
            <name>createPractitionerJson</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522846905</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
								Modify the description here. Modify the function name and parameters as needed. One function per
								template is recommended; create a new code template for each new function.

								@param {Any} msg -
								@param {Any} messageType -
								@param {Any} objectType -
								@return {String} return description
								*/
								function createPractitionerJson(msg, messageType, objectType)
								{
								logger.info(&quot;Going to create the practitioner json for messageType = &quot;+messageType+&quot; and objectType = &quot;+objectType)

								var practitionerList = new Array();


								if(objectType &amp;&amp; objectType != &quot;&quot;)
								{
								if(messageType == &quot;REF&quot;)
								{
								var refPhyMap = createRefPhysJsonSegment(objectType,msg);
								return refPhyMap;
								}
								var practMap = createPhysJsonSegment(objectType,msg);
								return practMap;
								}

								if(msg[&apos;PV1&apos;].length() &gt; 0)
								{
								for each (pv7 in msg[&apos;PV1&apos;][&apos;PV1.7&apos;]){
								var practMap = createPhysJsonSegment(&apos;PV1.7&apos;,pv7);
								if(practMap.hasOwnProperty(&apos;identifierDTO&apos;))
								{
								practMap.practitionerType  = &quot;ATTENDING_DOCTOR&quot;;
								practitionerList.push(practMap)
								}
								}
								for each (pv17 in msg[&apos;PV1&apos;][&apos;PV1.17&apos;]){
								var practMap = createPhysJsonSegment(&apos;PV1.17&apos;,pv17);
								if(practMap.hasOwnProperty(&apos;identifierDTO&apos;))
								{
								practMap.practitionerType  = &quot;ADMITTING_DOCTOR&quot;;
								practitionerList.push(practMap);
								var primaryPracMap = {};
								primaryPracMap.identifierDTO = practMap.identifierDTO
								primaryPracMap.humanNameDTO = practMap.humanNameDTO
								primaryPracMap.practitionerRoles = practMap.practitionerRoles
								primaryPracMap.practitionerType  = &quot;PRIMARY_PERFORMER_DOCTOR&quot;;
								practitionerList.push(primaryPracMap);
								}
								}
								for each (pv8 in msg[&apos;PV1&apos;][&apos;PV1.8&apos;]){
								var practMap = createPhysJsonSegment(&apos;PV1.8&apos;,pv8);
								if(practMap.hasOwnProperty(&apos;identifierDTO&apos;))
								{
								practMap.practitionerType  = &quot;REFERRING_DOCTOR&quot;;
								practitionerList.push(practMap)
								}
								}
								for each (pv9 in msg[&apos;PV1&apos;][&apos;PV1.9&apos;]){
								var practMap = createPhysJsonSegment(&apos;PV1.9&apos;,pv9);
								if(practMap.hasOwnProperty(&apos;identifierDTO&apos;))
								{
								practMap.practitionerType  = &quot;CONSULTING_DOCTOR&quot;;
								practitionerList.push(practMap)
								}
								}
								//practMap -&gt; Put all physician information related to PV1 (addtending, admitting, PPRF)
								}

								if(messageType == &quot;ADT&quot;)
								{
								//Need to put the additional doctor information if required.
								}
								if(messageType == &quot;ORM_LAB&quot; || messageType == &quot;ORU_LAB&quot;)
								{
								//Need to put the additional doctor information if required.
								}
								if((messageType == &quot;ORM&quot; || messageType == &quot;ORU&quot;) &amp;&amp; msg[&apos;OBR&apos;].length() &gt; 0)
								{
								//Need to put the additional doctor information if required.
								for each (obr16 in msg[&apos;OBR&apos;][0][&apos;OBR.16&apos;]){
								var practMap = createPhysJsonSegment(&apos;OBR.16&apos;,obr16);
								if(practMap.hasOwnProperty(&apos;identifierDTO&apos;))
								{
								practMap.practitionerType  = &quot;ORDERER_DOCTOR&quot;;
								practitionerList.push(practMap)
								}
								}
								}
								if(messageType == &quot;MDM&quot; &amp;&amp; msg[&apos;TXA&apos;].length() &gt; 0)
								{
								for each (txa5 in msg[&apos;TXA&apos;][0][&apos;TXA.5&apos;]){
								var practMap = createPhysJsonSegment(&apos;TXA.5&apos;,txa5);
								if(practMap.hasOwnProperty(&apos;identifierDTO&apos;))
								{
								practMap.practitionerType  = &quot;PERFORMER_DOCTOR&quot;;
								practitionerList.push(practMap)
								}
								}
								}
								//Here we have the different approach to create the practitioner structure.
								if(messageType == &quot;MFN&quot; &amp;&amp; msg[&apos;PRA&apos;].length() &gt; 0)
								{
								var practMap = {};
								var humanNameDTO = new Array();
								var identifierDTO = new Array();
								for each (pra in msg[&apos;PRA&apos;][0][&apos;PRA.6&apos;]){
								var identifierTmp = {};
								identifierTmp.assigningAuthority = pra[&apos;PRA.6.2&apos;].toString();
								identifierTmp.identifier = pra[&apos;PRA.6.1&apos;].toString();
								identifierTmp.typeCode = pra[&apos;PRA.6.3&apos;].toString();
								identifierDTO.push(identifierTmp)
								if(pra[&apos;PRA.6.3&apos;].toString() == &quot;PN&quot; || pra[&apos;PRA.6.3&apos;].toString() == &quot;MD&quot; || pra[&apos;PRA.6.3&apos;].toString() == &quot;KTP&quot;)
								{
								practMap.physicianIdForLocationMapping = pra[&apos;PRA.6.1&apos;].toString();
								}
								}
								/*for each (pra in msg[&apos;PRA&apos;][0][&apos;PRA.5&apos;]){
								var practitionerRoles = new Array();
								var practitionerRolesTmp = {};
								practitionerRolesTmp.roleText = msg[&apos;PRA&apos;][0][&apos;PRA.3&apos;][&apos;PRA.3.1&apos;].toString().trim();
								practitionerRolesTmp.specialityText = pra[&apos;PRA.5.1&apos;].toString().trim();
								practitionerRolesTmp.specialityCode = pra[&apos;PRA.5.2&apos;].toString().trim();
								practitionerRoles.push(practitionerRolesTmp);
								practMap.practitionerRoles = practitionerRoles;
								}*/
								if(msg[&apos;STF&apos;].length() &gt; 0)
								{
								//Physician Name
								var humanName = {};
								humanName.firstName = msg[&apos;STF&apos;][0][&apos;STF.3&apos;][&apos;STF.3.2&apos;].toString();
								humanName.middleName = msg[&apos;STF&apos;][0][&apos;STF.3&apos;][&apos;STF.3.3&apos;].toString();
								humanName.lastName = msg[&apos;STF&apos;][0][&apos;STF.3&apos;][&apos;STF.3.1&apos;].toString();
								humanName.prefix = msg[&apos;STF&apos;][0][&apos;STF.3&apos;][&apos;STF.3.5&apos;].toString();
								humanNameDTO.push(humanName)
								practMap.humanNameDTO = humanNameDTO;
								practMap.gender  = msg[&apos;STF&apos;][0][&apos;STF.5&apos;][&apos;STF.5.1&apos;].toString();
								practMap.dateOfBirth  = getISO8601DateFormat(msg[&apos;STF&apos;][0][&apos;STF.6&apos;][&apos;STF.6.1&apos;].toString());
								practMap.locationActivationDate = getISO8601DateFormat(msg[&apos;STF&apos;][0][&apos;STF.12&apos;][&apos;STF.12.1&apos;].toString());
								practMap.locationInactivationDate = getISO8601DateFormat(msg[&apos;STF&apos;][0][&apos;STF.13&apos;][&apos;STF.13.1&apos;].toString());

								//Physician telecom
								var telecomList = new Array();
								for each (stf10 in msg[&apos;STF&apos;][0][&apos;STF.10&apos;]){
								var phoneNumber = {}
								phoneNumber.countryCode = configurationMap.get(&apos;defaultCountryCode&apos;);
								phoneNumber.value = stf10[&apos;STF.10.1&apos;]
								phoneNumber.system = &quot;phone&quot;;
								phoneNumber.useCode = &quot;home&quot;;
								telecomList.push(phoneNumber)
								}
								for each (stf15 in msg[&apos;STF&apos;][0][&apos;STF.15&apos;]){
								var email = {}
								email.value = stf15[&apos;STF.15.1&apos;]
								email.system = &quot;email&quot;;
								email.useCode = &quot;email&quot;;
								telecomList.push(email)
								}
								practMap.telecomList = telecomList

								//Physician Address
								var addressList = new Array();
								for each (stf11 in msg[&apos;STF&apos;][0][&apos;STF.11&apos;]){
								var address = {};
								address.line1 = stf11[&apos;STF.11.1&apos;];
								address.line2 = stf11[&apos;STF.11.2&apos;];
								address.city = stf11[&apos;STF.11.3&apos;];
								//address.district = stf11[&apos;STF.11.9&apos;];
								address.state = stf11[&apos;STF.11.4&apos;];
								address.zip = stf11[&apos;STF.11.5&apos;];
								address.country = stf11[&apos;STF.11.6&apos;];
								addressList.push(address)
								}
								practMap.addresses = addressList;
								}

								practMap.accreditation = msg[&apos;PRA&apos;][0][&apos;PRA.7&apos;][&apos;PRA.7.1&apos;].toString();
								practMap.practiceName = msg[&apos;PRA&apos;][0][&apos;PRA.2&apos;][&apos;PRA.2.2&apos;].toString();
								practMap.identifierDTO = identifierDTO;
								practMap.practitionerType  = &quot;ORDERER_DOCTOR&quot;;

								if(msg[&apos;EDU&apos;].length() &gt; 0)
								{
								var eduSegmentsList = new Array();
								for each (edu in msg[&apos;EDU&apos;]){
								var eduSegments = {};
								eduSegments.academicDegree = edu[&apos;EDU.2&apos;][&apos;EDU.2.1&apos;].toString();
								eduSegments.academicDegreeGrantedDate = edu[&apos;EDU.6&apos;][&apos;EDU.6.1&apos;].toString();
								eduSegmentsList.push(eduSegments)
								}
								practMap.eduSegments = eduSegmentsList;
								}
								if(msg[&apos;ZPH&apos;].length() &gt; 0)
								{
								practMap.experience = msg[&apos;ZPH&apos;][0][&apos;ZPH.1&apos;][&apos;ZPH.1.1&apos;].toString();
								}

								practitionerList.push(practMap)
								}

								return practitionerList;
								}

								function createPhysJsonSegment(segment,obj){
								var practMap = {};
								var humanNameDTO = new Array();
								var identifierDTO = new Array();
								if(obj){
								if(obj[segment+&apos;.1&apos;].toString() &amp;&amp; obj[segment+&apos;.1&apos;].toString().trim() != &quot;&quot;)
								{
								var identifierTmp = {};
								identifierTmp.assigningAuthority = obj[segment+&apos;.9&apos;].toString();
								identifierTmp.identifier = obj[segment+&apos;.1&apos;].toString();
								identifierTmp.typeCode = obj[segment+&apos;.13&apos;].toString();
								identifierDTO.push(identifierTmp)
								practMap.identifierDTO = identifierDTO;
								}
								var humanName = {};
								humanName.firstName = obj[segment+&apos;.3&apos;].toString();
								humanName.middleName = obj[segment+&apos;.4&apos;].toString();
								humanName.lastName = obj[segment+&apos;.2&apos;].toString();
								humanName.prefix = obj[segment+&apos;.6&apos;].toString();
								humanNameDTO.push(humanName);
								practMap.humanNameDTO = humanNameDTO;
								if(obj[segment+&apos;.21&apos;].toString() &amp;&amp; obj[segment+&apos;.21&apos;].toString().trim() != &quot;&quot;)
								{
								var practitionerRoles = new Array();
								var practitionerRolesTmp = {};
								practitionerRolesTmp.roleText = obj[segment+&apos;.21&apos;].toString().trim();
								//practitionerRolesTmp.specialityText = specialityText;
								practitionerRoles.push(practitionerRolesTmp);
								practMap.practitionerRoles = practitionerRoles;
								}
								}
								return practMap;
								}

								function getISO8601DateFormat(dateString)
								{
								completeDateString = &apos;&apos;;
								if(dateString.length &gt;=8 ) {
								var year = dateString.substring(0,4)+&apos;-&apos;;
								var month = dateString.substring(4,6)+&apos;-&apos;;
								var day = dateString.substring(6,8);
								completeDateString = year+month+day+&quot;T00:00:00.000+0000&quot;; // creating an ISO8601 format date string
								}
								return completeDateString
								}
								function createRefPhysJsonSegment(segment,obj){
								var practMap = {};
								var humanNameDTO = new Array();
								var identifierDTO = new Array();
								if(obj){
								if(obj[segment+&apos;.7&apos;] &amp;&amp; obj[segment+&apos;.7&apos;][segment+&apos;.7.1&apos;].toString() &amp;&amp; obj[segment+&apos;.7&apos;][segment+&apos;.7.1&apos;].toString().trim() != &quot;&quot;)
								{
								var identifierTmp = {};
								identifierTmp.assigningAuthority = &quot;Minerva&quot;;
								identifierTmp.identifier = obj[segment+&apos;.7&apos;][segment+&apos;.7.1&apos;].toString();
								identifierTmp.typeCode = obj[segment+&apos;.7&apos;][segment+&apos;.7.2&apos;].toString();
								identifierTmp.useCode = &quot;usual&quot;;
								identifierDTO.push(identifierTmp)
								practMap.identifierDTO = identifierDTO;
								}
								var humanName = {};
								humanName.firstName = obj[segment+&apos;.2&apos;][segment+&apos;.2.2&apos;].toString();
								humanName.middleName = obj[segment+&apos;.2&apos;][segment+&apos;.2.3&apos;].toString();
								humanName.lastName = obj[segment+&apos;.2&apos;][segment+&apos;.2.1&apos;].toString();
								humanName.prefix = obj[segment+&apos;.2&apos;][segment+&apos;.2.5&apos;].toString();
								humanNameDTO.push(humanName);
								practMap.humanNameDTO = humanNameDTO;
								/*if(obj[segment+&apos;.1&apos;] &amp;&amp; obj[segment+&apos;.1&apos;][segment+&apos;.1.1&apos;].toString() &amp;&amp; obj[segment+&apos;.1&apos;][segment+&apos;.1.1&apos;].toString().trim() != &quot;&quot;)
								{
								var practitionerRoles = new Array();
								var practitionerRolesTmp = {};
								var roleText = &quot;&quot;;
								if(obj[segment+&apos;.1&apos;][segment+&apos;.1.1&apos;].toString() == &quot;RP&quot;)
								{
								roleText = &quot;Referring Physician&quot;;
								}
								if(obj[segment+&apos;.1&apos;][segment+&apos;.1.1&apos;].toString() == &quot;RT&quot;)
								{
								roleText = &quot;Referred to Physician&quot;;
								}
								practitionerRolesTmp.roleText = roleText;
								//practitionerRolesTmp.specialityText = specialityText;
								practitionerRoles.push(practitionerRolesTmp);
								practMap.practitionerRoles = practitionerRoles;
								}*/
								}
								return practMap;
								}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>946da289-0432-499b-9a45-bec0140e23a6</id>
            <name>getDatefromOtherTimeZoneDate</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522847188</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
								Modify the description here. Modify the function name and parameters as needed. One function per
								template is recommended; create a new code template for each new function.

								@param {Any} inDatePattern -
								@param {Any} outDatePattern -
								@param {Any} inTimeZone -
								@param {Any} outTimeZone -
								@param {Any} inDate -
								@return {String} return description
								*/
								function getDatefromOtherTimeZoneDate(inDatePattern,outDatePattern,inTimeZone,outTimeZone,inDate) {
								var result = &quot;&quot;;
								try
								{
								logger.info(&quot;In getDatefromOtherTimeZoneDate inDatePattern=&quot;+inDatePattern+&quot; outDatePattern=&quot;+outDatePattern+&quot; inTimeZone=&quot;+inTimeZone+&quot; outTimeZone=&quot;+outTimeZone+&quot; inDate=&quot;+inDate);
								var  dateObj = Packages.org.joda.time.format.DateTimeFormat.forPattern(inDatePattern).withZone(Packages.org.joda.time.DateTimeZone.forID(inTimeZone)).parseDateTime(inDate);
								logger.info(&quot;Data regarding dateObj &quot;+dateObj)
								result = Packages.org.joda.time.format.DateTimeFormat.forPattern(outDatePattern).print(dateObj.withZone(Packages.org.joda.time.DateTimeZone.forID(outTimeZone)));
								logger.info(&quot;Data regarding result &quot;+result)
								}
								catch(e)
								{
								logger.error(&quot;Error during parsing the date in getDatefromOtherTimeZoneDate inDatePattern=&quot;+inDatePattern+&quot; outDatePattern=&quot;+outDatePattern+&quot; inTimeZone=&quot;+inTimeZone+&quot; outTimeZone=&quot;+outTimeZone+&quot; inDate=&quot;+inDate+&quot; Error\n&quot;+e);
								}
								return result;
								}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.9.1">
            <id>349f0c01-ec08-4627-9f34-23989b1ae544</id>
            <name>Specialty Creation Data</name>
            <revision>1</revision>
            <lastModified>
              <time>1671522848192</time>
              <timezone>UTC</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>
								var jsonSpecialty = &apos;{&quot;identifier&quot; : [ { &quot;type&quot; : { &quot;text&quot; : { &quot;value&quot; : &quot;serviceTypeIdentifier&quot; } }, &quot;useCode&quot; : { &quot;value&quot; : &quot;usual&quot; }, &quot;value&quot; : { &quot;value&quot; : &quot;18&quot; } } ], &quot;specialty&quot; : [ { &quot;coding&quot; : [ { &quot;display&quot; : { &quot;value&quot; : &quot;ORTHOPAEDICS&quot; } } ], &quot;text&quot; : { &quot;value&quot; : &quot;ORTHOPAEDICS&quot; } } ], &quot;type&quot; : { &quot;coding&quot; : [ { &quot;display&quot; : { &quot;value&quot; : &quot;ORTHOPAEDICS&quot; } } ] }, &quot;version&quot; :0 }&apos;

								var jsonHealth = &apos;{ &quot;eligibility&quot; : { &quot;coding&quot; : [ { &quot;display&quot; : { &quot;value&quot; : &quot;Inactive&quot; } } ], &quot;text&quot; : { &quot;value&quot; : &quot;Active&quot; } }, &quot;extension&quot; : [ { &quot;url&quot; : &quot;accessControl&quot;, &quot;value&quot; : [ { &quot;bookableRoles&quot; : [ &quot;ROLE_FULL_ACCESS&quot; ], &quot;requestableRoles&quot; : [ &quot;ROLE_PATIENT&quot; ] } ] } ], &quot;identifier&quot; : [ { &quot;type&quot; : { &quot;coding&quot; : [ { &quot;display&quot; : { &quot;value&quot; : &quot;hcsIdentifier&quot; } } ], &quot;text&quot; : { &quot;value&quot; : &quot;hcsIdentifier&quot; } }, &quot;useCode&quot; : { &quot;value&quot; : &quot;usual&quot; }, &quot;value&quot; : { &quot;value&quot; : &quot;18&quot; } } ],  &quot;serviceCategory&quot; : { &quot;coding&quot; : [ { &quot;display&quot; : { &quot;value&quot; : &quot;specialty&quot; } } ], &quot;text&quot; : { &quot;value&quot; : &quot;specialty&quot; } }, &quot;serviceName&quot; : { &quot;value&quot; : &quot;ORTHOPAEDICS&quot; }, &quot;coverageArea&quot; : [ ] }&apos;

								function getSpecialtyData(type) {
								if(type == &quot;specialty&quot;){
								logger.info(&quot;As the type is: &quot;+type+&quot; Returning jsonSpecialty&quot;);
								return jsonSpecialty;
								}
								else if(type == &quot;healthCareService&quot;){
								logger.info(&quot;As the type is: &quot;+type+&quot; Returning jsonHealth&quot;);
								return jsonHealth;
								}
								else{
								logger.info(&quot;As the type is: &quot;+type+&quot; Returning null&quot;);
								return null;
								}

								}</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
    </codeTemplateLibraries>
  </exportData>
</channel>